<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学术论文中的英文表达</title>
      <link href="/2019/07/21/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E8%8B%B1%E6%96%87%E8%A1%A8%E8%BE%BE/"/>
      <url>/2019/07/21/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E8%8B%B1%E6%96%87%E8%A1%A8%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<ul><li>prioritize</li><li>state-of-the-art</li><li>twice as many number</li><li>respectively</li><li>pair wise</li><li>Whereas</li><li>infrastructure</li><li>benchmark</li><li>identical</li><li>merit</li><li>figure of merit</li><li>in the stage of infancy</li><li>representative</li><li>application-agnostic</li><li>fidelity</li><li>crucial hurdle</li><li>exploit</li><li>Iterate through all the layers</li><li>temporal</li><li>spatial</li><li>Figure-of-Merit</li><li>that using cost function and heuristics based on the number of hops or</li><li>Manhattan distance</li><li>Revised</li><li>in terms of</li><li>overhead</li><li>outperform</li><li>analogous</li><li>fidelity</li><li>address these drawbacks mentioned above</li><li>trade-off</li><li>leveraging</li><li>overhead</li><li>mathematically equivalent</li><li>unitary</li><li>implies that</li><li>accounts for</li><li>dictates</li><li>comprised of</li><li>resultant</li><li>metric：度量标准</li><li>leads to</li><li>mitigate：缓和</li><li>cascade</li><li>Algorithms exist that does：主语从句</li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-07-21-论文阅读-量子计算-ISCA_2019_Kaitlin</title>
      <link href="/2019/07/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ISCA-2019-Kaitlin/"/>
      <url>/2019/07/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ISCA-2019-Kaitlin/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文总结 </tag>
            
            <tag> 量子计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读_量子计算_1809.02573v2</title>
      <link href="/2019/07/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-1809-02573v2/"/>
      <url>/2019/07/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-1809-02573v2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1809.02573" target="_blank" rel="noopener">Tackling the Qubit Mapping Problem for NISQ-Era  Quantum Devices</a></p><h1>问题</h1><h2>不理解的名词</h2><ul><li>保留遍历搜索技术</li><li>全局优化初始映射</li></ul><h1>名词</h1><ul><li>quantum circuit：量子线路，是在抽象概念下，对量子信息存储单元进行操作的线路。组成包括：量子位、线路（时间线）、逻辑门。</li><li>Directed Acyclic Graph：DAG，有向非循环图</li></ul><h1>摘要</h1><p>由于对量子计算的硬件条件考虑不足，比如说没有考虑二量子位操作的物理连接不足的问题，一般的NISQ无法执行大多数的量子算法。动态重映射策略被创建，来解决这些问题。但是动态重映射策略不能保证程序的可靠性，策略复杂度高，初始映射差，可控性和灵活性低。</p><p>提出了一种基于交换的双向启发式搜索算法(SABRE)，适用于量子位任意连接的NISQ设备。通过优化每一次搜索尝试，采用新型的反向遍历技术，全局优化了初始映射。引入了了衰减效应，能够衡量搜索的深度和整个系统的门的个数。SABRE比其他的已知最好的指数级算法好一些。</p><h1>介绍</h1><p>量子计算机虽然无法实现QEC，但是也可以干很多事情。软硬差距存在，现有的NISQ体系结构无法支持大型量子程序有效执行。本文章专注于由于NISQ设备限制而产生的二量子位操作问题。逻辑量子位分配到物理量子位上，类比传统计算机就是寄存器分配。</p><p>实际量子线路无法直接在NISQ上执行，因此需要进行量子电路转换，实现量子程序在NISQ设备上的使用，步骤有：</p><ol><li>初始逻辑量子位到物理量子位的映射</li><li>映射变换，使要进行门运算的两个逻辑量子位重映射到两个相邻物理量子位上。</li></ol><p>之前的方法有：</p><ol><li>构建数学问题，采用求解器解决。缺点是求解速度慢，只能对小规模数据使用，不能利用问题内部特征。</li><li>启发式搜索算法，大多数是在理想的1D / 2D晶格模型上开发的，不适用于具有更多不规则和受限制的耦合连接的NISQ器件。</li><li>针对IBM QX的搜索算法，穷尽搜索，运行速度慢，缺少全局优化能力，在多目标优化条件下，无法保证生成的量子电路的质量。</li></ol><p>本文提出了：</p><ol><li>基于交换的双向启发式搜索算法，解决量子位映射问题。</li><li>穷尽搜索很多步骤是多余的，SABRE方法大量减少了搜索空间。</li><li>初始化映射极为重要，可以影响最终电路质量。采用创新的保留遍历搜索技术。通过遍历反向电路，可以产生高质量的初始映射。在这个过程中更重视电路开始的位置，不忽视电路其他部分。</li><li>引入衰减效应，可以使重叠的SWAP操作造成启发式代价函数值变高，因此更支持不重叠的SWAP操作。这种优化可以鼓励并行性，并且可以在电路深度和门数之间进行权衡，从而进一步生成不同的硬件兼容电路。</li></ol><p>本文贡献在于：</p><ol><li>对基于启发式搜索算法的量子位映射问题总结了目标和度量标准</li><li>提出了基于SWAP的搜索模式，比穷尽搜索模式优秀，允许向NISQ时代的可扩展性。</li><li>提出了反向遍历策略，利用量子位映射问题的内在可逆性，在初始映射解决方案中实现全局优化。</li><li>在启发式搜索策略中提出衰减代价函数，能产生适用于不同硬件的量子电路。</li></ol><h1>背景</h1><h2>软件基础</h2><p>多种量子模型是数学等价的，量子电路模型是最流行的。</p><ul><li>量子位</li><li>量子操作</li><li>量子线路</li></ul><h2>在NISQ时代的QC硬件</h2><p>实现量子计算的硬件方法有：超导量子电路、离子阱、量子点、中性原子等。目前最可靠的技术是超导量子电路。</p><p>文章中考虑硬件约束包括：</p><ol><li>量子位生存时间</li><li>量子位操作错误率，因为量子门会导致错误，因此要尽可能缩减量子门的数目</li><li>量子位连接。</li></ol><h1>问题分析</h1><ul><li>SWAP操作解决不连通问题</li><li>其他方法解决不连通问题：基于先前的架构，不予考虑。</li><li>SWAP操作带来如下问题：操作指令数增加，导致总体错误率增加；电路层次增加，总执行时间增加，由decoherence导致的错误增加。由此要尽量减少SWAP操作个数。</li></ul><h2>构建问题</h2><p>找初始mapping、中间mapping的变换，最小化门操作个数，最小化量子线路层次。</p><h2>目标和度量标准</h2><ol><li>灵活性：对以后的量子计算机也需适用</li><li>可靠性：要尽量减少门个数</li><li>并行性：减少量子线路层次，允许更多的操作</li><li>可扩展性：在不使用QEC的情况下，问题是不变的。使用了QEC，会将问题转化为另一个。</li></ol><p>度量标准：门总数和量子线路深度。</p><h1>找初始化映射和SWAP</h1><h2>预处理</h2><ol><li>使用Floyd-Warshall算法计算距离矩阵</li><li>使用有向非循环图（DAG）表示在一个量子线路中的双量子比特位门的执行限制。单量子位的操作在这不予考虑，因为他们不涉及到其他量子位。</li><li>找到第一层：没有前驱节点，即入度为零的控制非门可以被放在第一层中。</li><li>临时初始映射生成：随机产生初始映射，作为启发式搜索的起始状态。</li></ol><h2>基于SWAP的启发式搜索</h2><p>算法1是一次遍历的搜索过程，从头到尾扫描，并插入SWAP操作，使得所有的CNOT都可以被执行。这个算法会被多次使用来更新优化初始映射。</p><p>拓扑排序方法</p><ol><li><p>检查F是否为空，若是，则停止，若否，则初始化Execute gate list。</p></li><li><p>对于F中现在的所有的门，取出这个门涉及到的两个量子位，查看他们所在的物理量子位有没有连接，如果有，则加入Execute gate list，否则不加入。</p></li><li><p>如果Execute gate list不为空，则将里面的所有门从F中删除掉。接下来检查后继的门，对于后继门的两个量子位，如果如果F中没有任何门指向这两个量子位的其中一个，则把这个后继门添加到F中。回到2。</p></li><li><p>如果Execute gate list为空，则所有的F中的门在硬件中不能被执行。需要插入SWAP操作。</p></li><li><p><strong>启发式搜索插入SWAP</strong>：初始化score。通过F和G找到SWAP的候选列表。对于F中的所有门的所有程序量子位，找到它对应的物理量子位，通过G找到和这个物理量子位相邻的其他物理量子位，根据映射找到这些物理量子位对应的程序量子位。原量子位和这些程序量子位可以被进行SWAP。加入到候选SWAP列表中。对于候选列表中的每一个候选SWAP，更新原映射，作为临时图，对其进行评分，选择评分最小的SWAP操作，并将原映射更新。回到1。</p><blockquote><p>在这里每次启发式搜索只搜索一步SWAP，下一次可能还是处于EExecute gate list为空的状态，这样就需进行下一步的启发式搜索，如果不为空，则可以继续进行拓扑排序。</p></blockquote></li></ol><p>算法中：</p><ul><li>Front layer F：其中的门都可以在逻辑上被执行</li><li>Mapping $\pi$：表示了从逻辑量子位到物理量子位的映射</li><li>Distance Matrix D：表示了两点间最少的SWAP数</li><li>Circuit Dag：有向无环图，代表量子线路结构</li><li>Chip Coupling Graph G：无向图，代表任意两个物理量子位之间的连接</li></ul><p>算法的优势：</p><ul><li>不是去搜索一个映射，而是去搜索在F中的量子位的SWAP。</li></ul><h2>解释关键设计决策</h2><ul><li>只有F中的门涉及到的量子位元参与的SWAP才有意义。</li><li>F后紧邻的量子位的距离也加入启发式函数的考虑，但不考虑再后面的，因为执行过程中，mapping的变化可能会很大。</li></ul><h3>时间复杂度分析（暂不理解）</h3><p>时间复杂度上限可以通过最坏情况来估计，也就是每两个比特位门都需要单独满足。</p><p>满足一个比特位门的时间复杂度是满足在搜索空间中的潜在选项、最大可能搜索空间、二比特位最大数目的搜索步数的一次搜索的乘积。启发式代价函数的时间复杂度是O（N）。</p><p>搜索空间从可以从O(exp(N))降到O(N)（最坏情况下所有量子比特位都在首层），</p><h3>初始映射的反遍历</h3><p>Siraichi没有考虑时间因素，Zulehner只考虑了最初映射，没有全局考虑。</p><p>量子电路是可逆的，可以获取到一个量子电路的逆电路。如果知道了最终电路，我们就可以把最终电路作为初始电路，解决映射问题。如果一次执行完成，得到的结果映射，可以作为我们开始执行时的初始映射，这样能够提供更好的效果。</p><p>首先随机生成初始映射，进过原量子线路，获得最终映射。将最终映射通过反向量子线路，获得更新后的初始映射。更新后的初始映射就在以后被作为优秀的映射方案。</p><h3>量子线路深度和门数的衡量</h3><ul><li>深度优先</li><li>门数少优先</li></ul><p>衰减效果被应用，来尽可能选择不相交的SWAP操作。</p><h2>启发式函数设计</h2><ol><li>H应该能代表SWAP的移动步数</li><li>能够帮助后期的SWAP采用更少的步数</li><li>能够鼓励并行操作，考虑线路深度和并行度的取舍。</li></ol><p>设计：</p><ol><li>F中所有元素对之间的距离和（来自Distance Matrix）</li><li>扩展集中的距离和</li><li>swap是否被重复使用</li></ol><p>$$H=\max \left(\operatorname{decay}\left(SWAP . q_{1}\right), \operatorname{decay}\left(SWAP . q_{2}\right)\right)\*\left{\frac{1}{|F|} \sum_{g a t e \in F} D\left[\pi\left(g a t e \cdot q_{1}\right)\right]\left[\pi\left(g a t e . q_{2}\right)\right]\+W * \frac{1}{|E|} \sum_{g a t e \in E} D\left[\pi\left(g a t e . q_{1}\right)\right]\left[\pi\left(g a t e . q_{2}\right)\right] \right}$$</p><h1>总结</h1><ul><li>物理量子位不能比程序量子位少</li><li>有限的物理连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文总结_量子计算_ASPLOS_2019_1</title>
      <link href="/2019/07/19/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ASPLOS-2019-1/"/>
      <url>/2019/07/19/%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ASPLOS-2019-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>存疑</p><p>baseline方法是如何使swap数最小的？</p><p>为啥有一个图先高后低，为啥变化大的，它的PST提升的就高</p></blockquote><h1>关于量子计算的知识</h1><p>量子计算中，量子计算机是不可靠不稳定的。可能发生操作错误和保持性错误。操作错误分单比特位操作和双比特位操作。严重程度：双比特位操作错误&gt;单比特位操作错误&gt;保持性错误。</p><p>量子计算通过多次执行量子程序，记录每次的观测结果，根据大数定律，正确事件出现的次数与总试验次数的比值会趋近于该事件的概率。</p><h1>简介</h1><p>传统噪声中尺度量子计算机（NISQ, Noisy Intermediate Scale Quantum computers），由于量子位太少（10x-100x），不能够采用QEC来执行错误检测和错误更正，因为QEC需要10-100个量子位来编码一个错误检测位。那么该如何有效提升量子计算机的可靠性呢？</p><p>作者通过分析IBM-Q20的特征数据发现，量子位和量子位之间的连接的错误率是不完全一致的，是多变的。为了利用这一特性，作者提出了VQM和VQA，能使程序量子位被分配到更好的物理量子位上，能使swap操作更多地发生在更可靠的链接上。</p><h1>基线策略</h1><p>VQM和VQA是在基线准则上进行改进所得到的策略。</p><p>基线策略采用SWAP次数作为价值参数。</p><p>前提假设：所有的SWAP操作代价相同</p><h2>基线映射策略</h2><ol><li>初始化无权无向图</li><li>使用最短路算法，计算任意两点纠缠所需最少的swap次数</li><li>程序指令分为n层，不同层包含不同的指令，不同层之间可以并行执行。</li><li>遍历所有的层，对于每一层，都要找到从程序量子位到物理量子位的映射，这样每一层的CNOT就可以有足够的物理连接被执行了。</li><li>对于每两层中间，通过A*搜索算法，以成本函数和基于曼哈顿距离的启发函数，搜索最优的SWAP集合，能使第一层的程序量子位到物理量子位的映射转化到第二层程序量子位到物理量子位的映射。</li></ol><blockquote><p>存疑：</p><p>量子程序中的指令是什么样子的？</p><p>分层是什么意思？分层依据的准则是什么？</p><p>这里的分层，每一层的所包含的程序量子位都完全一样？否则第5步中无法通过SWAP方法来把第一层的映射改为第二层的映射。</p></blockquote><h1>VQM</h1><ol><li>可构造无向有权图，采用最短路算法，计算距离矩阵</li><li>对每一个物理量子位计算节点强度，节点强度等于节点上的所有连线的权值</li><li>将输入程序分层</li><li>每一层寻找映射，映射要优先选择介电强度高的节点</li><li>找到从第一层映射到第二层映射的最优swap集，依据标准是最短路矩阵，有最大跳数的限制</li></ol><h1>VQA</h1><ol><li>找一个具有k个节点的子图，子图应当具有最大的ANS，ANS是子图中所有节点的边权的和的加和。</li><li>在前t层中，通过计算CNOT数，计算每个量子位的量子位活动</li><li>映射程序量子位到物理量子位，优先映射量子位活动较高的程序量子位</li><li>运用基线策略，找到层$l_i$和层$l_{i+1}$之间的映射</li></ol>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文总结 </tag>
            
            <tag> 量子计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读_量子计算_ASPLOS_2019_1</title>
      <link href="/2019/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB_%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97_ASPLOS_2019_1/"/>
      <url>/2019/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB_%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97_ASPLOS_2019_1/</url>
      
        <content type="html"><![CDATA[<p><a href="http://memlab.ece.gatech.edu/papers/ASPLOS_2019_1.pdf" target="_blank" rel="noopener">论文原文</a></p><h1>前提知识</h1><h2>希尔伯特空间(Hilbert Space)</h2><p>希尔伯特空间是复向量内积空间。</p><p>内积空间是两个向量上的函数并返回一个标量的二元运算，它的结果是欧几里得空间的标准内积。</p><p>一个量子系统的态空间一般用有限维度的Hilbert空间来表述，即可以用来表述<strong>量子系统的各种可能的量子态</strong>。</p><h2>量子两个基本状态</h2><h3>叠加态</h3><p>量子叠加态就是一个量子能在同一时间处于两种不同属性0和1的状态，而对于经典物理中，一个粒子只能处于一种状态，如要么左旋，要么右旋。</p><h3>纠缠态</h3><p>量子纠缠态，就是满足一定条件的情况下一个量子的行为将会影响到另一个量子的状态。即其中一个量子被操作改变而发生状态变化时，比如进行量子观测时，一个量子被观测为左旋。则另一个量子其状态立即发生相应的状态变化。而两个量子之间不存在一定相同或者相反的绝对规则。因此两个被纠缠的粒子可以是状态相同，也可以是状态相反。</p><h2>Bloch 球面</h2><p><a href="https://baike.baidu.com/item/%E5%B8%83%E6%B4%9B%E8%B5%AB%E7%90%83%E9%9D%A2/5542370?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>对量子位元这样的二阶量子系统而言，其存在的可能状态 $ |\psi\rangle $可以由两个互相正交的基底以复数线性叠加所构成，这两个基底可以选用$|0\rangle,|1\rangle$为代表。在物理实作上,$|0\rangle,|1\rangle$代表了做投影式量子测量所会得到的唯二结果。</p><p>从任意纯态出发，有：$$|\psi\rangle=\alpha|0\rangle+\beta|1\rangle, \alpha, \beta \in \mathbb{C}, \quad|\alpha|^{2}+|\beta|^{2}=1$$可设：$$\alpha=\cos \theta e^{i \delta}$$</p><p>$$\beta=\sin \theta e^{i(\delta+\phi)}$$</p><p>有：$$|\psi\rangle=\cos \theta e^{i \delta}|0\rangle+\sin \theta e^{i(\delta+\phi)}|1\rangle= e^{i \delta}\left(\cos \theta|0\rangle+\sin \theta e^{i \phi}|1\rangle\right)$$$e^{i \delta}$称共同相位，可以省略。$e^{i \phi}$称相对相位。有：$$|\psi\rangle=\cos \theta|0\rangle+\sin \theta e^{i \phi}|1\rangle$$因$cos\theta$和$sin\theta$为长度，所以都为非负实数，可以确定：$$0 \leq \theta \leq \frac{\pi}{2} \Rightarrow 0 \leq 2 \theta \leq \pi, \quad 0 \leq \phi&lt;2 \pi$$$x=\sin 2 \theta \times \cos \phi$的所有分布在三维空间中画出来，即布洛赫球面。$$\begin{array}{rlrl}{x} &amp; {=} &amp; {\sin 2 \theta \times \cos \phi} \ {y} &amp; {=} &amp; {\sin 2 \theta \times \sin \phi} \ {z} &amp; {=} &amp; {\cos 2 \theta}\end{array}$$</p><h2>欧拉公式</h2><p>$e^{ix}=cosx+isinx$</p><p>得到一个模为1的复向量,$x$是向量的角</p><h2>k-core</h2><ul><li>一个图G的 KCore 是G的子图</li><li>这个子图的每个顶点的度≥K</li></ul><h3>计算方法</h3><ol><li>每个顶点记录is_delete，current_degree</li><li>如果一个顶点的度数小于k，则从图中删除该顶点，给邻居发消息</li><li>顶点收到消息之后，更新自己的度。</li></ol><h1>论文阅读</h1><h2>待了解</h2><ul><li>希尔伯特空间</li><li><a href="https://baike.baidu.com/item/%E5%B8%83%E6%B4%9B%E8%B5%AB%E7%90%83%E9%9D%A2/5542370?fr=aladdin" target="_blank" rel="noopener">Bloch球面</a></li><li><a href="https://blog.csdn.net/Mr_KkTian/article/details/70158659" target="_blank" rel="noopener">k-core算法</a></li></ul><h2>问题</h2><ul><li>noisy是什么意思？</li><li>SWAP操作如何理解？和量子纠缠的关系是什么？</li><li>baseline mapping policy中</li><li>普通方法与本论文的本质区别在哪里？普通方法也知道有错误率，但是认为普通方法的错误率是全局一致的。</li><li>Algorithm2 中的量子位活动是什么？</li><li>error-configs？</li><li>量子程序中的Cx代表什么意思?</li><li>Fig15中的执行过程是怎么回事？其中的SWAP操作为什么是3次方的失败概率？</li></ul><h2>概念</h2><ul><li>NISQ： Noisy Intermediate Scale Quantum computers，噪声中尺度量子计算机，具有10至1000量子位。容错率低，但能为量子应用提供一些优势。</li><li>Qubit-Allocation：处理程序量子位到物理量子位的映射问题。</li><li>Qubit-Movement：选择将一个量子位状态移动到另一个量子位状态的路径的问题</li><li>量子纠缠：两个暂时耦合的粒子，不再耦合之后彼此之间仍旧维持的关联。通过“2量子位操作完成”。如果两量子位不存在connection，可以通过swap操作，使得两量子位挨在一起，之后通过2量子位操作完成量子纠缠。</li><li>VQM：Variation-Aware Qubit Movement，可变感知量子位移动</li><li>VQA：Variation-Aware Qubit Allocation，可变感知量子位分配</li><li>qubit device：量子位设备</li><li>QEC：Quantum error correction codes，量子位防止错误的方法：量子误差校正码</li><li>SWAP操作：量子计算机中，用来交换两个量子状态的操作，即量子纠缠</li><li>data qubit：量子位数据</li><li>phycal qubit：物理量子位</li><li>PST：Probability of Successful Trial，成功试验概率，表示程序在没有任何错误的情况下成功完成的概率，用于度量量子计算机性能</li><li>量子门 (Quantum gate，或量子逻辑门)是一个基本的，操作一个小数量量子位的量子线路 ，使用酉矩阵表示。</li><li>Coherence Time：相干时间，一个物理量子位保持一个数据所能持续的时间</li><li>Operational errorrate：操作错误率定义为在执行操作时引入错误的概率</li><li>ANS,aggregate node strength，$A N S=\sum_{i}^{k} d_{i}$ where $d_{i}=\sum_{j}^{N} w_{i j}$</li><li>activity，(total number of CNOT operations)</li><li>benchmark：标准检查程序</li><li>STPT，Successful Trials per Unit Time，单位时间成功尝试次数</li></ul><h2>摘要</h2><p>现有量子计算机的不足：容错性不好。造成容错性不好的原因是：</p><ol><li>量子位数太少</li><li>系统噪声大，工作不稳定</li></ol><p>NISQ应运而生（量子位相对较多），本paper研究量子位分配和量子位移动。</p><p>不同的量子位和不同的量子位间的连接（link）拥有不同的错误率，这可能会影响量子位元移动和量子位元分配的**&lt;u&gt;决策&lt;/u&gt;**。因此作者分析了IBM-Q20的公开可用的特性数据，确实发现了上述差异，确定了&lt;u&gt;<strong>设备</strong>&lt;/u&gt;的变异性对整个系统的可靠性有重要的影响。</p><p>为了利用**&lt;u&gt;错误率&lt;/u&gt;**的可变性，作者提出了</p><ol><li>可变感知量子位移动(VQM)</li><li>可变感知量子位分配(VQA)</li></ol><p>这些策略可避免较弱的量子位和链接，鼓励更多的操作向较强的量子位和链接发展。</p><p>基于IBM-Q20仿真模型，变量感知策略可以将系统可靠性提高1.7倍。基于IBM-Q5，可靠性可高达1.9倍。</p><h2>介绍</h2><h3>量子计算机：</h3><p>能够加速求解普通困难问题的求解，如：</p><ul><li>素因子分解</li><li>模拟物质和化学反应</li></ul><p>通过创建纠缠集合状态实现运算，创建纠缠集合所用到的操作是：“两量子位操作”，这个操作只能对有**&lt;u&gt;联系&lt;/u&gt;**的量子位元进行。</p><h3>量子算法</h3><ul><li>利用叠加和纠缠的性质，依靠量子运算来改变量子位元的状态。</li></ul><h3>历史</h3><ul><li>过去20年：从理论模型到被实践</li><li>过去2年：各公司设计出了量子计算机蓝图</li><li>过去10年：一致性时间（coherence times）从1纳秒上升到了100微秒</li></ul><h3>量子位</h3><ul><li>具有易变的特性，因为：退相干和操作错误</li><li>具有避免错误的方法，即：QEC，但QEC有不足：需要10-100个物理量子位元来编码一个容错量子位元。当前有数十或数百量子位的计算机因量子位限制，不能使用QEC。</li></ul><h3>VOM and VOA</h3><h4>VOM</h4><ul><li>以前的做法是让SWAP次数更少的路径</li><li>选择成功率最高的纠缠路径</li></ul><h4>VOA</h4><ul><li>以前的做法是选择让SWAP次数更少的的放置位置，这些研究假设了swap代价均等</li><li>将数据量子位放置在成功率更高的的物理量子位上</li></ul><p>需要考虑量子位设备的多样性，认为SWAP操作代价不等</p><h3>文章工作</h3><ul><li>给出了所有20个量子位的相干时间统计量，执行单量子位运算时的误码率，以及在不同量子位上执行双量子位运算的误码率。</li><li>证明确实不同的量子位和连接是存在差异的。</li><li>提出Variation-Aware Qubit Movement：如果想对两个数据量子位进行纠缠，VQM方法会找出是成功率最高的path，而不是SWAP最小的path</li><li>提出Variation-Aware Qubit Allocation：在将数据量子位映射到物理量子位上时，选择最强的链接，提升系统整体的可靠性。</li></ul><h2>背景和动机</h2><h3>量子计算背景</h3><ul><li>传统计算机的一个位可看做球体上的南北两极，而一个量子位代表的数据可看做在一个球面**&lt;u&gt;（布洛赫球面）&lt;/u&gt;**上的任意一点</li><li>量子操作：将一个量子位从球面上的一点移动到另一点</li><li>存储和操作量子位是量子算法的关键</li><li>量子纠缠是创建有联系的量子位之间的集合状态的操作</li><li>量子纠缠通过“二量子位操作”完成，例如控制非门</li><li>IBM量子机中，两量子位比特操作通过他们之间的连接环（coupling-link）完成。</li><li>超导量子计算机通常不会采用全互联量子位，而是采用一种受限制的网络，如mesh，只在相邻的量子位之间连接。</li><li>SWAP操作可以交换邻接的量子位位，能使任意两个量子进行纠缠，SWAP可以通过三个控制非门完成</li></ul><h3>量子计算机中的错误</h3><ul><li>很有可能因为量子设备的环境发生变化而产生错误</li><li>分类：连贯性错误和操作错误</li><li>连贯性错误：量子位只能在有限时间内保持数据，高能状态$(|1\rangle)$总会向低能状态$(|0\rangle)$衰变。与这种衰变相关的时间常量被称为T1相干时间（T1 Coherence Time）。T1表示一个量子位自然放松的时间。T2表示被环境影响的量子位放松时间。</li><li>操作错误：量子操作不精确，不完美，可能导致错误。<strong>操作错误率</strong>定义为在执行操作时引入错误的概率。单量子操作错误率量级：$10^{-3}$，双量子操作错误率量级：$10^{-2}$。本文主要研究双量子操作错误。</li></ul><h3>近期的量子计算机</h3><ul><li>QEC可实现错误免疫，但一个容错量子位需要10x-100x物理量子位来编码。现阶段量子位少的量子计算机（NISQ）无法实现QEC。</li><li>大程序需要几百万量子位，已存在或近期的量子计算机无法达到。对只需要几十位的量子程序，错误更正无法达到。</li><li>NISQ没办法执行错误更正，但能执行有用的工作。</li><li>可通过多次执行，根据大数定律可知，一个事件出现的次数与实验总次数比值随着实验次数的增加，趋近于事件的概率。</li></ul><h3>量子位元之间有限的连通性</h3><ul><li>若实现量子位全连通，连接需$O(N^2)$，不可行。</li><li>连接包括导线、以特定频率工作的谐振器，使连接做到可靠，是一项艰难的任务。因此大多量子计算机使用网格网络。</li><li>由于使用网格网络，所以产生了两个子问题：Qubit-Allocation：处理程序量子位到物理量子位的映射问题。Qubit-Movement：选择将一个量子位状态移动到另一个量子位状态的路径的问题。</li><li>Qubit-Movement 策略：此策略决定在将数据从芯片上的一个位置移动到另一个位置时应该使用的路由。</li><li>Qubit-Allocation 策略：该策略决定程序量子位元到数据量子位元的初始映射。经常通信的量子位元最好放在彼此附近。</li><li>本文工作采用Zulehner开发的编译器，对于给定链接的量子程序进行编译，生成指令队列、SWAPs和初始量子位映射。他开发的编译器采用贪婪算法减少SWAP次数，在执行交换操作时，用于qubit移动和qubit分配的基线策略假定统一的成本(特别是可靠性影响)。但是不正确，会有易变性。</li></ul><h2>分析 IBM-Q20 中的可变性</h2><h3>相干时间分布</h3><ul><li>标准差是离均差平方的算术平均数的平方根。平均偏差是数列中各项数值和其对应的算术平均数的离差绝对值的算术平均数。</li></ul><h3>单量子位位操作错误率</h3><ul><li>IMB量子计算机中的量子位操作是通过在量子位元装置上应用具有一定持续时间和频率的微波信号来实现的。但量子位器件是高度非线性的，微小的扰动或实验条件都会引起器件特性的漂移。</li><li>单位操作比双位操作更加稳定。</li></ul><h3>双量子位位操作错误率</h3><ul><li>IBM量子计算机中双量子位操作通过在目标设备、控制量子位设备以及连接两者的耦合链路上应用微波脉冲来执行的。与单量子位操作类似，双量子位操作的错误率也会发生变化。有一小部分耦合链路比大多数链路明显不可靠</li></ul><h3>双量子位位门误差的时间变化</h3><ul><li>链接的错误率可能随时间变化</li><li>强连接保持平均错误率的能力较强，弱连接保持平均错误率的能力较弱</li></ul><h3>双量子位位门误差的空间变化</h3><ul><li>不同节点和连接之间的误差率不一样</li></ul><h2>评估方法</h2><h3>系统级别可靠性的品质因数</h3><ul><li>以PST作为主要指标</li></ul><h3>评估基准</h3><ul><li>微基准是按照比例缩小的大的量子应用和子程序</li><li>选取准则：选取了纠缠模式不同的数据集</li></ul><h3>评估所用的工具</h3><ul><li>采用基于蒙特卡洛方法的错误注入模拟器</li><li>采用NISQ的迭代执行，分析结果模型</li><li>错误注入模拟器接收：1.NISQ程序 2.框架、配置和错误率 3. 管理策略</li><li>评估了以下方面的失败可能性：两量子位位、单量子位位、测量操作</li><li>对每个数据集执行100万次</li><li>错误建模为具有独立概率的不相关事件</li><li>映射和编译策略可以被一阶模拟器评估</li></ul><h3>架构和错误率参数</h3><ul><li>架构参数规定了量子位的数量和连通性</li><li>错误率参数规定了单比特、双比特和测量操作的错误率</li><li>文章对coherence错误进行了建模</li><li>IBM-Q20的门错误比coherence错误更加严重</li></ul><h3>量子位移动和分配的基准策略</h3><h4>Zulehner提出的基本映射策略</h4><ol><li><p>构建无权图，节点为量子位，边为量子位与量子位之间的连通</p></li><li><p>采用Floyd算法，计算任意两点之间的最短路径</p></li><li><p>对输入程序**&lt;u&gt;分层&lt;/u&gt;**，使得每一层都包含能够被并行执行的独立操作。分层为：$$L=\left{l_{0}, \ldots, l_{i}, l_{i+1}, \ldots, l_{n-1}\right}$$</p></li><li><p>对于每一个分层$l_{i}$，都要找到一个对应的映射$m_{i}$，使得这一层的控制非门都能有足够的物理连通性被执行</p></li><li><p>为每对相邻层$l_{i}$ 和 $l_{i+1}$找到最优swap操作集合$\left(S_{i \rightarrow i+1}\right)$，**这个操作集合能够将映射$m_{i}$转化到$m_{i+1}$。*<em>搜索时要采用A</em>算法。</p></li></ol><h2>可变感知的量子位移动</h2><ul><li>由于量子计算机的量子位大多数以网格状分布，因此两点之间沿任意路径的曼哈顿距离相同。</li><li>现有的方法采用插入的交换数作为代价函数。但文章的方法是将量子位从源移动到目标的总体失败率。但在失败率相同的时候，选择最小的交换数。</li><li>VQM利用了基线的局部性保留特性，同时使用了一种可变感知的启发式。</li></ul><h4>VQM算法流程</h4><ol><li>初始化权图，边的权值是失败概率，使用N次Dijkstra算法，获取任意两点之间的纠缠最小失败概率。</li><li>计算每个量子位的节点强度$d_{i}$，$d_{i}=\sum_{j}^{N} w_{i j}$</li><li>将输入程序分层，使得每一层都包含能够被并行执行的独立操作。分层为：</li></ol><p>$$L=\left{l_{0}, \ldots, l_{i}, l_{i+1}, \ldots, l_{n-1}\right}$$</p><ol><li>找映射，量子位节点强度更高的量子位会被优先选中。</li><li>选择能够根据最小失败概率矩阵，找到最优交换操作。使用A*算法进行搜索，启发函数使用可靠性消耗和MAH（最大附加跳数）的加和。</li></ol><p>MAH：Maximum Additional Hop，用于限制最大跳数，如果超过最大跳数的做法，即使cost低，也不予考虑。</p><h2>可变感知的量子位分配</h2><ul><li>普通方法只注意分配过程使SWAP数最小，而VQA方法要使出错概率最小。</li><li>基线策略从精心选择的初始映射开始，然后尝试收敛到具有最小SWAP数量的配置。</li><li>VQA方法将最频繁使用的量子位分配到最稳定的物理量子位上，并保持局部性。VQA方法通过采用最可靠的初始映射，限制最常用的量子位到最可靠的连接上来实现。VQA方法通过分析程序中的前N条指令、跟踪控制非门操作涉及的对象，来估计最常被纠缠的量子位。</li></ul><h4>VQA算法流程</h4><ol><li>找到具有k个节点的具有最高ANS的子图，ANS等于k个节点的临边权值和的和</li><li>通过计算前t层的每一个量子位的控制非门数，找出***&lt;u&gt;量子位活动&lt;/u&gt;***</li><li>优先映射量子位活动多的量子位到子图上</li><li>用基线算法找到层$l_{i}$ 和 $l_{i+1}$的SWAP数</li></ol><p>VQA使用<strong>K-core算法</strong>来计算最强的子图集，该算法递归删除度数小于k的节点。</p><h3>VQA对系统可靠性的影响</h3><ul><li>VQA具有高活动性(CNOT操作总数)的程序量子位元到具有较高节点强度的物理量子位的映射。这提高了在少数几个qubit对之间重复纠缠操作的工作负载的可靠性。</li></ul><h3>和IBM编译器的比较</h3><ul><li>baseline比原始IBM编译器提升了4倍，VQA和VQM可提升7倍</li></ul><h3>每天不同数据的比较</h3><ul><li>错误率变化程度大的数据，PST相对较高，反之则较低</li></ul><h3>对错误率大小变化的敏感性</h3><ul><li>错误率无论大小，总会有变化，总是适用。</li><li>VQM+VQA提供了显著的好处，这些好处随着相对变化的增加而增加。</li><li>改变了两个变量：一个是平均错误率，一个是Covariation（相关变异）</li></ul><h2>在IBM-Q5上的测试</h2><p>two-qubit error rate is 4.2%, the worst link-error is 12%.  We run each experiment with 4096 trials and analyze the output log to compute the PST for each  program and policy.</p><h2>分区的量子计算机</h2><ul><li>在实际所需的量子位比物理量子位少一半甚至更少的时候，探究分区是否有意义。</li><li>产生了2 copy mode</li><li>同时运行的两个副本每次可以提供两倍的无错误试验次数。但是这限制了物理量子位的映射的选择。因为单次实验可以选择连接较强，错误率较低的物理量子位进行映射，而两个副本导致了不得不选用连接较弱、错误率较高的物理量子位进行映射。</li></ul><h2>局限性分析</h2><ul><li>benchmarks可能不典型</li><li>错误模型可能假设有问题</li></ul><h2>总结</h2><ul><li>强调了量子位和量子位之间的连接的错误率中的可变性</li><li>提出了VQM，能使量子位的移动有最低失败概率</li><li>提出了VQA，能将程序量子位映射到更健壮的物理量子位上</li><li>提出了一套评价方法论来评估设备变化和管理策略对量子计算机系统级可靠性的影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法读书笔记</title>
      <link href="/2019/07/07/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/07/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>资料</h1><p><a href="https://www.cnblogs.com/limitlessun/p/8611103.html" target="_blank" rel="noopener">统计学习方法读书笔记</a></p><p><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">代码实现</a></p><p><a href="https://github.com/SmirkCao/Lihang" target="_blank" rel="noopener">笔记</a></p><h1>CH1：统计学习方法概论</h1><h2>实现统计学习方法的步骤</h2><p>统计学习方法三要素：模型，策略，算法</p><blockquote><ol><li>得到一个有限的训练数据集合；</li><li>确定包含所有可能的模型的<strong>假设空间</strong>，即学习模型的集合；</li><li>确定模型选择的准则，即学习的<strong>策略</strong>；</li><li>实现求解最优模型的算法，即学习的<strong>算法</strong>；</li><li>通过学习方法选择最优的模型；</li><li>利用学习的最优模型对新数据进行预测或分析。</li></ol></blockquote><h2>统计学习分类</h2><h3>基本分类</h3><ul><li>监督学习：采用的数据集包含标签，如KNN</li><li>无监督学习：采用的数据集不包含标签，如k-means</li><li>半监督学习：监督学习与与无监督学习的结合</li><li>强化学习：通过接收环境对动作的奖励（反馈）获得学习信息并更新模型参数</li></ul><h3>按模型分类</h3><ul><li>概率模型：为生成模型</li><li>非概率模型：为判别模型</li></ul><h3>按算法分类</h3><ul><li>在线学习</li><li>批量学习</li></ul><h2>统计学习方法三要素</h2><h3>模型</h3><p>在监督学习过程中，模型就是所要学习的<strong>条件概率分布</strong>或者<strong>决策函数</strong>。</p><table><thead><tr><th></th><th>假设空间$\cal F$</th><th>输入空间$\cal X$</th><th>输出空间$\cal Y$</th><th>参数空间</th></tr></thead><tbody><tr><td>决策函数</td><td>$\cal F\it ={f_{\theta}</td><td>Y=f_{\theta}(x), \theta \in \bf R \it ^n}$</td><td>变量</td><td>变量</td></tr><tr><td>条件概率分布</td><td>$\cal F\it ={P</td><td>P_{\theta}(Y</td><td>X),\theta\in \bf R \it ^n}$</td><td>随机变量</td></tr></tbody></table><h3>策略</h3><p>学习过程或选择最优的模型的过程所参照的准则。</p><h4>损失函数与风险函数</h4><blockquote><p><strong>损失函数</strong>度量模型<strong>一次预测</strong>的好坏，<strong>风险函数</strong>度量<strong>平均意义</strong>下模型预测的好坏。</p></blockquote><ol><li><p>损失函数(loss function)或代价函数(cost function)损失函数定义为给定输入$X$的<strong>预测值$f(X)$<strong>和</strong>真实值$Y$<strong>之间的</strong>非负实值</strong>函数，记作$L(Y,f(X))$</p></li><li><p>风险函数(risk function)或期望损失(expected loss)这个和模型的泛化误差的形式是一样的</p></li></ol><p>$$R_{exp}(f)=E_p[L(Y, f(X))]=\int_{\mathcal X\times\mathcal Y}L(y,f(x))P(x,y), {\rm d}x{\rm d}y模型$f(X)$关于联合分布$P(X,Y)$的<strong>平均意义下的</strong>损失(<strong>期望</strong>损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是<strong>期望</strong>，以及<strong>平均意义下的</strong>。$$</p><p>模型$f(X)$关于联合分布$P(X,Y)$的<strong>平均意义下的</strong>损失(<strong>期望</strong>损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是<strong>期望</strong>，以及<strong>平均意义下的</strong>。</p><p>这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏，$P(x,y)$转换成$\frac {\nu(X=x, Y=y)}{N}$更容易直观理解。</p><ol start="3"><li><p><strong>经验风险</strong>(empirical risk)或<strong>经验损失</strong>(empirical loss)$R_{emp}(f)=\frac{1}{N}\sum^{N}_{i=1}L(y_i,f(x_i))$模型$f$关于<strong>训练样本集</strong>的平均损失根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险</p></li><li><p><strong>结构风险</strong>(structural risk)$R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$J(f)$为模型复杂度, $\lambda \geqslant 0$是系数，用以权衡经验风险和模型复杂度。</p></li></ol><h4>常用损失函数</h4><p>损失函数数值越小，模型就越好</p><ol><li><p>0-1损失$$L(Y,f(X))=\begin{cases}1, Y \neq f(X) \0, Y=f(X) \end{cases}$$</p></li><li><p>平方损失$$L(Y,f(X))=(Y-f(X))^2$$</p></li><li><p>绝对损失</p></li></ol><p>$$L(Y,f(X))=|Y-f(X)|$$</p><ol start="4"><li>对数损失这里$P(Y|X)\leqslant 1$，对应的对数是负值，所以对数损失中包含一个负号。</li></ol><p>$$L(Y,P(Y|X))=-\log P(Y|X)$$</p><h4>ERM与SRM</h4><p>经验风险最小化(Empirical Risk Minimization,ERM)与结构风险最小化(Structural Risk Minimization,SRM)</p><ol><li><strong>极大似然估计</strong>是经验风险最小化的一个例子当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计</li><li><strong>贝叶斯估计</strong>中的<strong>最大后验概率估计</strong>是结构风险最小化的一个例子当模型是条件概率分布，损失函数是对数损失函数，<strong>模型复杂度由模型的先验概率表示</strong>时，结构风险最小化等价于最大后验概率估计</li></ol><h3>算法</h3><p>这章里面简单提了一下，具体可以参考<a href="../CH12/README.md">CH12</a>表格中关于学习算法的描述。</p><h2></h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在hexo博客中使用数学公式</title>
      <link href="/2019/07/01/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/07/01/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<hr><h1>解决方法一</h1><h2>第一步： 安装Kramed</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn remove hexo-renderer-marked</span><br><span class="line">yarn add hexo-renderer-kramed</span><br></pre></td></tr></table></figure></p><h2>第二步：更改文件配置</h2><p>打开<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>第三步: 停止使用 hexo-math，并安装mathjax包</h2><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn remove hexo-math</span><br><span class="line">yarn add hexo-renderer-mathjax</span><br></pre></td></tr></table></figure></p><h2>第四步: 更新 Mathjax 的 配置文件</h2><p>打开<code>/node_modules/hexo-renderer-mathjax/mathjax.html</code></p><p>将<code>&lt;script&gt;</code>替换为：</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2>第五步: 更改默认转义规则</h2><p>打开<code>/node_modules\kramed\lib\rules\inline.js</code></p><ol><li></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure></p><p>改为</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()# +\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure></p><ol start="2"><li></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></p><p>改为</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></p><h2>第六步: 开启mathjax</h2><p>在<code>config.yml</code>文件 中开启 Mathjax</p><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h1>解决方法二</h1><p>将这段代码放到 HTML 的 header 里，解决方案来自<a href="https://liam.page/2015/09/09/fix-conflict-between-mathjax-and-markdown/" target="_blank" rel="noopener">liam</a></p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"code"</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    match = <span class="regexp">/^\$(.*)\$$/</span>.exec($(<span class="keyword">this</span>).html());</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      $(<span class="keyword">this</span>).replaceWith(<span class="string">"&lt;span class=hpl_mathjax_inline&gt;"</span> + $(<span class="keyword">this</span>).html() + <span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">      MathJax.Hub.Queue([<span class="string">"Typeset"</span>,MathJax.Hub,$(<span class="keyword">this</span>).get(<span class="number">0</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    match = <span class="regexp">/^\$\$(.*)\$\$$/</span>.exec($(<span class="keyword">this</span>).html());</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      $(<span class="keyword">this</span>).replaceWith(<span class="string">"&lt;span class=hpl_mathjax_inline&gt;"</span> + $(<span class="keyword">this</span>).html() + <span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">      MathJax.Hub.Queue([<span class="string">"Typeset"</span>,MathJax.Hub,$(<span class="keyword">this</span>).get(<span class="number">0</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    match = <span class="regexp">/^\\begin/</span>.exec($(<span class="keyword">this</span>).html());</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      $(<span class="keyword">this</span>).replaceWith(<span class="string">"&lt;span class=hpl_mathjax_inline&gt;"</span> + $(<span class="keyword">this</span>).html() + <span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">      MathJax.Hub.Queue([<span class="string">"Typeset"</span>,MathJax.Hub,$(<span class="keyword">this</span>).get(<span class="number">0</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>https://www.jianshu.com/p/7ab21c7f0674</p><p>https://www.jianshu.com/p/0c97df3a8491</p><p>https://blog.csdn.net/u014630987/article/details/78670258</p><p>https://liam.page/2015/09/09/fix-conflict-between-mathjax-and-markdown/</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> latex </tag>
            
            <tag> mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SfM和SLAM项目总结</title>
      <link href="/2019/06/28/SfM%E5%92%8CSLAM%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/28/SfM%E5%92%8CSLAM%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：2019年6月27日，我进行了网易伏羲实验室虚拟人方向的电话面试。在电话中，我支支吾吾连自己的项目都讲不清楚。不管最后面试结果如何，自己做过的东西起码自己要懂。</p></blockquote><h1>基础知识</h1><h2>内积</h2><p>$$\bf{a} \cdot \bf{b}=\bf{a}^T\bf{b}=\sum_{i=1}^3a_ib_i=|\bf{a}||\bf{b}|cos&lt;\bf{a,b}&gt;$$</p><h2>外积</h2><p>$$\bf{a} \times \bf{b} =\left[\begin{array}{ccc}{\bf{i}} &amp; {\bf{j}} &amp; {\bf{k}}\{a_1} &amp; {a_2} &amp; {a_3}\{b_1} &amp; {b_2} &amp; {b_3}\end{array}\right]= \left[\begin{array}{c}{a_2b_3-a_3b_2}\{a_3b_1-a_1b_3}\{a_1b_2-a_2b_1}\end{array}\right]=\left[\begin{array}{ccc}{0} &amp; {-a_3} &amp; {a_2}\{a_3} &amp; {0} &amp; {-a_1}\{-a_2} &amp; {a_1} &amp; {0}\end{array}\right]\bf{b}\triangleq \bf{a} ^\wedge \bf{b}$$</p><p>相应的，有$$\boldsymbol{a}=[a_1\boldsymbol{i},a_2\boldsymbol{j},a_3\boldsymbol{k}]$$</p><p>$$\boldsymbol{a}^{\wedge}=\boldsymbol{A}=\left[\begin{matrix}0&amp;-a_3&amp;a_2\a_3&amp;0&amp;-a_1\-a_2&amp;a_1&amp;0\\end{matrix}\right]$$</p><p>$$\boldsymbol{A}^{\vee}=\boldsymbol{a}$$</p><h2>特殊正交群 $SO(3)$</h2><p>$$SO(3)={R\in\mathbb{R}^{3\times3}|RR^T=I,\det(R)=1}$$</p><p>（det为行列式）</p><h2>特殊欧式群$SE(3)$</h2><p>$$SE(3)={T=\left[\begin{matrix}R&amp;t\0^T&amp;1\\end{matrix}\right]\in\mathbb{R}^{4\times4}|R\in SO(3),t\in \mathbb{R}^3}$$</p><h2>李代数$\mathfrak{so}(3)$</h2><p>在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{'}R(t)^T$是一个反对称矩阵，那么就用一个$\phi(t)\in\mathbb{R}^3$与之对应。有：</p><p>$$R(t)^{'}R(t)^T=\phi(t)^{\wedge}$$</p><p>之后求解微分方程，可以得到：</p><p>$$R(t)=exp(\phi^{\wedge}t)$$</p><p>实际求解时利用到指数映射和对数映射。</p><h2>双目系统</h2><p><img src="/2019/06/28/SfM和SLAM项目总结/01.jpg" alt="01"></p><p><img src="/2019/06/28/SfM和SLAM项目总结/02.jpg" alt="02"></p><p>左右相机只有在 x 轴上有位移，因此 P 的像也只在 x 轴（对应图像的 u 轴）上有差异。</p><p>$$\frac{z-f}{z}=\frac{b-(u_{L}+u_{R})}{b}$$</p><p>整理得:</p><p>$$z=\frac{f b}{d}, \quad d=u_{L}-u_{R}$$</p><h2>对极几何</h2><p><img src="/2019/06/28/SfM和SLAM项目总结/03.jpg" alt="03"></p><p>两帧图像$I_{1},I_{2}$，两个相机中心分别为 $O_{1},O_{2}$。$p_{1},p_{2}$为互相匹配的特征点。</p><p><strong>极平面</strong>：连线$\overrightarrow{O_{1} p_{1}}$和连线$\overrightarrow{O_{2} p_{2}}$在三维空间中会相交于点 P。这时候点$O_{1}, O_{2}, P$三个点可以确定一个平面，该平面称极平面。</p><p><strong>极点</strong>：$O_{1} O_{2}$连线与像平面$I_{1},I_{2}$的交点被称为极点。</p><p><strong>基线</strong>：$O_{1},O_{2}$的连线。</p><p><strong>极线</strong>：极平面与两个像平面$I_{1},I_{2}$之间的相交线$l_{1},l_{2}$。</p><p><strong>用途</strong>：双目匹配中，给定左图一个点，能将右图中对应的点的搜索空间缩减到一条线。</p><p><strong>条件</strong>：需要八个或八个以上的点对</p><p><strong>推导</strong>：设在第一帧的坐标系下，P坐标为：$\boldsymbol{P}=[X, Y, Z]^{T}​$，两像素点 $p_{1},p_{2}​$ **（齐次化坐标）**的像素位置为：</p><p>$$s_{1} \boldsymbol{p}<em>{1}=\boldsymbol{K} \boldsymbol{P}, \quad s</em>{2} \boldsymbol{p}_{2}=\boldsymbol{K}(\boldsymbol{R} \boldsymbol{P}+\boldsymbol{t})$$</p><p>因为是齐次坐标，所以认为等式任意一边乘以非零常数，等式仍然成立。即：</p><p>$$\boldsymbol{p}<em>{1}=\boldsymbol{K} \boldsymbol{P}, \quad \boldsymbol{p}</em>{2}=\boldsymbol{K}(\boldsymbol{R} \boldsymbol{P}+\boldsymbol{t})$$</p><p>取$\boldsymbol{x}<em>{1}, \boldsymbol{x}</em>{2}$是两个像素点的<strong>归一化平面上的坐标</strong>：</p><p>$$\boldsymbol{x}<em>{1}=\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}, \quad \boldsymbol{x}<em>{2}=\boldsymbol{K}^{-1} \boldsymbol{p}</em>{2}$$</p><p>有：</p><p>$$\boldsymbol{x}<em>{2}=\boldsymbol{R} \boldsymbol{x}</em>{1}+\boldsymbol{t}$$</p><p>同时左乘$t^{\wedge}$，相当于同时与$t$做外积。</p><p>$$\boldsymbol{t}^{\wedge} \boldsymbol{x}<em>{2}=\boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}</em>{1}$$</p><p>同时左乘$\boldsymbol{x}_{2}^{T}$</p><p>$$\boldsymbol{x}<em>{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{x}</em>{2}=\boldsymbol{x}<em>{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}</em>{1}$$</p><p>因$t^{\wedge} x_{2}$垂直于$\boldsymbol{x}_{2}^{T}$或$t$，因此左侧为0。<strong><em>极线约束</em></strong>即：</p><p>$$\boldsymbol{x}<em>{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}</em>{1}=0$$</p><p>将$\boldsymbol{x}<em>{1}=\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}, \quad \boldsymbol{x}<em>{2}=\boldsymbol{K}^{-1} \boldsymbol{p}</em>{2}$代回，可得<strong><em>极线约束</em></strong>的另一种形式：</p><p>$$\boldsymbol{p}<em>{2}^{T} \boldsymbol{K}^{-T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}=0$$</p><p><strong>意义</strong>：</p><p>$O_{1}, P, O_{2}$三点共面，$\boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}<em>{1}$表示极线，且极线一定通过$\boldsymbol{x}</em>{2}$。</p><h2>本质矩阵</h2><p>本质矩阵为：</p><p>$$\boldsymbol{E}=\boldsymbol{t}^{\wedge} \boldsymbol{R}$$</p><p><strong>特点</strong>：</p><ol><li>秩为2</li><li>仅依赖于外参</li><li>采用摄像机坐标系</li></ol><h2>基本矩阵</h2><p>基本矩阵为：</p><p>$$\boldsymbol{F}=\boldsymbol{K}^{-T} \boldsymbol{E} \boldsymbol{K}^{-1}$$</p><p><strong>特点</strong>：</p><ol><li>秩为2</li><li>仅依赖于外参和内参</li><li>采用像素坐标系</li><li>F是从左图到右图，有方向，从右图到左图就是F的转置</li><li>7个自由度。（$3\times3$矩阵本有9个自由度，因行列式值为零，相差常数因子，即$kF,k\neq 0$,也是基本矩阵，减去两个自由度。）</li></ol><h2>单应矩阵</h2><p>单应矩阵是齐次矩阵，有8个未知数，需要四个对应点。</p><h1>张正友标定法</h1><p><a href="https://www.researchgate.net/publication/3193178_A_Flexible_New_Technique_for_Camera_Calibration" target="_blank" rel="noopener">A Flexible New Technique for Camera Calibration</a></p><p>摘要：张正友标定法只需要相机观察几个（至少两个）不同方向上显示的平面图案。相机或平面图案都可以自由移动。且相机或标定板的运动不需要知道。张正友标定法对径向透镜畸变进行了建模。该方法由一个封闭形式的解组成，然后根据最大似然准则进行非线性改进。</p><h2>数学推导</h2><h3>针孔相机模型三维点到二维点投影矩阵</h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>$m=[u,v]^T$</td><td>二维点</td></tr><tr><td>$M=[X,Y,Z]^T$</td><td>三维点</td></tr><tr><td>$\widetilde{m}=[u,v,1]^T$</td><td>二维点齐次坐标</td></tr><tr><td>$\widetilde{M}=[X,Y,Z,1]^T$</td><td>三维点齐次坐标</td></tr><tr><td>s</td><td>随机尺度因子</td></tr><tr><td>$\bf{(R,t)}$</td><td>外参，即将世界坐标系和相机坐标系联系起来的旋转矩阵和位移向量</td></tr><tr><td>$\bf{A}$</td><td>相机内参矩阵</td></tr><tr><td>$\alpha,\beta$</td><td>分别为图像u轴和v轴的尺度因子</td></tr><tr><td>$u_0,v_0$</td><td>光心的图像坐标系坐标</td></tr><tr><td>$\gamma$</td><td>描述图像轴u,v之间的倾斜</td></tr></tbody></table><p>$$s \widetilde{\bf{m}} = \bf{A[R\quad t]\widetilde{M}}$$</p><p>其中，</p><p>$$A = \left[ \begin{array}{ccc} {\alpha} &amp; {\gamma} &amp; {u_0}\ {0} &amp; {\beta} &amp; {v_0}\ {0} &amp; {0} &amp; {1}\end{array}\right]$$</p><h3>标定板平面与图像之间的单应性矩阵</h3><p>这里假设标定板所在的平面为空间坐标系下的$Z=0$。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>$\bf{r_i}$</td><td>旋转矩阵$\bf{R}$的第i列</td></tr></tbody></table><p>$$s\left[\begin{array}{c}{u}\{v}\{1}\end{array}\right]=\bf{A}[\begin{array}{cccc}{\bf{r_1}}&amp;{\bf{r_2}}&amp;{\bf{r_3}}&amp;{\bf{t}}\end{array}]\left[\begin{array}{c}{X}\{Y}\{0}\{1}\end{array}\right]=A[\begin{array}{ccc}{\bf{r_1}}&amp;{\bf{r_2}}&amp;{\bf{t}}\end{array}]\left[\begin{array}{c}{X}\{Y}\{1}\end{array}\right]$$</p><p>即：</p><p>$$s\widetilde{\bf{m}}=\bf{H\widetilde{M}}$$</p><p>其中，$\bf{H}$为单应矩阵，$\bf{H=A[\begin{array}{ccc}{\bf{r_1}}&amp;{\bf{r_2}}&amp;{\bf{t}}\end{array}]}$。</p><h3>内参约束</h3><p>假设$\bf{H}=\left[\begin{array}{ccc}{\bf{h_1}}&amp;{\bf{h_2}}&amp;{\bf{h_3}}\end{array}\right]$，根据单应关系有：</p><p>$$\left[\begin{array}{ccc}{\bf{h_1}}&amp;{\bf{h_2}}&amp;{\bf{h_3}}\end{array}\right]=\lambda \bf{A}[\begin{array}{ccc}{\bf{r_1}}&amp;{\bf{r_2}}&amp;{\bf{t}}\end{array}]$$</p><p>可推出$$\mathbf{r}<em>{1}=\lambda \mathbf{A}^{-1} \mathbf{h}</em>{1}$$</p><p>$$\mathbf{r}<em>{2}=\lambda \mathbf{A}^{-1} \mathbf{h}</em>{2}$$</p><p>$$\mathbf{r}<em>{3}=\mathbf{r}</em>{1} \times \mathbf{r}_{2}$$</p><p>$$\mathbf{t}=\lambda \mathbf{A}^{-1} \mathbf{h}_{3}$$</p><p>$$\lambda=\frac{1}{\left|\mathbf{A}^{-1} \mathbf{h}<em>{1}\right|}=\frac{1}{\left|\mathbf{A}^{-1} \mathbf{h}</em>{2}\right|}$$</p><p>根据$\bf{r_1}$和$\bf{r_2}$正交，根据</p><ol><li>正交</li><li>模相等</li></ol><p>有：$$h_1^TA^{-T}A^{-1}h_2=0$$</p><p>$$h_1^TA^{-T}A^{-1}h_1= h_2^TA^{-T}A^{-1}h_2$$</p><h3>几何解释</h3><p>需要大于等于三张图像才能确定唯一解。</p><h1>SfM</h1><h2>三角化</h2><p>设 $x_1 ,x_2$ 为两个特征点的归一化坐标，那么它们满足：$$s_{1} \boldsymbol{x}<em>{1}=s</em>{2} \boldsymbol{R} \boldsymbol{x}<em>{2}+\boldsymbol{t}$$现在我们已经知道了$\boldsymbol{R}, \boldsymbol{t}$，想要求解的是两个特征点的深度 $s</em>{1}, s_{2}$。</p><p>可以左侧使用$x_1$进行叉乘，使左侧为0，即可求得$s_2$：$$s_{1} \boldsymbol{x}<em>{1}^{\wedge} \boldsymbol{x}</em>{1}=0=s_{2} \boldsymbol{x}<em>{1}^{\wedge} \boldsymbol{R} \boldsymbol{x}</em>{2}+\boldsymbol{x}_{1}^{\wedge} \boldsymbol{t}$$求$s_1$时同理。</p><h2>PnP</h2><p>求解 3D 到 2D 点对运动的问题。特征点的 3D 位置可以由三角化，或者由 RGB-D 相机的深度图确定。在单目视觉里程计中，必须先进行初始化，然后才能使用 PnP。</p><h1>SLAM</h1><h2>ORB_SLAM流程</h2><ol><li><p>System类生成一个对象slam，初始化slam对象，设置三个线程：Tracking ，LocalMapping ，LoopClosing</p></li><li><p>订阅 GrabImage() ——&gt; TrackMonocular()——&gt;GrabImageMonocular()——&gt;Track()</p></li></ol><h3>三个线程作用</h3><h4>Tracking：</h4><ol><li>Extract ORB，提取关键点和描述子</li><li>Initialize pose：在Track() 中初始化位姿 pose ， 第一帧 ：mInitialFrame  当前帧：mCurrentFrame ，从这两帧得到 （R，t）。并且，这两帧转为KeyFrame，凡是关键帧KeyFrame都要插入地图 mpMap（mpMap-&gt;AddMapPoint(pMP);），根据关键帧与当前帧公共3D点的个数 更新关键帧间的连接关系。</li></ol><p><strong>MapPoint类表示 路标点，Map类用Hash表管理 路标点和关键帧。</strong></p><ol start="3"><li><p>track local map：</p><ol><li><p>更新局部地图，包括局部关键帧和关键点</p></li><li><p>对局部MapPoints进行投影匹配</p></li><li><p>根据匹配对估计当前帧的姿态</p></li><li><p>根据姿态剔除误匹配</p></li></ol></li><li><p>keyFrame decision</p></li></ol><h4>Local Mapping:</h4><p><strong>LocalMapping线程处理的关键帧都是Tracking线程发过来的</strong></p><ol><li>插入关键帧，</li><li>去除<strong>冗余的MapPoints；</strong></li><li>Local BA；</li><li>去除<strong>冗余的关键帧</strong> : 检测并剔除当前帧相邻的关键帧中<strong>和关键帧</strong>，剔除的标准是：该关键帧的90%的MapPoints可以被其它关键帧观测到。将当前帧加入到闭环检测队列中。</li></ol><h4>Loop Closing</h4><ol><li>回环检测Loop decision：计算闭环候选帧，在候选帧中检测具有连续性的候选帧；</li><li>计算相似变换阵sim3，求 [ sR | t ]；</li><li>Loop Correction：</li></ol><p>A. 通过求解的Sim3以及相对姿态关系，调整与当前帧相连的关键帧位姿以及这些关键帧观测到的MapPoints的位置；B. 将闭环帧以及 与闭环帧相连的关键帧的MapPoints和与当前帧相连的关键帧的点进行匹配；C. 通过MapPoints的匹配关系更新这些帧之间的连接关系，即更新covisibility graphD. 对Essential Graph（Pose Graph）进行优化，MapPoints的位置则根据优化后的位姿做相对应的调整E. 创建线程进行全局Bundle Adjustment</p><p>main-&gt;构造SLAM对象，在构造函数中设置线程。</p><p>读取图像，循环调用trackMonocular，在其中先检查状态是否改变，再调用</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GrabImageMonocular</span><br></pre></td></tr></table></figure></p><p>构造了CurrentFrame，最后进行Track</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> 机器视觉 </tag>
            
            <tag> 单目 </tag>
            
            <tag> SfM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分、线段树与树状数组</title>
      <link href="/2019/06/08/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2019/06/08/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2>树状数组</h2><ul><li>时间复杂度：O（n）</li><li>适用于：单点更新，区间查询</li></ul><h3>理解</h3><blockquote><p>C[1] = C[0001] = A[1];C[2] = C[0010] = A[1]+A[2];C[3] = C[0011] = A[3];C[4] = C[0100] = A[1]+A[2]+A[3]+A[4];C[5] = C[0101] = A[5];C[6] = C[0110] = A[5]+A[6];C[7] = C[0111] = A[7];C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];</p></blockquote><p>即：</p><ul><li>$C[i]=A[i-2^k+1]+A[i-2^k+2]+\dots+A[i];$</li><li>$k$为 $i$ 的二进制中从最低位到高位连续零的长度。</li><li>$2^k$可通过$i&amp;-i$获得。</li></ul><blockquote><p>补码为原码取反后加1，如果将补码+1进位，那么最末尾的1和原码最右边的1一定是同一个位置</p></blockquote><h3>lowbit</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>单点更新</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> index,<span class="keyword">int</span> diff,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * arr：树状数组</span></span><br><span class="line"><span class="comment">    * index：待更新的位置</span></span><br><span class="line"><span class="comment">    * diff：改变的值</span></span><br><span class="line"><span class="comment">    * len：树状数组长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=len;i+=lowbit(i))</span><br><span class="line">        arr[i] += diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>区间查询</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * arr：树状数组</span></span><br><span class="line"><span class="comment">    * x：求从1到x的和</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=lowbit(i))</span><br><span class="line">        ans += arr[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>样例</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t &amp; (-t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &lt;= n)&#123;</span><br><span class="line">        a[t] += d;</span><br><span class="line">        t = t + lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sum += a[t];</span><br><span class="line">        t = t - lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, k, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    k= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">            insert(i, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, k++);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"End"</span>)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"Query"</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getSum(y) - getSum(x - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Add"</span>)</span><br><span class="line">                insert(x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Sub"</span>)</span><br><span class="line">                insert(x, -y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>线段树</h2><h3>模板一、RMQ，查询区间最值下标</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXIND 256 <span class="comment">//线段树节点个数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//构建线段树,目的:得到M数组.  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> M[], <span class="keyword">int</span> A[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (b == e)  </span><br><span class="line">        M[node] = b; <span class="comment">//只有一个元素,只有一个下标  </span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        build(<span class="number">2</span> * node, b, (b + e) / <span class="number">2</span>, M, A);  </span><br><span class="line">        build(<span class="number">2</span> * node + <span class="number">1</span>, (b + e) / <span class="number">2</span> + <span class="number">1</span>, e, M, A);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (A[M[<span class="number">2</span> * node]] &lt;= A[M[<span class="number">2</span> * node + <span class="number">1</span>]])  </span><br><span class="line">        M[node] = M[<span class="number">2</span> * node];  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        M[node] = M[<span class="number">2</span> * node + <span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//找出区间 [i, j] 上的最小值的索引  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> M[], <span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> p1, p2;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//查询区间和要求的区间没有交集  </span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e || j &lt; b)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (b &gt;= i &amp;&amp; e &lt;= j)  </span><br><span class="line">        <span class="keyword">return</span> M[node];  </span><br><span class="line"> </span><br><span class="line">    p1 = query(<span class="number">2</span> * node, b, (b + e) / <span class="number">2</span>, M, A, i, j);  </span><br><span class="line">    p2 = query(<span class="number">2</span> * node + <span class="number">1</span>, (b + e) / <span class="number">2</span> + <span class="number">1</span>, e, M, A, i, j);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//return the position where the overall  </span></span><br><span class="line">    <span class="comment">//minimum is  </span></span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="number">-1</span>)  </span><br><span class="line">        <span class="keyword">return</span> M[node] = p2;  </span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="number">-1</span>)  </span><br><span class="line">        <span class="keyword">return</span> M[node] = p1;  </span><br><span class="line">    <span class="keyword">if</span> (A[p1] &lt;= A[p2])  </span><br><span class="line">        <span class="keyword">return</span> M[node] = p1;  </span><br><span class="line">    <span class="keyword">return</span> M[node] = p2;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> M[MAXIND]; <span class="comment">//下标1起才有意义,否则不是二叉树,保存下标编号节点对应区间最小值的下标.  </span></span><br><span class="line">    <span class="built_in">memset</span>(M,<span class="number">-1</span>,<span class="keyword">sizeof</span>(M));  </span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])<span class="number">-1</span>, M, a);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])<span class="number">-1</span>, M, a, <span class="number">0</span>, <span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>模板二、连续区间修改或者单节点更新的动态查询问题 （此模板查询区间和）</h3><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l , m , rt &lt;&lt; 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1 , r , rt &lt;&lt; 1 | 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1 , N , 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>;  </span><br><span class="line">LL add[maxn&lt;&lt;<span class="number">2</span>];  </span><br><span class="line">LL sum[maxn&lt;&lt;<span class="number">2</span>];  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;  </span><br><span class="line">    sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (add[rt]) &#123;  </span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>] += add[rt];  </span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[rt];  </span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>] += add[rt] * (m - (m &gt;&gt; <span class="number">1</span>));  </span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[rt] * (m &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">        add[rt] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span> </span>&#123;  </span><br><span class="line">    add[rt] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[rt]);  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    build(lson);  </span><br><span class="line">    build(rson);  </span><br><span class="line">    PushUp(rt);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;  </span><br><span class="line">        add[rt] += c;  </span><br><span class="line">        sum[rt] += (LL)c * (r - l + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    PushDown(rt , r - l + <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L , R , c , lson);  </span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L , R , c , rson);  </span><br><span class="line">    PushUp(rt);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;  </span><br><span class="line">        <span class="keyword">return</span> sum[rt];  </span><br><span class="line">    &#125;  </span><br><span class="line">    PushDown(rt , r - l + <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    LL ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) ret += query(L , R , lson);  </span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) ret += query(L , R , rson);  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> N , Q;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;Q);  </span><br><span class="line">    build(root);  </span><br><span class="line">    <span class="keyword">while</span> (Q --) &#123;  </span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];  </span><br><span class="line">        <span class="keyword">int</span> a , b , c;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);  </span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a , b ,root));  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);  </span><br><span class="line">            update(a , b , c , root);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>前缀和</h2><h3>一维前缀和</h3><p>有数组A，数组A对应的前缀和数组为S，有：$$S[k]=\sum_{i=0}^{k}A[i]$$</p><p>由此方便了范围查询：$$\sum_{i=L}^RA[i]=S[R]-S[L-1]$$</p><h3>二维前缀和</h3><p>对于二维数组A，数组A对应的前缀和数组为S，有：$$S[i][j]=\sum_{m=0}^i\sum_{n=0}^jA[i][j]$$计算时二维前缀和时，可以使用递推公式：$$S[i][j]=A[i][j]+S[i-1][j]+S[i][j-1]-S[i-1][j-1]$$当求被点$(x_1,y_1)$和点$(x_2,y_2)$围起来的元素的和时，可以使用：$$\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}A[i][j]=S[x_2][y_2]-S[x_1-1][y2]-S[x_2][y_1-1]+S[x_1-1][y_1-1]$$</p><h2>差分</h2><p>差分可解决范围更新的问题。</p><p>思想：</p><ul><li>延后更新</li><li>更新的起点和终点</li><li>利用前缀和</li></ul><p>样例：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,n,m,p;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> L,R,t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">b[L]+=p;b[R+<span class="number">1</span>]-=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b[L]-=p;b[R+<span class="number">1</span>]+=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">add+=b[i];</span><br><span class="line">a[i]+=a[i<span class="number">-1</span>]+add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[y]-a[x<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法Sunday</title>
      <link href="/2019/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95Sunday/"/>
      <url>/2019/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95Sunday/</url>
      
        <content type="html"><![CDATA[<p>Sunday算法在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。</p><ul><li>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；</li><li>否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。</li></ul><h2>偏移表</h2><p>在预处理中，计算偏移表。$$shift[w] =\begin{cases}m - max{i &lt; m  | P[i] = w}  &amp; \mbox{ if } w \mbox{ is in } P[0..m-1] \m + 1 &amp; \mbox{ otherwise }\end{cases}$$</p><h2>C++实现</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> charnum = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> shift[charnum];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sunday</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; T, <span class="keyword">const</span> <span class="built_in">string</span>&amp; P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span> m = P.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charnum; i++) &#123;</span><br><span class="line">        shift[i] = m + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        shift[P[i]] = m - i; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j; </span><br><span class="line">    <span class="keyword">while</span>(s &lt;= n - m) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(T[s + j] == P[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> s; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        s += shift[T[s + m]];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM之单目视觉里程计</title>
      <link href="/2019/05/12/SLAM%E4%B9%8B%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/"/>
      <url>/2019/05/12/SLAM%E4%B9%8B%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>SLAM之单目视觉里程计</h1><h2>基础知识</h2><h3>旋转矩阵和位移矩阵</h3><p>建议参考计算机图形学教材，学习“图形变换”章节。重点掌握以下概念：</p><ul><li>旋转矩阵</li><li>平移向量</li><li>齐次坐标</li><li>变换矩阵（旋转矩阵与平移向量的结合）</li></ul><p>参考：</p><ul><li><a href="https://blog.csdn.net/csxiaoshui/article/details/65446125#" target="_blank" rel="noopener">旋转变换（一）旋转矩阵</a></li><li><a href="https://www.cnblogs.com/flyinggod/p/8144100.html" target="_blank" rel="noopener">旋转矩阵、欧拉角、四元数理论及其转换关系</a></li></ul><h3>三个坐标系</h3><p><strong>图像坐标系</strong>： 一般来说，图像坐标系包括像素坐标系以及物理坐标系。</p><p><img src="/2019/05/12/SLAM之单目视觉里程计/01.jpg" alt="图像坐标系"></p><p>对于图像直角坐标系上的坐标$(u,v)$，分别能从像素的行数和列数得到，叫做像素坐标系。为表示像素点在图像中的位置我们需要借助物理坐标系，以图像中某一点$O_{1}$当作原点建立坐标系，其中$x$轴，$y$轴分别与像素坐标系的横、竖轴平行，方向一致。其中$(x, y)$坐标单位为毫米，$O_{1}$在$(u, v)$坐标系下的坐标为$\left(u_{0}, v_{0}\right)$，$d_{x}$和$d_y$表示每个像素点在$x$,$y$轴上的尺寸大小，则有：$$\left{\begin{array}{l}{u=\frac{x}{d x}+u_{0}} \ {v=\frac{y}{d y}+v_{0}}\end{array}\right.$$即：$$\left[ \begin{array}{c}{u} \ {v} \ {1}\end{array}\right]=\left[ \begin{array}{ccc}{\frac{1}{d x}} &amp; {0} &amp; {u_{0}} \ {0} &amp; {\frac{1}{d y}} &amp; {v_{0}} \ {0} &amp; {0} &amp; {1}\end{array}\right] \left[ \begin{array}{l}{x} \ {y} \ {1}\end{array}\right]$$<strong>相机坐标系</strong>：相机坐标系原点位于光心。如图所示，相机光心为点$O$，$Z_{c}$与像平面垂直，为相机的光轴，$X_{c}, Y_{c}$分别与$x,y$轴相平行，焦距大小为线段$O O_{1}$的长度，则将$O-X_{c} Y_{c} Z_{c}$坐标系称作相机坐标系。</p><p><img src="/2019/05/12/SLAM之单目视觉里程计/02.jpg" alt="相机坐标系"></p><p><strong>世界坐标系</strong>:世界坐标系可以对场景的中的任何物体进行描述，同时能表示出相机坐标。如上图中，将坐标系$O_{w}-X_{w} Y_{w} Z_{w}$称为世界坐标系，其与相机坐标系的相互变换可以通过$3 \times 1$的平移向量$t$以及$3\times 3$的旋转矩阵$R$来表示，设点$P$在世界坐标系中的齐次坐标为$\left(X_{w}, Y_{w}, Z_{w}, 1\right)^{T}$，在相机坐标系中的齐次坐标为$\left(X_{c}, Y_{c}, Z_{c}, 1\right)^{T}$，那么二者的转换关系为：$$\left[ \begin{array}{c}{X_{c}} \ {Y_{c}} \ {Z_{c}} \ {1}\end{array}\right]=\left[ \begin{array}{cc}{R} &amp; {t} \ {0^{T}} &amp; {1}\end{array}\right] \left[ \begin{array}{c}{X_{w}} \ {Y_{w}} \ {Z_{w}} \ {1}\end{array}\right]=M_{1} \left[ \begin{array}{c}{X_{w}} \ {Y_{w}} \ {Z_{w}} \ {1}\end{array}\right]$$</p><h2>针孔相机模型</h2><p>针孔相机模型是将空间坐标映射到图像点的模型。</p><p>请阅读: 视觉SLAM十四讲 5.1.1</p><p>对于使用的数据集，一般会提供拍摄照片所用的相机的内参和畸变系数。如果使用自己的相机，则需要采用张正友标定法进行相机标定，以获取相机内参及畸变系数。</p><p>最终有：$$Z \boldsymbol{P}<em>{u v}=Z \left[ \begin{array}{c}{u} \ {v} \ {1}\end{array}\right]=\boldsymbol{K}\left(\boldsymbol{R} \boldsymbol{P}</em>{w}+\boldsymbol{t}\right)=\boldsymbol{K} T \boldsymbol{P}_{w}$$</p><p>其中$Z$为空间点三维坐标中的$Z$坐标值，$P_{uv}$代表空间点投影到像平面，在像平面上的坐标，$K$为相机内参，$R$为相机外参中的旋转矩阵，$t$为相机外参中的位移向量，$P_w$为空间点在世界坐标系下的三维坐标。其中：$$K=\left( \begin{array}{ccc}{f_{x}} &amp; {0} &amp; {c_{x}} \ {0} &amp; {f_{y}} &amp; {c_{y}} \ {0} &amp; {0} &amp; {1}\end{array}\right)$$</p><h2>单目视觉里程计</h2><p>单目视觉里程计主要需要了解<strong>对极约束</strong>、<strong>三角化</strong>和<strong>PnP</strong>。</p><p><strong>对极约束</strong></p><p>对极约束用于通过二维点之间的匹配关系，求解相邻两张图像之间的运动。关于对极约束的内容，请阅读视觉SLAM十四讲7.3，7.4。</p><p>使用对极约束求解本质矩阵可以通过调用opencv中的findEssentialMat函数完成。</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function">Mat <span class="title">findEssentialMat</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray points1, </span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray points2,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray cameraMatrix, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> method = RANSAC,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> prob = <span class="number">0.999</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> threshold = <span class="number">1.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray mask = noArray())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例调用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">Mat E = findEssentialMat(p1, p2, M);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>points1与points2是vector&lt;Point2f&gt;类型，两vector的size相同，对应位置上的Point2f互相匹配。</li><li>cameraMatrix是相机内参矩阵</li><li>method是计算方法，RANSAC是openCV中被define的常量，表示采用RANSAC方法进行本征矩阵计算</li><li>prob是估计矩阵正确的可信度</li><li>参数threshold用于RANSAC的参数。 它是从点到极线的最大距离（以像素为单位），超出此点时，该点被视为异常值，不用于计算最终的基本矩阵。 根据点定位精度，图像分辨率和图像噪声的不同，可将其设置为1-3。</li><li>参数mask输出N个元素的数组，其中每个元素对于异常值设置为0，对其他点设置为1。</li></ul><p>求解出本征矩阵E后，调用recoverPose求解旋转矩阵和位移向量。</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recoverPose</span><span class="params">(Mat E,</span></span></span><br><span class="line"><span class="function"><span class="params">                InputArray points1,</span></span></span><br><span class="line"><span class="function"><span class="params">                InputArray points2,</span></span></span><br><span class="line"><span class="function"><span class="params">                InputArray cameraMatrix,</span></span></span><br><span class="line"><span class="function"><span class="params">                OutputArray R,</span></span></span><br><span class="line"><span class="function"><span class="params">                OutputArray t,</span></span></span><br><span class="line"><span class="function"><span class="params">                OutputArray mask = noArray())</span></span>; </span><br><span class="line"><span class="comment">//示例调用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">int</span> pass_count = recoverPose(E,p1, p2, M, R, t,mask);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>E是经过findEssentialMat求解出的本征矩阵</li><li>points1，points2，cameraMatrix，mask与findEssentialMat函数中的意义相同</li><li>R是求解出的旋转矩阵</li><li>t是求解出的位移向量</li></ul><p>R和t组成变换矩阵T，这里的T是是第一张图到第二张图的坐标变换矩阵。或者可以理解为第一张图相机相对于相机初始位置的变换矩阵是X。因为第一张图相机所处的位置是初始位置，所以有：$X = eye(4)$，其中$eye(4)$是四阶单位矩阵。那么T左乘X是第二个图的相机的坐标变换矩阵。</p><p>对极约束可以求解出两张图像之间的相机变换矩阵，但是它是2D和2D之间求解的变换矩阵，t的尺度无法确定，t可能是1米，可能是1cm。</p><p><strong>三角化</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reconstruct</span><span class="params">(Mat&amp; K, Mat&amp; R1, Mat&amp; T1, Mat&amp; R2, Mat&amp; T2, <span class="built_in">vector</span>&lt;Point2f&gt;&amp; p1, <span class="built_in">vector</span>&lt;Point2f&gt;&amp; p2, <span class="built_in">vector</span>&lt;Point3f&gt;&amp; structure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//两个相机的投影矩阵[R T]，triangulatePoints只支持float型</span></span><br><span class="line"><span class="function">Mat <span class="title">proj1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">proj2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line">R1.convertTo(proj1(Range(<span class="number">0</span>, <span class="number">3</span>), Range(<span class="number">0</span>, <span class="number">3</span>)), CV_32FC1);</span><br><span class="line">T1.convertTo(proj1.col(<span class="number">3</span>), CV_32FC1);</span><br><span class="line"></span><br><span class="line">R2.convertTo(proj2(Range(<span class="number">0</span>, <span class="number">3</span>), Range(<span class="number">0</span>, <span class="number">3</span>)), CV_32FC1);</span><br><span class="line">T2.convertTo(proj2.col(<span class="number">3</span>), CV_32FC1);</span><br><span class="line"></span><br><span class="line">Mat fK;</span><br><span class="line">K.convertTo(fK, CV_32FC1);</span><br><span class="line">proj1 = fK*proj1;</span><br><span class="line">proj2 = fK*proj2;</span><br><span class="line"><span class="comment">//三角重建</span></span><br><span class="line">Mat s;</span><br><span class="line">triangulatePoints(proj1, proj2, p1, p2, s);</span><br><span class="line"></span><br><span class="line">structure.clear();</span><br><span class="line">structure.reserve(s.cols);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.cols; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;<span class="keyword">float</span>&gt; col = s.col(i);</span><br><span class="line">col /= col(<span class="number">3</span>);  <span class="comment">//齐次坐标，需要除以最后一个元素才是真正的坐标值</span></span><br><span class="line">structure.push_back(Point3f(col(<span class="number">0</span>), col(<span class="number">1</span>), col(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三角化在得到两个相机的旋转矩阵、位移向量后，可以根据匹配的特征点进行三角化，最终能够求得特征点对应的空间点云的坐标。</p><p><strong>PnP</strong></p><p>PnP在得知了对应的空间点的三维坐标和新加入的图像中的特征点的二维坐标之后，可以求解新加入的图像的相机的旋转矩阵和位移向量。</p><p>参考<a href="https://blog.csdn.net/jay463261929/article/details/53818611" target="_blank" rel="noopener">opencv中solvePnPRansac函数求解相机位姿</a></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solvePnPRansac</span><span class="params">(InputArray objectPoints,</span></span></span><br><span class="line"><span class="function"><span class="params">                    InputArray imagePoints,</span></span></span><br><span class="line"><span class="function"><span class="params">                    InputArray cameraMatrix,</span></span></span><br><span class="line"><span class="function"><span class="params">                    InputArray dist，</span></span></span><br><span class="line"><span class="function"><span class="params">                    OutputArray rvec,</span></span></span><br><span class="line"><span class="function"><span class="params">                    OutputArray tvec,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ...)</span></span>;</span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">solvePnPRansac(object_points, image_points, K, noArray(), r, T);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li><p>objectPoints为三维坐标，imagePoints为二维坐标，对应位置的坐标互相匹配。</p></li><li><p>cameraMatrix为相机内参。</p></li><li><p>dist为畸变参数矩阵。</p></li><li><p>rvec为求解出的相机<strong><em>旋转向量</em></strong>，不是旋转矩阵。可经过罗德里格斯变换获取旋转矩阵。</p></li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rodrigues(r, R);</span><br></pre></td></tr></table></figure></p><ul><li>tvec为求解出的相机位移向量。</li></ul><p>这里的objectPoints为原有空间点云三维坐标。imagePoints为新加入的一张图像中的特征点的图像坐标。假设刚开始运行程序时候，点云$C_{12}$由前两张图像的相机的旋转矩阵、位移向量和匹配的特征点经过三角化求解出来。</p><p>上述过程涉及到的前两张图像中第一张图像的相机旋转矩阵为三阶单位矩阵，位移向量为0，即第一张图像的相机处于起始位置；第二张图像的旋转矩阵和位移向量通过对极几何被求解出来。</p><p>进行求解PnP需要构建已有空间点云三维坐标和新加入图像中的特征点二维坐标的匹配关系。那么这个关系是怎么建立的呢？是在图一、图二进行三角化生成空间点云时候，会生成空间点云中点与图二中特征点的匹配关系。图二与图三进行匹配，可获得图二与图三中特征点的匹配关系。由此可获得图三中特征点与原有空间点云中点的匹配关系。</p><p>程序经过一次PnP，求解出第三张图像的相机的旋转矩阵和位移矩阵后，可以使用第三张图像的相机的旋转矩阵和位移向量与第二张图像的旋转矩阵和位移向量进行三角化，生成第二张图像和第三张图像共同构建的空间点云$C_{23}$。</p><p>之后，空间点云可以进行点的添加和旧点的消除，每次新加入的一张图像的相机位姿可以通过PnP求解出来。</p><h2>参考资料</h2><p>【1】《视觉SLAM十四讲》 —— 高翔</p><p>【2】 葛均强. 基于无人机航拍图像序列的三维重建研究与实现[D]. 电子科技大学,2015.</p><p>【3】<a href="https://www.bilibili.com/video/av5987715?from=search&amp;seid=17088161877399053008" target="_blank" rel="noopener">线性代数的本质——3blue1brown</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> 机器视觉 </tag>
            
            <tag> 单目 </tag>
            
            <tag> 视觉里程计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OJ技巧</title>
      <link href="/2019/05/10/OJ%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/05/10/OJ%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1>OJ中的奇技淫巧</h1><h2>使用异或进行swap</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    a=a^b;</span><br><span class="line">    b=a^b;</span><br><span class="line">    a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>单行多字符串处理</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss&lt;&lt;s;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;s)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>加快cin速度</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h2>while和scanf</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读到文件的结尾，程序自动结束</span></span><br><span class="line"><span class="keyword">while</span>( ( <span class="built_in">scanf</span>( <span class="string">" %d "</span> ,&amp;a) ) != <span class="number">-1</span> )</span><br><span class="line"><span class="keyword">while</span>( ( <span class="built_in">scanf</span>( <span class="string">" %d "</span> ,&amp;a) ) != EOF)</span><br><span class="line"><span class="keyword">while</span>( ( <span class="built_in">scanf</span>( <span class="string">" %d "</span> ,&amp;a) ) == <span class="number">1</span> )</span><br><span class="line"><span class="keyword">while</span>( ~( <span class="built_in">scanf</span>( <span class="string">" %d "</span> ,&amp;a) ) )</span><br><span class="line"><span class="comment">//读到一个 0 时，程序结束</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>( <span class="string">" %d "</span> ,&amp;a) ,a)</span><br><span class="line"><span class="comment">//读到多个0时，程序结束</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>( <span class="string">" %d%d%d "</span> ,&amp;a,&amp;b,&amp;c),a+b+c ) <span class="comment">//a,b,c非负</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>( <span class="string">" %d%d%d "</span> ,&amp;a,&amp;b,&amp;c),a|b|c )</span><br></pre></td></tr></table></figure></p><h2>vector定义二维数组</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len,<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs229</title>
      <link href="/2019/05/10/cs229/"/>
      <url>/2019/05/10/cs229/</url>
      
        <content type="html"><![CDATA[<h1>CS229</h1><ul><li><a href="https://github.com/econti/cs229" target="_blank" rel="noopener">课程讲义</a></li><li><a href="https://blog.csdn.net/blackyuanc/article/details/68951640" target="_blank" rel="noopener">CSDN博主中文翻译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro装机配置</title>
      <link href="/2019/05/09/manjaro%E8%A3%85%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/05/09/manjaro%E8%A3%85%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2>配置镜像源:</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure></p><p>打开配置文件sudo nano /etc/pacman.conf在文件末尾添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></p><h2>导入GPG Key</h2><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure></p><h2>安装软件</h2><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S vim cmake firefox-i18n-zh-cn gdb nodejs fcitx-im fcitx-configtool fcitx-sogoupinyin yarn visual-studio-code-bin texmaker </span><br><span class="line">sudo pacman -S google-chrome deepin.com.qq.office netease-cloud-music typora vlc wewechat wps-office ttf-wps-fonts</span><br><span class="line">sudo pacman -S mysql eclipse-jee opencv webstorm clion pycharm-professional intellij-idea-ultimate-edition qtcreator qt4 maven android-studio nginx</span><br></pre></td></tr></table></figure></p><h2>配置搜狗环境</h2><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.xprofile</span><br></pre></td></tr></table></figure></p><p>添加以下内容</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span></span><br></pre></td></tr></table></figure></p><h2>配置firefox</h2><p>地址栏输入about:config</p><p>搜索intl.locale.requested 将其值修改为zh_CN</p><h2>配置yarn</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global bin</span><br><span class="line">sudo vim /etc/profile </span><br><span class="line">appendpath &apos;/home/douxl/.yarn/bin&apos;</span><br></pre></td></tr></table></figure></p><h2>禁用pcspkr</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod pcspkr</span><br><span class="line">sudo vim /etc/modprobe.d/nobeep.conf</span><br></pre></td></tr></table></figure></p><p>输入</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist pcspkr</span><br></pre></td></tr></table></figure></p><h2>nodejs包</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add hexo vue-cli</span><br></pre></td></tr></table></figure></p><h2>pip</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure></p><p>输入以下内容</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><h2>python 包</h2><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy pandas sklearn matplotlib requests minepy</span><br></pre></td></tr></table></figure></p><h2>配置git</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;douxl5516@163.com&quot;</span><br><span class="line">git config --global user.name &quot;douxl5516&quot;</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></p><h2>与windows时间同步</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure></p><h2>SSH</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;douxl5516@163.com&quot;</span><br></pre></td></tr></table></figure></p><h2>WPS字体缺失问题</h2><p>国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip</p><p>国内下载地址：https://pan.baidu.com/s/1eS6xIzo</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp * /usr/share/fonts</span><br><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo <span class="built_in">fc</span>-cache</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研中用到的数学基础</title>
      <link href="/2019/05/04/%E7%A7%91%E7%A0%94%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/04/%E7%A7%91%E7%A0%94%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>数学基础</h1><h2>范数</h2><blockquote><p>在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p></blockquote><ul><li>LP范数不是一个范数，而是一组范数。定义如下：</li></ul><p>$$L_p=\Vert x \Vert_p=\sqrt[p]{\sum_{i=1}^{n}{x_i^p}},x=(x_1,x_2,\dots,x_n)$$</p><ul><li>L0范数表示向量中非零元素的个数。</li><li>L1范数表示向量x中非零元素的绝对值之和。定义如下：</li></ul><p>$$L_1=\Vert x \Vert_1=\sum_{i=1}^{n}{|x_i|},x=(x_1,x_2,\dots,x_n)$$</p><ul><li><p>L2范数表示向量元素的平方和再开平方，即欧氏距离。</p><p>二范数指矩阵A的2范数，就是A的转置共轭矩阵与矩阵A的积的最大特征根的平方根值，是指空间上两个向量矩阵的直线距离。类似于求棋盘上两点间的直线距离。</p><p>定义如下：</p></li></ul><p>$$L_2=\Vert x \Vert_2=\sqrt{\sum_{i=1}^{n}{x_i^2}},x=(x_1,x_2,\dots,x_n)$$</p><ul><li><a href="https://baike.baidu.com/item/%E8%8C%83%E6%95%B0/10856788?fr=aladdin" target="_blank" rel="noopener">百度百科</a></li><li><a href="https://blog.csdn.net/a493823882/article/details/80569888" target="_blank" rel="noopener">几种范数</a></li></ul><h2>梯度</h2><p>即对于一般标量函数$f(x)$ , 其中向量为$x=(x_1,x_2,\dots,x_n)$，导数为：$$\frac{\partial{f}}{\partial{x}}=(\frac{\partial{f}}{\partial{x_1}},\dots,\frac{\partial{f}}{\partial{x_2}})$$</p><h2>雅可比矩阵</h2><blockquote><p>在向量微积分中，雅可比矩阵(Jacobi Matrix)是一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。因此，雅可比矩阵类似于多元函数的导数。</p></blockquote><p>$$J(f)=\left|\frac{\partial{(f_1,\dots,f_n)}}{\partial{(x_1,\dots,x_n)}}\right|=\left|\begin{matrix}\frac{\partial{f_1}}{\partial{x_1}}&amp;\dots&amp;\frac{\partial{f_1}}{\partial{x_n}}\\vdots&amp;\ddots&amp;\vdots\\frac{\partial{f_n}}{\partial{x_1}}&amp;\dots&amp;\frac{\partial{f_n}}{\partial{x_n}}\\end{matrix}\right|$$</p><p>若m=n，则雅可比矩阵为<strong>方阵</strong>，方阵的行列式为<strong>雅可比行列式</strong>。</p><ul><li><a href="https://baike.baidu.com/item/%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/10753754?fr=aladdin" target="_blank" rel="noopener">雅可比矩阵</a></li></ul><h2>海森矩阵</h2><blockquote><p>黑塞矩阵（Hessian Matrix），又译作海森矩阵、海瑟矩阵、海塞矩阵等，是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。黑塞矩阵最早于19世纪由德国数学家Ludwig Otto Hesse提出，并以其名字命名。黑塞矩阵常用于牛顿法解决优化问题，利用黑塞矩阵可判定多元函数的极值问题。在工程实际问题的优化设计中，所列的目标函数往往很复杂，为了使问题简化，常常将目标函数在某点邻域展开成泰勒多项式来逼近原函数，此时函数在某点泰勒展开式的矩阵形式中会涉及到黑塞矩阵。</p></blockquote><p>$$H(f)=\left[\begin{matrix}\frac{\partial^2{f}}{\partial{x_1^2}}&amp;\frac{\partial^2{f}}{\partial{x_1}\partial{x_2}}&amp;\dots&amp;\frac{\partial^2{f}}{\partial{x_1}\partial{x_n}}\</p><p>\frac{\partial^2{f}}{\partial{x_2}\partial{x_1}}&amp;\frac{\partial^2{f}}{\partial{x_2^2}}&amp;\dots&amp;\frac{\partial^2{f}}{\partial{x_2}\partial{x_n}}\</p><p>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\</p><p>\frac{\partial^2{f}}{\partial{x_n}\partial{x_1}}&amp;\frac{\partial^2{f}}{\partial{x_n}\partial{x_2}}&amp;\dots&amp;\frac{\partial^2{f}}{\partial{x_n^2}}\</p><p>\end{matrix}\right]$$</p><ul><li><a href="https://baike.baidu.com/item/%E9%BB%91%E5%A1%9E%E7%9F%A9%E9%98%B5/2248782?fr=aladdin" target="_blank" rel="noopener">海森矩阵</a></li></ul><h2>泰勒公式</h2><blockquote><p>数学中，泰勒公式是一个用函数在某点的信息描述其附近取值的公式。如果函数足够平滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值。泰勒公式还给出了这个多项式和实际的函数值之间的偏差。</p></blockquote><p>$$f(x)=\frac{f(a)}{0!}+\frac{f'(a)}{1!}(x-a)+\frac{f''(a)}{2!}(x-a)^2+\dots+\frac{f^n(a)}{n!}(x-a)^n+R_n(x)$$</p><h2>李代数</h2><p>首先特殊正交群SO(3)可以代表旋转矩阵，SE(3)可以代表欧式变换矩阵。矩阵对于乘法封闭，对于加法不封闭，所以具有群的特性。</p><p>李群是指具有连续(光滑)性质的群。</p><ul><li><p>外积$$\boldsymbol{a}\times\boldsymbol{b}=\left[\begin{matrix}\boldsymbol{i}&amp;\boldsymbol{j}&amp;\boldsymbol{k}\a_1&amp;a_2&amp;a_3\b_1&amp;b_2&amp;b_3\\end{matrix}\right]=\left[\begin{matrix}a_2b_3-a_3b_2\a_3b_1-a_1b_3\a_1b_2-a_2b_1\\end{matrix}\right]=\left[\begin{matrix}0&amp;-a_3&amp;a_2\a_3&amp;0&amp;-a_1\-a_2&amp;a_1&amp;0\\end{matrix}\right]\boldsymbol{b}\triangleq\boldsymbol{a}^{\wedge}\boldsymbol{b}$$相应的，有$$\boldsymbol{a}=[a_1\boldsymbol{i},a_2\boldsymbol{j},a_3\boldsymbol{k}],\\boldsymbol{a}^{\wedge}=\boldsymbol{A}=\left[\begin{matrix}0&amp;-a_3&amp;a_2\a_3&amp;0&amp;-a_1\-a_2&amp;a_1&amp;0\\end{matrix}\right],\\boldsymbol{A}^{\vee}=\boldsymbol{a}$$</p></li><li><p>特殊正交群 $SO(3)$$$SO(3)={R\in\mathbb{R}^{3\times3}|RR^T=I,\det(R)=1}$$</p></li><li><p>特殊欧式群$SE(3)$$$SE(3)={T=\left[\begin{matrix}R&amp;t\0^T&amp;1\\end{matrix}\right]\in\mathbb{R}^{4\times4}|R\in SO(3),t\in \mathbb{R}^3}$$</p></li><li><p>李代数$\mathfrak{so}(3)$</p><p>在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{'}R(t)^T$是一个反对称矩阵，那么就用一个$\phi(t)\in\mathbb{R}^3$与之对应。有：$$R(t)^{'}R(t)^T=\phi(t)^{\wedge}$$之后求解微分方程，可以得到：$$R(t)=exp(\phi^{\wedge}t)$$实际求解时利用到指数映射和对数映射。</p></li></ul><h2>奇异值分解</h2><p><a href="https://www.cnblogs.com/lzllovesyl/p/5243370.html" target="_blank" rel="noopener">参考资料</a></p><p><a href="https://blog.csdn.net/xiaocong1990/article/details/54909126/" target="_blank" rel="noopener">分解原理</a></p><h2>方阵的迹</h2><blockquote><p><a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%B9/8889744?fr=aladdin" target="_blank" rel="noopener">百度百科词条</a></p><p>在<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/800" target="_blank" rel="noopener">线性代数</a>中，一个n×n矩阵<strong><em>A</em></strong>的<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AF%B9%E8%A7%92%E7%BA%BF/4269887" target="_blank" rel="noopener">主对角线</a>（从左上方至右下方的对角线）上各个元素的总和被称为<a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069" target="_blank" rel="noopener">矩阵</a><strong><em>A</em></strong>的<strong>迹</strong>（或<strong>迹数</strong>），一般记作<strong>tr(A)</strong>。</p></blockquote><h3>性质</h3><ul><li><p>tr(AB)=tr(BA)</p></li><li><p>tr(ABC)=tr(CAB)=tr(BCA)</p></li><li><p>f(a)=tr(AB)，$\bigtriangledown_Atr(AB)=B^T$</p></li><li><p>$tr(A)=tr(A^T)$</p></li><li><p>tr(a)=a,$a \in R$</p></li><li><p>$\bigtriangledown_Atr(ABA^TC)=CAB+C^TAB^T$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake入门</title>
      <link href="/2018/09/13/CMake%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/13/CMake%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://blog.csdn.net/yaoyuanyylyy" target="_blank" rel="noopener">yaoyuanyylyy</a><a href="https://blog.csdn.net/yaoyuanyylyy/article/details/79024962" target="_blank" rel="noopener">CMake入门1——CMake与VS编译器和nmake的结合使用</a><a href="https://blog.csdn.net/yaoyuanyylyy/article/details/79043599" target="_blank" rel="noopener">CMake入门2——复杂项目的构建配置</a><a href="https://blog.csdn.net/yaoyuanyylyy/article/details/79051295" target="_blank" rel="noopener">CMake入门3——更多指令的使用</a>本文描述在Win10-64位系统中安装CMake、cmake-gui的简单使用及其与VS2015编译器的结合使用，以及cmake命令行与nmake的结合使用。</p><h1>下载</h1><p>从<a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake官网</a>上下载最新版本的安装包，本文中下载的是 <strong>cmake-3.10.1-win64-x64.msi</strong>。若不想安装，可直接下载压缩包版本<a href="https://cmake.org/files/v3.10/cmake-3.10.1-win64-x64.zip" target="_blank" rel="noopener">cmake-3.10.1-win64-x64.zip</a>。</p><h1>安装</h1><p>CMake的安装非常简单。压缩包版本直接解压即可，安装版本也可一直点击下一步进行安装。为了使用方便，可将CMake配置到环境变量中，当然，这一步也可以在安装过程中设置。另外需要注意的是为了避免不必要的麻烦，路径中最好不要包括中文字符。下面简单描述一下安装过程。</p><ol><li>双击下载的安装包，进入安装界面，点击[Next]。<img src="/2018/09/13/CMake入门/1.png" alt="这里写图片描述"></li><li>勾选同意许可后，点击[Next]。<img src="/2018/09/13/CMake入门/2.png" alt="这里写图片描述"></li><li>可在此处选择将CMake路径添加到环境变量中，并且创建CMake GUI程序的桌面快捷方式。然后点击[Next]。<img src="/2018/09/13/CMake入门/3.png" alt="这里写图片描述"></li><li>可在此处自定义安装目录，设置好后点击[Next]。<img src="/2018/09/13/CMake入门/4.png" alt="这里写图片描述"></li><li>开始安装，安装完成后点击[Next]。<img src="/2018/09/13/CMake入门/5.png" alt="这里写图片描述"></li><li>安装完成，点击[Finish]，结束安装过程。<img src="/2018/09/13/CMake入门/6.png" alt="这里写图片描述"></li><li>安装完成后，即可使用CMake了。在命令行中输入<code>&quot;cmake --version&quot;</code>，可看到如下图所示的输出。<img src="/2018/09/13/CMake入门/7.png" alt="这里写图片描述"></li></ol><h1>例1 使用cmake-gui与VS生成器</h1><p>本例使用cmake-gui和VS生成器构建出VS工程，然后用VS工具打开项目进行编译。</p><ol><li>新建CMakeTest目录，在CMakeTest目录下新建demo1目录，作为测试项目的根目录。在demo1下新建main.cpp和CMakeLists.txt文件。<img src="/2018/09/13/CMake入门/8.png" alt="这里写图片描述">main.cpp文件的内容很简单，就是输出一个提示字符串：</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;cmake test demo 1&quot;&lt;&lt;endl;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CMakeLists文件内容如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CMake最低版本要求 </span><br><span class="line">cmake_minimum_required(VERSION 3.10.1)</span><br><span class="line"># 项目信息</span><br><span class="line">project(demo1)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(demo main.cpp)</span><br></pre></td></tr></table></figure></p><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔，且命令是不区分大小写的。符号 # 后面的内容被认为是注释。对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ul><li><strong>cmake_minimum_required</strong>：指定运行此配置文件所需的 CMake 的最低版本，如果低于3.10.1版本，则构建过程会被终止</li><li><strong>project</strong>：参数值是 demo1，该命令表示项目的名称是 demo1</li><li><strong>add_executable</strong>： 将名为 main.cpp 的源文件编译成一个名称为 demo 的可执行文件</li></ul><ol><li>打开cmake-gui程序，在上方配置两个目录:</li></ol><ul><li>第一个是CMakeLists文件目录，cmake据此开始执行</li><li>第二个是cmake构建后的项目目录<img src="/2018/09/13/CMake入门/9.png" alt="这里写图片描述"></li></ul><ol><li>配置好点击[Configure]开始执行配置过程。首先会弹出编译器选择界面，此处使用默认的VS2015-32位编译器，直接点击[Finish]，开始配置。<img src="/2018/09/13/CMake入门/10.png" alt="这里写图片描述"></li><li>第一次配置完成后如图所示，红色的两行是新的配置值，再次点击[Configure]即可。<img src="/2018/09/13/CMake入门/11.png" alt="这里写图片描述"><img src="/2018/09/13/CMake入门/12.png" alt="这里写图片描述"></li><li>配置完成后，在build目录生成了如下的文件<img src="/2018/09/13/CMake入门/13.png" alt="这里写图片描述"></li><li>点击[Generate]，开始生成VS项目<img src="/2018/09/13/CMake入门/14.png" alt="这里写图片描述"></li><li>生成完成后，在build目录下生成了demo1对于的VS项目<img src="/2018/09/13/CMake入门/15.png" alt="这里写图片描述"></li><li>通过点击cmake-gui中下放的[Open Project]按钮或者直接双击build目录下的demo1.sln，即可在VS中打开工程。<img src="/2018/09/13/CMake入门/16.png" alt="这里写图片描述"></li><li>cmake生的demo1工程总共有3个项目</li></ol><ul><li><strong>ZERO_CHECK</strong>：该项目会检查生成工程的 CMake 配置文件（ CMakeLists.txt  ）是否更新。如更新，将运行 CMake 重新生成工程文件。如果确信 CMakeLists.txt 不会被更新，或者希望手工运行 CMake  重新生成工程文件，可以在 CMakeLists.txt 配置文件中添加 set(CMAKE_SUPPRESS_REGENERATION  FALSE) 命令， ZERO_CHECK 目标将不会生成。</li><li><strong>ALL_BUILD</strong>：该目标会导致工程中所有项目被构建，类似 Visual Studio 的 Build All 或者 make 的 make all命令。</li><li><strong>demo</strong>：项目本身，就是在CMakeLists.txt文件中配置的<code>project(demo1)</code></li></ul><ol><li>在VS中通过单独生成项目demo1或者直接生成项目All_BUILD后，可以在build下的相应目录看到可执行文件demo.exe已经生成。双击demo.exe后，可以看到程序输出。<img src="/2018/09/13/CMake入门/17.png" alt="这里写图片描述"></li><li>如果不想用VS打开工程，也可以使用msbuild.exe编译demo1工程。首先需要打开VS命令行，因为cmake-gui中选择的编译器是32位的，所以此处选择”VS2015 x86 本机工具命令提示符”。<img src="/2018/09/13/CMake入门/18.png" alt="这里写图片描述">打开后在命令行中进入到demo1的build目录，执行<code>msbuild demo1.sln</code>即可编译demo1项目。编译完成后可以在debug中看到生成的demo.exe文件，双击可运行。<img src="/2018/09/13/CMake入门/19.png" alt="这里写图片描述"></li></ol><h1>例2 使用cmake命令与nmake生成器 本例使用cmake命令行与nmake生成器构建Makefile，然后用nmake编译项目。</h1><ol><li>新建项目demo2，将demo1中的main.cpp和CMakeLists.txt文件拷贝过来。将CMakeLists.txt文件中的project项目配置为demo2。 2. 同样从VS命令行进入到demo2目录，执行命令：</li></ol><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G <span class="string">"NMake Makefiles"</span> .</span><br></pre></td></tr></table></figure></p><p>执行完毕后，即可看到在demo2目录中生成了一些文件：<img src="/2018/09/13/CMake入门/20.png" alt="这里写图片描述">其中重要的是Makefile文件，这是用来编译项目的。在命令行中继续执行nmake命令开始编译，编译完成后可以看到在demo2目录生成了demo.exe程序。允许后可以看到输出。<img src="/2018/09/13/CMake入门/21.png" alt="这里写图片描述"></p><h1>例3 PreLoad.cmake用法</h1><p>在命令行下使用cmake，需要用”-G”选项指定生成器。每次都输入感觉比较麻烦，可以将其配置在”PreLoad.cmake”文件中。新建项目demo3，准备好main.cpp和CMakeLists.txt文件，然后demo3目录下新建文件”PreLoad.cmake”，输入：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_GENERATOR <span class="string">"NMake Makefiles"</span> CACHE INTERNAL <span class="string">""</span> FORCE)</span><br></pre></td></tr></table></figure></p><p>然后执行<code>&quot;cmake .&quot;</code>即可配置，然后执行<code>&quot;nmake&quot;</code>就可以编译。</p><h1>例4 多文件单目录测试</h1><p>此测试项目将所有的文件都放在根目录下。在CMakeTest目录下新建demo4目录。demo4项目文件列表如下：<img src="/2018/09/13/CMake入门/22.png" alt="这里写图片描述">其中实现了算术运算的加减乘除，每个功能分别实现在各自的文件中：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p><p>然后在main.cpp中调用各个函数，代码如下：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"minus.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"multiply.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"divide.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"cmake test demo 4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"+"</span>&lt;&lt;b&lt;&lt;<span class="string">"="</span>&lt;&lt;my_add(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"-"</span>&lt;&lt;b&lt;&lt;<span class="string">"="</span>&lt;&lt;my_minus(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"*"</span>&lt;&lt;b&lt;&lt;<span class="string">"="</span>&lt;&lt;my_multiply(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"/"</span>&lt;&lt;b&lt;&lt;<span class="string">"="</span>&lt;&lt;my_divide(a, b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CMakeLists.txt文件内容如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>此配置文件中使用了一条新命令：</p><ul><li><strong>aux_source_directory</strong>：该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。这样，就不用在add_executable中列出所有源文件了，而是直接引用变量即可。从VC命令行进入到demo4目录，然后执行cmake命令和nmake命令，即可编译出执行程序。<img src="/2018/09/13/CMake入门/23.png" alt="这里写图片描述"></li></ul><h1>例5 多文件单子目录测试</h1><p>此测试项目将main入口函数文放在根目录下，其他文件放在独立目录下。新建demo5目录，使用例3中的项目文件，将main.cpp放在demo5目录下，将其他的加减乘除的相关文件放在math子目录下。然后在demo5目录和math目录下分别放一个CMakeLists.txt文件。<img src="/2018/09/13/CMake入门/24.png" alt="这里写图片描述"><img src="/2018/09/13/CMake入门/25.png" alt="这里写图片描述">其中demo5目录下的CMakeLists.txt文件内容如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">math</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加math子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure></p><p>在这个配置文件中，依次出现了几条新的cmake命令：</p><ul><li><strong>include_directories</strong>：头文件包含目录，因为main.cpp中使用了加减乘除函数，因此需要指明头文件目录所在之处。当然，也可以在main.cpp中包含都文件时指定目录</li><li><strong>add_subdirectory</strong>：添加子目录命令，表示需要编译该子目录</li><li><strong>target_link_libraries</strong>：添加要依赖的库文件，此处的math库是在子目录math中编译出来的math目录下的CMakeLists.txt文件内容如下：</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>在上面这个配置文件中，出现了一条新命令：</p><ul><li><strong>add_library</strong>：将指定的文件编译为库，前面是库名称，后面是源文件进demo5目录，然后执行cmake命令和nmake命令，即可编译出执行程序。可以看到，在math子目录下生成了一个”math.lib”的库文件。</li></ul><h1>例6 多目录和多级目录测试</h1><p>本例子demo6中把加减乘除四个运算分散在不同的目录下，形成了多个目录、多级目录的形式。具体的文件布局如下图所示：<img src="/2018/09/13/CMake入门/26.png" alt="这里写图片描述">多个子目录和多级目录在用cmake来构建时的一种方式是：将所有源文件按功能或目录来分别构建为库，然后在需要用到库的地方链接上所需的一个或多个库。对于此例来说，各目录的说明和构建方式如下：</p><ul><li>demo6根目录下包括了math和divide两个目录；</li><li>divide目录是除法目录，由其目录中的配置文件单独构建为一个库；</li><li>math目录包括了add_minus和multiply两个目录；</li><li>add_minus目录包括加法的实现文件和减法目录minus;</li><li>减法不单独构建为库，而是和加法一起，用add_minus中的配置文件构建为一个库；</li><li>乘法的库也不再它自己的目录中构建，而是在math目录下构建为单独的乘法库；</li><li>最后，在demo6根目录下的配置文件中构建demo.exe程序，并连接了乘法库、除法库、加减法合在一起的库；<strong>首先</strong>，divide目录下构建除法库的配置文件比较简单，使用了 <code>aux_source_directory</code>  和<code>add_library</code>两条指令。</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_LIB_DIVIDE_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_DIVIDE_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_library</span>(lib_divide <span class="variable">$&#123;DIR_LIB_DIVIDE_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></p><p><strong>其次</strong>，加减法库的构建如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_MINUS_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./minus DIR_MINUS_SRCS)</span><br><span class="line"><span class="comment"># 把要编译的文件都列在此处，存入ADD_SRCS变量中</span></span><br><span class="line"><span class="keyword">set</span>(ADD_SRCS add.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_library</span>(lib_add_minus <span class="variable">$&#123;ADD_SRCS&#125;</span> <span class="variable">$&#123;DIR_MINUS_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>这个也很简单，只是有3点小改变：</p><ul><li><strong>aux_source_directory</strong>指令中指定的目录为<code>./minus</code>，表示当前文件夹下的<code>minus</code>子目录，也就是把<code>minus</code>子目录下的减法源文件存在了<code>DIR_MINUS_SRCS</code>变量中</li><li>使用了一条新的指令<strong>set</strong>，这也是一条用来设置变量的，不过变量放在前面，变量的值放在后面。这里指定为将当前目录下的加法实现源文件存入变量<code>ADD_SRCS</code>中。需注意的是，后面的文件可以列出多个各处的文件</li><li>在<strong>add_library</strong>命令将前面的两个保存了加法和减法源文件的变量一起用来生成一个库<code>lib_add_minus</code><strong>再次</strong>，<code>math</code>目录下的配置文件如下：</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(add_minus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把要编译的文件都列在此处，存入DIR_MULTIPLY_SRC变量中</span></span><br><span class="line"><span class="keyword">set</span>(DIR_MULTIPLY_SRC multiply/multiply.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_library</span>(lib_multiply <span class="variable">$&#123;DIR_MULTIPLY_SRC&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>在这个配置文件中，将<code>multiply</code>目录下的乘法编译成了单独的一个库，然后添加了<code>add_minus</code>子目录。所用的指令都是已使用过的。<strong>最后</strong>，根目录<code>demo6</code>下的配置文件如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo6)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">math</span>/add_minus <span class="keyword">math</span>/add_minus/minus <span class="keyword">math</span>/multiply)</span><br><span class="line"><span class="keyword">include_directories</span>(divide)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加math子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="comment"># 添加divide子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(divide)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo lib_add_minus)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo lib_multiply lib_divide)</span><br></pre></td></tr></table></figure></p><p>在这个配置文件中，有几点小说明：</p><ul><li>这个根目录下的配置文件为cmake的入口配置文件，所以在其中指定了最低版本。这样其实在子目录下的配置文件中就可以不用再用<code>cmake_minimum_required</code>指令了</li><li>用<code>include_directories</code>指令指明了头文件所在目录，一条命令中可以指定多个头文件包含目录。在实际项目中可将头文件提取到一个目录中，然后指定一个目录就可以了</li><li>用<code>add_subdirectory</code>指明了<code>divide</code>和<code>math</code>两个子目录</li><li>用<code>target_link_libraries</code>将各个库连接到目标程序”demo”中，此命令也可以一次指定多个库。至此，所有的工作就做好了，在命令下执行cmake命令和nmake命令，就可编译出执行程序。同时可以看到，在math子目录下生成了一个”lib_multiply.lib”库，在math/add_minus目录下生成了一个lib_add_minus.lib库，在divide目录下生成了lib_divide库。</li></ul><h1>基本语法规则</h1><p>从前面的几个例子中，我们使用了cmake的几条基本指令，在这里，总结一下：</p><ul><li>cmake由指令、注释和空白字符组成</li><li>以#开头，到行末尾的是注释</li><li>形如<code>指令(参数1 参数2 参数3 ...)</code>的是指令，参数间使用空格或者分号<code>;</code>隔开</li><li>指令不区分大小写，但参数是区分大小写的</li><li>cmake中可以设置变量，变量的引用方式为**${变量名}**</li><li>cmake的构建指令为**&quot;cmake path [参数选项]&quot;<strong>；当前我们都使用的是</strong>“cmake .”**，表示构建当前目录下的项目</li></ul><h1>内部构建与外部构建</h1><p>在前面的例子中，danger构建项目后，会发现cmake构建过程中产生的中间文件和项目文件混在一起，多了就不好区分；而且cmake不能跟踪这些中间文件，所以也没有一条可以清除它们的指令。这样的情况是因为我们使用的是cmake的内部构建，而cmake提供的另外一种称为外部构建的构建方式，可以解决这个问题。</p><ul><li><strong>内部构建</strong>：<code>in-source build</code>，在项目的入口配置文件目录下执行**“cmake .”**时，就是内部构建；这种方式下，生成的临时中间文件就放在了构建目录下，导致和源文件混在一起</li><li><strong>外部构建</strong>：<code>out-of-source build</code>，在其他目录下执行cmake构建命令，然后指定入口配置文件的目录，这样就可以将临时文件存放于单独的目录中。比如我们在项目下新建一个build目录，然后在build目录下执行**“cmake ..”**，那么我们就可以看到构建后的所有临时文件都产生在build目录中，这样就方便我们管理和清理了</li></ul><h1>例7 外部构建以及**&quot;project&quot;<strong>和</strong>&quot;message&quot;**指令</h1><p>首先，我们新建一个项目demo7，其中的源文件和demo6的是一样的，唯一的区别只有demo7根目录下的CMakeLists.txt文件不同，我们添加了几条**&quot;message&quot;**指令，这是用来在构建过程中显示消息的。配置文件的前面部分如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo7)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the BINARY dir is $&#123;demo7_BINARY_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 后面的没有改变，此处省略不显示</span></span><br></pre></td></tr></table></figure></p><p>因为要采用外部构建的方式，因此我们先新建一个build目录，然后在build目录下执行cmake构建指令。过程如下：<img src="/2018/09/13/CMake入门/27.png" alt="这里写图片描述">可以从以一个红框中看到外部构建的一般过程。这里我们来看看第二个红框中的输出内容，这就是**&quot;message&quot;**指令的输出。**&quot;message&quot;**指令的语法如下：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">"message"</span> ...)</span><br></pre></td></tr></table></figure></p><p>第一个参数是消息类型，后面的参数是一条或多条要显示的消息。错误类型有3种：</p><ul><li><strong>SEND_ERROR</strong>：表示产生错误信息</li><li><strong>STATUS</strong>：表示一般的状态信息</li><li><strong>FATAL_ERROR</strong>：我们知道肯定是严重错误信息，cmake会立即停止执行参数个数：</li><li>一条消息显示指令后可以跟上多条消息，它们会依次连在一起进行显示我们修改一下前面的配置文件如下：</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(demo7)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"------------------------------"</span>  <span class="string">"this is "</span> <span class="string">"another message"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"------------------------------"</span>)</span><br><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">"the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"------------------------------"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"the BINARY dir is $&#123;demo7_BINARY_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"------------------------------"</span>)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">"the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"------------------------------"</span>)</span><br></pre></td></tr></table></figure></p><p>在每条消息前后我们用分割线分割开，构建后，可以看到消息显示如下：<img src="/2018/09/13/CMake入门/28.png" alt="这里写图片描述">第一个红框中的是前两条消息，其中第一条消息的多个消息是连续显示的；第二个红框中的是”SEND_ERROR”类型的错误消息，cmake会提示错误所在的行，然后项目会继续构建；最后一个红框中的是”FATAL_ERROR”类型的消息，cmake首先也输出了错误消息，然后便中止了构建过程。下面我们来关注一下这个配置文件中在message指令中使用的几个变量：</p><ul><li>${PROJECT_BINARY_DIR}</li><li>${PROJECT_SOURCE_DIR}</li><li>${demo6_BINARY_DIR}</li><li>${demo6_SOURCE_DIR}<strong>首先，&quot;project&quot;</strong> 指令在使用后会定义两个隐式的变量 <strong>&quot;PROJECT_BINARY_DIR&quot;</strong> 和 <strong>&quot;PROJECT_SOURCE_DIR&quot;</strong>。从输出的消息我们也可以看到，前者就是我们执行构建命令时所在的目录，也是我们的中间文件存放的目录；后者就是我们的配置文件和源文件所在的目录。<strong>同时</strong>，因为用 <strong>&quot;project&quot;</strong> 指令将项目名称指定为 <strong>&quot;demo7&quot;</strong> ，所以这两个变量中的”PROJECT”部分也可以中”demo7来代替。但是，不推荐用这种方式。<strong>另外</strong>，当我们使用内部构建时，这两个变量的值是一样的。<strong>最后</strong>，这两个值和我们使用cmake-gui时，要设置的两个目录是相对应的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java平台下Opencv图像展示的简便实现</title>
      <link href="/2018/08/12/Java%E5%B9%B3%E5%8F%B0%E4%B8%8BOpencv%E5%9B%BE%E5%83%8F%E5%B1%95%E7%A4%BA%E7%9A%84%E7%AE%80%E4%BE%BF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/12/Java%E5%B9%B3%E5%8F%B0%E4%B8%8BOpencv%E5%9B%BE%E5%83%8F%E5%B1%95%E7%A4%BA%E7%9A%84%E7%AE%80%E4%BE%BF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在C++环境下的OpenCV中，展示Mat图像可以通过imshow()实现。但在Java平台上该怎样简便地实现呢？</p><p>通常的做法是将读取到的Mat转化为BufferedImage，将BufferedImage作为GUI中的icon进行展示。下方是将Mat转化为BufferedImage的代码。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Mat转换成BufferedImage</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> matrix 要转换的Mat</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fileExtension 格式为 ".jpg", ".png", etc</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 转换后的BufferedImage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">Mat2BufferedImage</span> <span class="params">(Mat matrix, String fileExtension)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// convert the matrix into a matrix of bytes appropriate for this file extension</span></span><br><span class="line">       MatOfByte mob = <span class="keyword">new</span> MatOfByte();</span><br><span class="line">       Imgcodecs.imencode(fileExtension, matrix, mob);</span><br><span class="line">       <span class="comment">// convert the "matrix of bytes" into a byte array</span></span><br><span class="line">       <span class="keyword">byte</span>[] byteArray = mob.toArray();</span><br><span class="line">       BufferedImage bufImage = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           InputStream in = <span class="keyword">new</span> ByteArrayInputStream(byteArray);</span><br><span class="line">           bufImage = ImageIO.read(in);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> bufImage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里提供一种简单的方法，实现了类似C++的图像展示方式。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageUI</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageUI</span><span class="params">(Mat m, String window)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        init(m, window);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Elements for paint.</span></span><br><span class="line">    <span class="keyword">private</span> Mat mat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstPaint = <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">private</span> BufferedImage out;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> String WINDOW = <span class="string">""</span>; </span><br><span class="line">    <span class="keyword">private</span> JFrame jframe = <span class="keyword">new</span> JFrame();        </span><br><span class="line">    <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Mat2BufIm</span><span class="params">()</span></span>&#123;               </span><br><span class="line">        mat.get(<span class="number">0</span>, <span class="number">0</span>, data);</span><br><span class="line">        out.getRaster().setDataElements(<span class="number">0</span>, <span class="number">0</span>, mat.cols(), mat.rows(), data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Mat m,String window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mat = m;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">byte</span>[mat.cols() * mat.rows() * (<span class="keyword">int</span>)mat.elemSize()];</span><br><span class="line"></span><br><span class="line">        WINDOW = window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mat.channels() == <span class="number">1</span>)</span><br><span class="line">            type = BufferedImage.TYPE_BYTE_GRAY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            type = BufferedImage.TYPE_3BYTE_BGR;</span><br><span class="line">        out = <span class="keyword">new</span> BufferedImage(mat.cols(), mat.rows(), type);</span><br><span class="line">        Mat2BufIm();    </span><br><span class="line">        jframe.add(<span class="keyword">this</span>);  </span><br><span class="line">        jframe.setSize(mat.cols(), mat.rows());  </span><br><span class="line">        jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line">        jframe.setTitle(WINDOW);</span><br><span class="line">        jframe.addKeyListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;  </span><br><span class="line">            g.drawImage(out, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImageUI <span class="title">imshow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(firstPaint)&#123;</span><br><span class="line">            jframe.setVisible(<span class="keyword">true</span>); </span><br><span class="line">            firstPaint = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        Mat2BufIm();</span><br><span class="line">        <span class="keyword">this</span>.repaint();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Elements for waitKey.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object mt = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> lastKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">waitKey</span><span class="params">(<span class="keyword">int</span> millisecond)</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO 实现监听键盘</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(millisecond == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(mt)&#123;</span><br><span class="line">                    mt.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(millisecond);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key != lastKey)&#123;</span><br><span class="line">            ret = key;</span><br><span class="line">            lastKey = key;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mt)&#123;</span><br><span class="line">            mt.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = e.getKeyCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent arg0)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyTyped</span><span class="params">(KeyEvent arg0)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在项目中添加上面的源码后，可以通过以下方式实现图像的展示：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat mat = Mat.eye(<span class="number">1000</span>, <span class="number">2000</span>, CvType.CV_8UC3);</span><br><span class="line">String window_name = <span class="string">"mat"</span></span><br><span class="line">ImageUI ig = <span class="keyword">new</span> ImageGui(mat,window_name);</span><br><span class="line">ig.imshow();</span><br><span class="line">ig.waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>或者，可以通过另一种简单的方法实现：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat mat = Mat.eye(<span class="number">1000</span>, <span class="number">2000</span>, CvType.CV_8UC3);</span><br><span class="line"><span class="keyword">new</span> ImageGui(mat,<span class="string">"mat"</span>).imshow().waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java下OpenCV中Mat的初始化及赋值方法</title>
      <link href="/2018/08/08/Java%E4%B8%8BOpenCV%E4%B8%ADMat%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/08/Java%E4%B8%8BOpenCV%E4%B8%ADMat%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>利用函数构造特殊Mat</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = Mat.eye(<span class="number">3</span>,<span class="number">3</span>, CvType.CV_64FC1);</span><br><span class="line">A = Mat.zero(<span class="number">3</span>,<span class="number">3</span>,CvType.CV_64FC1);</span><br></pre></td></tr></table></figure></p><p>诸如MatOfDouble之类的矩阵，还支持将矩阵转换为List或者从List（array）转换成矩阵。所以可以直接这样创建矩阵：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MatOfDouble A = <span class="keyword">new</span> MatOfDouble(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p><p>或者</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MatOfDouble A = <span class="keyword">new</span> MatOfDouble();</span><br><span class="line">A.fromArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p><p>这样得到的矩阵实际上是一个列向量，也就是$9<em>1$的矩阵。如果想得到一个$3</em>3$的矩阵，可以使用reshape。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.reshape(<span class="number">1</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>注意这里第一个参数为通道数，第二个参数为行数</p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows远程桌面连接阿里云Ubuntu服务器</title>
      <link href="/2018/08/02/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/08/02/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本地Windows远程桌面连接阿里云Ubuntu 16.04服务器:</p><p>1、目的:希望通过本地的Windows远程桌面连接到阿里云的Ubuntu服务器,通过远程桌面图形界面的方式操作服务器。</p><p>2、条件:申请的阿里云Ubuntu服务器一台,本地Windows操作系统电脑一台。</p><p>3、如何远程桌面连接:</p><p>(1)首先通过Windows系统下连接Linux系统的命令行工具连接Ubuntu服务器,(工具:xshell,securecrt,putty等)。</p><p>(2)通过Windows下工具连接到linux操作系统,之后打开命令窗口,切换到root权限。</p><p>(3)先安装更新:apt-get upate。</p><p>(4)安装xrdp:输入apt-get install xrdp--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车,安装完成。</p><pre><code>   (xrdp: An open source remote desktop protocol(rdp) server)</code></pre><p>(5)安装vnc4server:输入apt-get install vnc4server&quot;--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车,安装完成。</p><pre><code>   (VNC (Virtual Network Console)是虚拟网络控制台的缩写)</code></pre><p>(6)安装xfce4:输入apt-get install xubuntu-desktop&quot;--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车。</p><blockquote><p>--&gt;输入echo &quot;xfce4-session&quot; &gt;~/.xsession--&gt;回车--&gt;输入 service xrdp restart--&gt;回车,安装完成。</p></blockquote><blockquote><p>(Xfce是一个自由软件,运行在类Unix操作系统 (如Linux、FreeBSD 和 Solaris)上,提供轻量级桌面环境。)</p></blockquote><p>(7)在本地Windows电脑上,使用&quot;窗口键+R&quot;打开&quot;运行对话框&quot;--&gt;输入&quot;mstsc&quot;--&gt;回车--&gt;输入Ubuntu主机的IP地址--&gt;&quot;连接&quot;。</p><p>(8)选择&quot;sesman-Xvnc&quot;--&gt;输入&quot;用户名和密码&quot;--&gt;回车,成功登录到Ubuntu桌面,现在可以进行远程操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
