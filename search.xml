<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学术论文中的英文表达]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E8%8B%B1%E6%96%87%E8%A1%A8%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[prioritize state-of-the-art twice as many number respectively pair wise Whereas infrastructure benchmark identical merit figure of merit in the stage of infancy representative application-agnostic fidelity crucial hurdle exploit Iterate through all the layers temporal spatial Figure-of-Merit that using cost function and heuristics based on the number of hops or Manhattan distance Revised in terms of overhead outperform analogous fidelity address these drawbacks mentioned above trade-off leveraging overhead mathematically equivalent unitary implies that accounts for dictates comprised of resultant metric：度量标准 leads to mitigate：缓和 cascade Algorithms exist that does：主语从句]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-21-论文阅读-量子计算-ISCA_2019_Kaitlin]]></title>
    <url>%2F2019%2F07%2F21%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ISCA-2019-Kaitlin%2F</url>
    <content type="text"><![CDATA[A Quantum Computational Compiler and Design Tool for Technology-Specifific Targets 前提知识酉矩阵一个矩阵的共轭转置和它的逆相等。 即： U^{H} U=U U^{H}=E_{n}其中，$U^{H}$为$U$的共轭转置，$E_n$为n阶单位矩阵。 不理解 Local optimizations based on removing partitions of gates that equal the identity function are implemented recursively until technology library cost function cannot be further reduced.（P6） single-target gate？ 关键词汇理解 technologically-independent：技术无关，即没有映射到实际量子计算机，不考虑量子计算机实际物理体系结构的 technology-dependent ：考虑量子计算机体系结构的 Quantum Multiple valued Decision Diagram (QMDD)，量子多值决策图 quantum information processing（QIP），量子信息处理 quantum operator=quantum gate connectivity tree reroute algorithm（CTR），连接树重新路由算法 switching functions，可逆的二进制转换函数，即量子电路 摘要为了充分利用量子计算机性能，编译器需要对细节做优化，将量子程序映射到实际结构上。现有的大多数技术并没有考虑量子计算机本身的特点。我们的方法基于实际架构的约束来执行。这个工具基于实际结构执行优化，具有高质量的架构相关的映射结果。并进行了数学方面的等价检查，使我们的映射结果与原有算法等价。 简介QC体系结构各不相同，需要特殊的技术使合成工具能够将广义量子线路映射到特定QC体系结构上。这个工具需要重新配置一个量子线路，让一个量子计算机上的可执行的量子线路映射到另一个设备上。该技术促进了量子逻辑自动转化工具的发展、硬件编译器的发展。技术利用形式等价性验证产生的物理映射结果和最初的逻辑线路是否相等。该技术也可以自动优化逻辑线路。 过去已经产生了可逆逻辑、考虑架构限制的网格模型量子结构、单双量子门。 此处讨论的特点是： 逻辑量子线路被映射到物理量子线路的体系结构上。 形式等价性检查，确认生成的最终电路在功能上与原始形式等价。 通过形式验证达到了高效的量子线路合成和映射。编译过程中，实现了量子多值决策图（QMDD），用于电路等价性检查。 原型工具实现了对原始量子线路图到实际量子计算机上的量子线路图的映射、优化和验证转换。文中以IBMQ系列量子计算机为例，是因为这些计算机提供了他们具体的架构，但本文工作也可以用于其他的架构，因此是模块化的。 第2节提供了量子逻辑，计算和操作的背景信息，并介绍了QMDD数据结构。 第3节描述了IBM量子机器和工具。 第4节概述了基于量子计算机物理体系结构的量子逻辑综合和编译的方法。第5节回顾了实验结果。第6节得出了当前研究的结论，并详述了量子合成和编译工具的未来发展和改进。 背景量子计算 叠加态和纠缠态在经过观测后消失 量子算子表示量子态的特定时间演化，从而有目的地转换量子位状态，从而产生有意义的QIP。如果将量子算法建模为一个电路，那么量子运算可以看作是量子逻辑门。 量子位多，退相干性高，superconducting solid-state qubits是目前效果最好的量子位实现手段。 量子费用 维持量子在计算中的稳定性是非常重要的 减少操作数是非常重要的 提出了量子位费用，其中T门为三比特位操作，额外成本设为0.5，C门额外成本为0.25，量子成本越高说明退相干可能性越大。 q_{c o s t}=0.5 \times t+0.25 \times c+a 可逆逻辑 可逆逻辑指的是理论上可以通过反向执行算法来恢复输入信息的实现 为了实现可逆性，要求输入和输出端口相同，输入输出有闲余端口用于维持可逆性。编译和优化工具的优化目标是：在维持可逆性的前提下，最小化闲余端口。 与QIP操作对应的状态转换被建模为酉转换，及具有可逆性。 希望可以实现用户输入不可逆算法，由工具转换为可逆。 存在将二进制切换函数变成可逆函数的算法，一旦转换了切换功能，就可以将它们转换成QIP电路或QC程序，以便在量子机器上进行评估。 所有的QIP和QC过程在逻辑和物理上都是可逆的，这是量子力学假设和公理的结果。 对应于QIP操作的状态变换是酉变换。 一种方法：对输入的以ESOP形式表达的转换函数进行转换，转换为可逆的Toffoli流的形式。占用时间短。 后来的一项工作，包含了ESOP的工作，使用决策图（DD，decision diagram）来进行表示。一个顺序二维决策图用一堆不相交的立方体表示了一个不可逆函数。 现有的量子合成工作使用诸如ESOP和DD表示之类的技术将经典规范转换为可逆逻辑[2,6]，但由于可逆逻辑在实际QC上是不可实现的，因此产生的输出与技术无关。 量子多值决策表 对于n个量子位的逻辑门需要的酉矩阵大小为$2^n\times 2^n$ QMDD可以用有向无环图表示量子逻辑门，类似空间八叉树。 量子多值决策表被用于等价性检测，因为对于初始量子线路和映射到物理量子线路上的量子程序，只要操作顺序不变，量子多值决策表是相同的。 IBM Q可以讲IBM Q系列表示为一个字典，键为CNOT的控制位，值列表为CNOT控制位对应的目标。 设计了一个称为“耦合复杂度”的度量，用于描述物理量子位的耦合复杂度。 将耦合复杂度定义为耦合映射中发现的允许CNOT耦合数量与量子机器的所有量子的二排列之比。越接近1，两个量子位互联的可能性更高。 ibmqx2 = {0:[1,2], 1:[2], 3:[2,4], 4:[2]} $complex=\frac{6}{C_5^2}=\frac{6}{20}=0.3$ 量子逻辑合成方法 最终量子程序要以量子汇编语言展示。 前端接受多种输入，包括经典的切换函数，前端都会对其进行处理。 前端的处理结果是一个与实际物理量子设备无关的可逆表示。 前端生成的可逆表示被后端的设计工具处理。 后端进行转化和优化，映射到一个具体的物理量子机器上。 后端可以进行多量子位门的分解，也进行了两量子位操作的优化。 多量子位操作在物理上难以实现，分解的方法是必要的。树的数据结构有助于为CNOT找到最短的SWAP路由。 CRT算法被用来自动路由不符合硬件条件的CNOT操作。基于耦和图的树结构决定了SWAP操作的最短路径。 SWAP操作继续移动控制量子位，直到可以在指定目标上执行所需的CNOT操作。 在执行CNOT操作之后，控制量子位反向遍历SWAP路径以返回其原始位置，以便保留电路中的原始量子位分配。 构建CRT 树时，只要两者之间有连接，即可构建CRT树枝，因为CNOT其实可以通过四个H门进行转向。 后端构建基于实际架构的QASM，主要符合两个方面：1.符合物理架构2.最小化量子代价 实现了以下的映射和优化过程：1.CNOT可翻转。2.CTR用于路由不直接连接的量子位。3.广义Toffoli门被分解为Toffoli流。4.将Toffoli操作分解为一个和两个量子位操作符。5.在不能进一步降低技术库成本函数之前，将递归地实现基于删除等同于标识函数的门的分区的本地优化。6.在不能进一步降低技术库成本函数之前，递归地实现基于移除逻辑上相同的电路标识可以最小化的门分区的局部优化。 所有的综合优化程序完成后，调用形式验证，使用QMDD进行等价测试。非常重要，因为验证了工具的转换和优化不会改变算法逻辑。 实验 负责映射和优化，用于合成和编译的后端工具使用Python完成。 工具的目的是使用经典的计算方法，而不是模拟量子算法，来合成依赖于技术的算法。 工具可以对IBM Q系列设备、和自己提出来的96qubits设备进行计算，可直接在个人电脑上进行计算。 benchmarks：Optimal Single-target Gates，大小为3-6。他们中药师因为他们被作为查表法的的重要部分 单目标门可以被分解为一个和两个量子位操作。作为独立于物理线路的.qc文件被输入到合成工具中。 映射到模拟器时，是和物理线路无关的。 模拟器的结果是一个技术独立的线路，考虑了T数和总门数，没有考虑多比特位操作要放在哪。 在没有被物理线路限制的情况下，基准线路的量子位和连接已经是最精简的了，经过基于费用的优化和映射，其门数和成本函数并不会减少。 不被物理结构支持的门需要被分解或重路由，具有低“耦合复杂度”的线路往往需要更多的门来实现技术相关的映射。 映射结束后，结果线路可能被内建的局部优化器优化。]]></content>
      <categories>
        <category>量子计算</category>
      </categories>
      <tags>
        <tag>论文总结</tag>
        <tag>量子计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读_量子计算_1809.02573v2]]></title>
    <url>%2F2019%2F07%2F19%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-1809-02573v2%2F</url>
    <content type="text"><![CDATA[Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices 问题不理解的名词 保留遍历搜索技术 全局优化初始映射 名词 quantum circuit：量子线路，是在抽象概念下，对量子信息存储单元进行操作的线路。组成包括：量子位、线路（时间线）、逻辑门。 Directed Acyclic Graph：DAG，有向非循环图 摘要由于对量子计算的硬件条件考虑不足，比如说没有考虑二量子位操作的物理连接不足的问题，一般的NISQ无法执行大多数的量子算法。动态重映射策略被创建，来解决这些问题。但是动态重映射策略不能保证程序的可靠性，策略复杂度高，初始映射差，可控性和灵活性低。 提出了一种基于交换的双向启发式搜索算法(SABRE)，适用于量子位任意连接的NISQ设备。通过优化每一次搜索尝试，采用新型的反向遍历技术，全局优化了初始映射。引入了了衰减效应，能够衡量搜索的深度和整个系统的门的个数。SABRE比其他的已知最好的指数级算法好一些。 介绍量子计算机虽然无法实现QEC，但是也可以干很多事情。软硬差距存在，现有的NISQ体系结构无法支持大型量子程序有效执行。本文章专注于由于NISQ设备限制而产生的二量子位操作问题。逻辑量子位分配到物理量子位上，类比传统计算机就是寄存器分配。 实际量子线路无法直接在NISQ上执行，因此需要进行量子电路转换，实现量子程序在NISQ设备上的使用，步骤有： 初始逻辑量子位到物理量子位的映射 映射变换，使要进行门运算的两个逻辑量子位重映射到两个相邻物理量子位上。 之前的方法有： 构建数学问题，采用求解器解决。缺点是求解速度慢，只能对小规模数据使用，不能利用问题内部特征。 启发式搜索算法，大多数是在理想的1D / 2D晶格模型上开发的，不适用于具有更多不规则和受限制的耦合连接的NISQ器件。 针对IBM QX的搜索算法，穷尽搜索，运行速度慢，缺少全局优化能力，在多目标优化条件下，无法保证生成的量子电路的质量。 本文提出了： 基于交换的双向启发式搜索算法，解决量子位映射问题。 穷尽搜索很多步骤是多余的，SABRE方法大量减少了搜索空间。 初始化映射极为重要，可以影响最终电路质量。采用创新的保留遍历搜索技术。通过遍历反向电路，可以产生高质量的初始映射。在这个过程中更重视电路开始的位置，不忽视电路其他部分。 引入衰减效应，可以使重叠的SWAP操作造成启发式代价函数值变高，因此更支持不重叠的SWAP操作。这种优化可以鼓励并行性，并且可以在电路深度和门数之间进行权衡，从而进一步生成不同的硬件兼容电路。 本文贡献在于： 对基于启发式搜索算法的量子位映射问题总结了目标和度量标准 提出了基于SWAP的搜索模式，比穷尽搜索模式优秀，允许向NISQ时代的可扩展性。 提出了反向遍历策略，利用量子位映射问题的内在可逆性，在初始映射解决方案中实现全局优化。 在启发式搜索策略中提出衰减代价函数，能产生适用于不同硬件的量子电路。 背景软件基础多种量子模型是数学等价的，量子电路模型是最流行的。 量子位 量子操作 量子线路 在NISQ时代的QC硬件实现量子计算的硬件方法有：超导量子电路、离子阱、量子点、中性原子等。目前最可靠的技术是超导量子电路。 文章中考虑硬件约束包括： 量子位生存时间 量子位操作错误率，因为量子门会导致错误，因此要尽可能缩减量子门的数目 量子位连接。 问题分析 SWAP操作解决不连通问题 其他方法解决不连通问题：基于先前的架构，不予考虑。 SWAP操作带来如下问题：操作指令数增加，导致总体错误率增加；电路层次增加，总执行时间增加，由decoherence导致的错误增加。由此要尽量减少SWAP操作个数。 构建问题找初始mapping、中间mapping的变换，最小化门操作个数，最小化量子线路层次。 目标和度量标准 灵活性：对以后的量子计算机也需适用 可靠性：要尽量减少门个数 并行性：减少量子线路层次，允许更多的操作 可扩展性：在不使用QEC的情况下，问题是不变的。使用了QEC，会将问题转化为另一个。 度量标准：门总数和量子线路深度。 找初始化映射和SWAP预处理 使用Floyd-Warshall算法计算距离矩阵 使用有向非循环图（DAG）表示在一个量子线路中的双量子比特位门的执行限制。单量子位的操作在这不予考虑，因为他们不涉及到其他量子位。 找到第一层：没有前驱节点，即入度为零的控制非门可以被放在第一层中。 临时初始映射生成：随机产生初始映射，作为启发式搜索的起始状态。 基于SWAP的启发式搜索算法1是一次遍历的搜索过程，从头到尾扫描，并插入SWAP操作，使得所有的CNOT都可以被执行。这个算法会被多次使用来更新优化初始映射。 拓扑排序方法 检查F是否为空，若是，则停止，若否，则初始化Execute gate list。 对于F中现在的所有的门，取出这个门涉及到的两个量子位，查看他们所在的物理量子位有没有连接，如果有，则加入Execute gate list，否则不加入。 如果Execute gate list不为空，则将里面的所有门从F中删除掉。接下来检查后继的门，对于后继门的两个量子位，如果如果F中没有任何门指向这两个量子位的其中一个，则把这个后继门添加到F中。回到2。 如果Execute gate list为空，则所有的F中的门在硬件中不能被执行。需要插入SWAP操作。 启发式搜索插入SWAP：初始化score。通过F和G找到SWAP的候选列表。对于F中的所有门的所有程序量子位，找到它对应的物理量子位，通过G找到和这个物理量子位相邻的其他物理量子位，根据映射找到这些物理量子位对应的程序量子位。原量子位和这些程序量子位可以被进行SWAP。加入到候选SWAP列表中。对于候选列表中的每一个候选SWAP，更新原映射，作为临时图，对其进行评分，选择评分最小的SWAP操作，并将原映射更新。回到1。 在这里每次启发式搜索只搜索一步SWAP，下一次可能还是处于EExecute gate list为空的状态，这样就需进行下一步的启发式搜索，如果不为空，则可以继续进行拓扑排序。 算法中： Front layer F：其中的门都可以在逻辑上被执行 Mapping $\pi$：表示了从逻辑量子位到物理量子位的映射 Distance Matrix D：表示了两点间最少的SWAP数 Circuit Dag：有向无环图，代表量子线路结构 Chip Coupling Graph G：无向图，代表任意两个物理量子位之间的连接 算法的优势： 不是去搜索一个映射，而是去搜索在F中的量子位的SWAP。 解释关键设计决策 只有F中的门涉及到的量子位元参与的SWAP才有意义。 F后紧邻的量子位的距离也加入启发式函数的考虑，但不考虑再后面的，因为执行过程中，mapping的变化可能会很大。 时间复杂度分析（暂不理解）时间复杂度上限可以通过最坏情况来估计，也就是每两个比特位门都需要单独满足。 满足一个比特位门的时间复杂度是满足在搜索空间中的潜在选项、最大可能搜索空间、二比特位最大数目的搜索步数的一次搜索的乘积。启发式代价函数的时间复杂度是O（N）。 搜索空间从可以从O(exp(N))降到O(N)（最坏情况下所有量子比特位都在首层）， 初始映射的反遍历Siraichi没有考虑时间因素，Zulehner只考虑了最初映射，没有全局考虑。 量子电路是可逆的，可以获取到一个量子电路的逆电路。如果知道了最终电路，我们就可以把最终电路作为初始电路，解决映射问题。如果一次执行完成，得到的结果映射，可以作为我们开始执行时的初始映射，这样能够提供更好的效果。 首先随机生成初始映射，进过原量子线路，获得最终映射。将最终映射通过反向量子线路，获得更新后的初始映射。更新后的初始映射就在以后被作为优秀的映射方案。 量子线路深度和门数的衡量 深度优先 门数少优先 衰减效果被应用，来尽可能选择不相交的SWAP操作。 启发式函数设计 H应该能代表SWAP的移动步数 能够帮助后期的SWAP采用更少的步数 能够鼓励并行操作，考虑线路深度和并行度的取舍。 设计： F中所有元素对之间的距离和（来自Distance Matrix） 扩展集中的距离和 swap是否被重复使用 H=\max \left(\operatorname{decay}\left(SWAP . q_{1}\right), \operatorname{decay}\left(SWAP . q_{2}\right)\right)\\ *\left\{\frac{1}{|F|} \sum_{g a t e \in F} D\left[\pi\left(g a t e \cdot q_{1}\right)\right]\left[\pi\left(g a t e . q_{2}\right)\right]\\ +W * \frac{1}{|E|} \sum_{g a t e \in E} D\left[\pi\left(g a t e . q_{1}\right)\right]\left[\pi\left(g a t e . q_{2}\right)\right] \right\}总结 物理量子位不能比程序量子位少 有限的物理连接]]></content>
      <categories>
        <category>量子计算</category>
      </categories>
      <tags>
        <tag>量子计算</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文总结_量子计算_ASPLOS_2019_1]]></title>
    <url>%2F2019%2F07%2F19%2F%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-ASPLOS-2019-1%2F</url>
    <content type="text"><![CDATA[存疑 baseline方法是如何使swap数最小的？ 为啥有一个图先高后低，为啥变化大的，它的PST提升的就高 关于量子计算的知识量子计算中，量子计算机是不可靠不稳定的。可能发生操作错误和保持性错误。操作错误分单比特位操作和双比特位操作。严重程度：双比特位操作错误&gt;单比特位操作错误&gt;保持性错误。 量子计算通过多次执行量子程序，记录每次的观测结果，根据大数定律，正确事件出现的次数与总试验次数的比值会趋近于该事件的概率。 简介传统噪声中尺度量子计算机（NISQ, Noisy Intermediate Scale Quantum computers），由于量子位太少（10x-100x），不能够采用QEC来执行错误检测和错误更正，因为QEC需要10-100个量子位来编码一个错误检测位。那么该如何有效提升量子计算机的可靠性呢？ 作者通过分析IBM-Q20的特征数据发现，量子位和量子位之间的连接的错误率是不完全一致的，是多变的。为了利用这一特性，作者提出了VQM和VQA，能使程序量子位被分配到更好的物理量子位上，能使swap操作更多地发生在更可靠的链接上。 基线策略VQM和VQA是在基线准则上进行改进所得到的策略。 基线策略采用SWAP次数作为价值参数。 前提假设：所有的SWAP操作代价相同 基线映射策略 初始化无权无向图 使用最短路算法，计算任意两点纠缠所需最少的swap次数 程序指令分为n层，不同层包含不同的指令，不同层之间可以并行执行。 遍历所有的层，对于每一层，都要找到从程序量子位到物理量子位的映射，这样每一层的CNOT就可以有足够的物理连接被执行了。 对于每两层中间，通过A*搜索算法，以成本函数和基于曼哈顿距离的启发函数，搜索最优的SWAP集合，能使第一层的程序量子位到物理量子位的映射转化到第二层程序量子位到物理量子位的映射。 存疑： 量子程序中的指令是什么样子的？ 分层是什么意思？分层依据的准则是什么？ 这里的分层，每一层的所包含的程序量子位都完全一样？否则第5步中无法通过SWAP方法来把第一层的映射改为第二层的映射。 VQM 可构造无向有权图，采用最短路算法，计算距离矩阵 对每一个物理量子位计算节点强度，节点强度等于节点上的所有连线的权值 将输入程序分层 每一层寻找映射，映射要优先选择介电强度高的节点 找到从第一层映射到第二层映射的最优swap集，依据标准是最短路矩阵，有最大跳数的限制 VQA 找一个具有k个节点的子图，子图应当具有最大的ANS，ANS是子图中所有节点的边权的和的加和。 在前t层中，通过计算CNOT数，计算每个量子位的量子位活动 映射程序量子位到物理量子位，优先映射量子位活动较高的程序量子位 运用基线策略，找到层$li$和层$l{i+1}$之间的映射]]></content>
      <categories>
        <category>量子计算</category>
      </categories>
      <tags>
        <tag>论文总结</tag>
        <tag>量子计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读_量子计算_ASPLOS_2019_1]]></title>
    <url>%2F2019%2F07%2F17%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB_%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97_ASPLOS_2019_1%2F</url>
    <content type="text"><![CDATA[论文原文 前提知识希尔伯特空间(Hilbert Space)希尔伯特空间是复向量内积空间。 内积空间是两个向量上的函数并返回一个标量的二元运算，它的结果是欧几里得空间的标准内积。 一个量子系统的态空间一般用有限维度的Hilbert空间来表述，即可以用来表述量子系统的各种可能的量子态。 量子两个基本状态叠加态量子叠加态就是一个量子能在同一时间处于两种不同属性0和1的状态，而对于经典物理中，一个粒子只能处于一种状态，如要么左旋，要么右旋。 纠缠态量子纠缠态，就是满足一定条件的情况下一个量子的行为将会影响到另一个量子的状态。即其中一个量子被操作改变而发生状态变化时，比如进行量子观测时，一个量子被观测为左旋。则另一个量子其状态立即发生相应的状态变化。而两个量子之间不存在一定相同或者相反的绝对规则。因此两个被纠缠的粒子可以是状态相同，也可以是状态相反。 Bloch 球面百度百科 对量子位元这样的二阶量子系统而言，其存在的可能状态 $ |\psi\rangle $可以由两个互相正交的基底以复数线性叠加所构成，这两个基底可以选用$|0\rangle,|1\rangle$为代表。在物理实作上,$|0\rangle,|1\rangle$代表了做投影式量子测量所会得到的唯二结果。 从任意纯态出发，有： |\psi\rangle=\alpha|0\rangle+\beta|1\rangle, \alpha, \beta \in \mathbb{C}, \quad|\alpha|^{2}+|\beta|^{2}=1可设： \alpha=\cos \theta e^{i \delta} \beta=\sin \theta e^{i(\delta+\phi)}有： |\psi\rangle=\cos \theta e^{i \delta}|0\rangle+\sin \theta e^{i(\delta+\phi)}|1\rangle= e^{i \delta}\left(\cos \theta|0\rangle+\sin \theta e^{i \phi}|1\rangle\right)$e^{i \delta}$称共同相位，可以省略。$e^{i \phi}$称相对相位。有： |\psi\rangle=\cos \theta|0\rangle+\sin \theta e^{i \phi}|1\rangle因$cos\theta$和$sin\theta$为长度，所以都为非负实数，可以确定： 0 \leq \theta \leq \frac{\pi}{2} \Rightarrow 0 \leq 2 \theta \leq \pi, \quad 0 \leq \phi]]></content>
      <categories>
        <category>量子计算</category>
      </categories>
      <tags>
        <tag>量子计算</tag>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法读书笔记]]></title>
    <url>%2F2019%2F07%2F07%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 资料统计学习方法读书笔记 代码实现 笔记 CH1：统计学习方法概论实现统计学习方法的步骤统计学习方法三要素：模型，策略，算法 得到一个有限的训练数据集合； 确定包含所有可能的模型的假设空间，即学习模型的集合； 确定模型选择的准则，即学习的策略； 实现求解最优模型的算法，即学习的算法； 通过学习方法选择最优的模型； 利用学习的最优模型对新数据进行预测或分析。 统计学习分类基本分类 监督学习：采用的数据集包含标签，如KNN 无监督学习：采用的数据集不包含标签，如k-means 半监督学习：监督学习与与无监督学习的结合 强化学习：通过接收环境对动作的奖励（反馈）获得学习信息并更新模型参数 按模型分类 概率模型：为生成模型 非概率模型：为判别模型 按算法分类 在线学习 批量学习 统计学习方法三要素模型在监督学习过程中，模型就是所要学习的条件概率分布或者决策函数。 假设空间$\cal F$ 输入空间$\cal X$ 输出空间$\cal Y$ 参数空间 决策函数 $\cal F\it =\{f_{\theta} Y=f_{\theta}(x), \theta \in \bf R \it ^n\}$ 变量 变量 $\bf R\it ^n$ 条件概率分布 $\cal F\it =\{P P_{\theta}(Y X),\theta\in \bf R \it ^n\}$ 随机变量 随机变量 $\bf R\it ^n$ 策略学习过程或选择最优的模型的过程所参照的准则。 损失函数与风险函数 损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 损失函数(loss function)或代价函数(cost function)损失函数定义为给定输入$X$的预测值$f(X)$和真实值$Y$之间的非负实值函数，记作$L(Y,f(X))$ 风险函数(risk function)或期望损失(expected loss)这个和模型的泛化误差的形式是一样的 R_{exp}(f)=E_p[L(Y, f(X))]=\int_{\mathcal X\times\mathcal Y}L(y,f(x))P(x,y)\, {\rm d}x{\rm d}y模型$f(X)$关于联合分布$P(X,Y)$的**平均意义下的**损失(**期望**损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是**期望**，以及**平均意义下的**。模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失(期望损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是期望，以及平均意义下的。 这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏，$P(x,y)$转换成$\frac {\nu(X=x, Y=y)}{N}$更容易直观理解。 经验风险(empirical risk)或经验损失(empirical loss)$R{emp}(f)=\frac{1}{N}\sum^{N}{i=1}L(y_i,f(x_i))$模型$f$关于训练样本集的平均损失根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险 结构风险(structural risk)$R{srm}(f)=\frac{1}{N}\sum{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$$J(f)$为模型复杂度, $\lambda \geqslant 0$是系数，用以权衡经验风险和模型复杂度。 常用损失函数损失函数数值越小，模型就越好 0-1损失 L(Y,f(X))=\begin{cases}1, Y \neq f(X) \\0, Y=f(X) \end{cases} 平方损失 L(Y,f(X))=(Y-f(X))^2 绝对损失 L(Y,f(X))=|Y-f(X)| 对数损失这里$P(Y|X)\leqslant 1$，对应的对数是负值，所以对数损失中包含一个负号。 L(Y,P(Y|X))=-\log P(Y|X)ERM与SRM经验风险最小化(Empirical Risk Minimization,ERM)与结构风险最小化(Structural Risk Minimization,SRM) 极大似然估计是经验风险最小化的一个例子当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计 贝叶斯估计中的最大后验概率估计是结构风险最小化的一个例子当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化等价于最大后验概率估计 算法这章里面简单提了一下，具体可以参考CH12表格中关于学习算法的描述。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo博客中使用数学公式]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解决方法一第一步： 安装Kramed12yarn remove hexo-renderer-markedyarn add hexo-renderer-kramed 第二步：更改文件配置打开/node_modules/hexo-renderer-kramed/lib/renderer.js，更改： 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed's rule: $$ + \1 + $$ return text.replace(/`\$(.*?)\$`/g, '$$$$$1$$$$');&#125; 为 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 第三步: 停止使用 hexo-math，并安装mathjax包12yarn remove hexo-mathyarn add hexo-renderer-mathjax 第四步: 更新 Mathjax 的 配置文件打开/node_modules/hexo-renderer-mathjax/mathjax.html 将&lt;script&gt;替换为： 1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt; 第五步: 更改默认转义规则打开/node_modules\kramed\lib\rules\inline.js 1. 1escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, 改为 1escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 2. 1em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 改为 1em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 第六步: 开启mathjax在config.yml文件 中开启 Mathjax 12mathjax: enable: true 解决方法二将这段代码放到 HTML 的 header 里，解决方案来自liam 123456789101112131415161718192021&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("code").map(function()&#123; match = /^\$(.*)\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; match = /^\$\$(.*)\$\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; match = /^\\begin/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; &#125;);&#125;);&lt;/script&gt; https://www.jianshu.com/p/7ab21c7f0674 https://www.jianshu.com/p/0c97df3a8491 https://blog.csdn.net/u014630987/article/details/78670258 https://liam.page/2015/09/09/fix-conflict-between-mathjax-and-markdown/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>latex</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SfM和SLAM项目总结]]></title>
    <url>%2F2019%2F06%2F28%2FSfM%E5%92%8CSLAM%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言：2019年6月27日，我进行了网易伏羲实验室虚拟人方向的电话面试。在电话中，我支支吾吾连自己的项目都讲不清楚。不管最后面试结果如何，自己做过的东西起码自己要懂。 基础知识内积 \bf{a} \cdot \bf{b}=\bf{a}^T\bf{b}=\sum_{i=1}^3a_ib_i=|\bf{a}||\bf{b}|cos外积 \bf{a} \times \bf{b} = \left[ \begin{array}{ccc} {\bf{i}} & {\bf{j}} & {\bf{k}}\\ {a_1} & {a_2} & {a_3}\\{b_1} & {b_2} & {b_3} \end{array} \right] = \left[ \begin{array}{c} {a_2b_3-a_3b_2}\\ {a_3b_1-a_1b_3}\\ {a_1b_2-a_2b_1} \end{array} \right] =\left[ \begin{array}{ccc} {0} & {-a_3} & {a_2}\\ {a_3} & {0} & {-a_1}\\ {-a_2} & {a_1} & {0} \end{array} \right] \bf{b} \triangleq \bf{a} ^\wedge \bf{b}相应的，有 \boldsymbol{a}=[a_1\boldsymbol{i},a_2\boldsymbol{j},a_3\boldsymbol{k}] \boldsymbol{a}^{\wedge}=\boldsymbol{A}=\left[\begin{matrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\\\end{matrix}\right] \boldsymbol{A}^{\vee}=\boldsymbol{a}特殊正交群 $SO(3)$ SO(3)=\{R\in\mathbb{R}^{3\times3}|RR^T=I,\det(R)=1\}（det为行列式） 特殊欧式群$SE(3)$ SE(3)=\{T=\left[ \begin{matrix} R&t\\ 0^T&1\\ \end{matrix} \right]\in\mathbb{R}^{4\times4}|R\in SO(3),t\in \mathbb{R}^3\}李代数$\mathfrak{so}(3)$在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{‘}R(t)^T$是一个反对称矩阵，那么就用一个$\phi(t)\in\mathbb{R}^3$与之对应。有： R(t)^{'}R(t)^T=\phi(t)^{\wedge}之后求解微分方程，可以得到： R(t)=exp(\phi^{\wedge}t)实际求解时利用到指数映射和对数映射。 双目系统 左右相机只有在 x 轴上有位移，因此 P 的像也只在 x 轴（对应图像的 u 轴）上有差异。 \frac{z-f}{z}=\frac{b-(u_{L}+u_{R})}{b}整理得: z=\frac{f b}{d}, \quad d=u_{L}-u_{R}对极几何 两帧图像$I{1},I{2}$，两个相机中心分别为 $O{1},O{2}$。$p{1},p{2}$为互相匹配的特征点。 极平面：连线$\overrightarrow{O{1} p{1}}$和连线$\overrightarrow{O{2} p{2}}$在三维空间中会相交于点 P。这时候点$O{1}, O{2}, P$三个点可以确定一个平面，该平面称极平面。 极点：$O{1} O{2}$连线与像平面$I{1},I{2}$的交点被称为极点。 基线：$O{1},O{2}$的连线。 极线：极平面与两个像平面$I{1},I{2}$之间的相交线$l{1},l{2}$。 用途：双目匹配中，给定左图一个点，能将右图中对应的点的搜索空间缩减到一条线。 条件：需要八个或八个以上的点对 推导：设在第一帧的坐标系下，P坐标为：$\boldsymbol{P}=[X, Y, Z]^{T}​$，两像素点 $p{1},p{2}​$ （齐次化坐标）的像素位置为： s_{1} \boldsymbol{p}_{1}=\boldsymbol{K} \boldsymbol{P}, \quad s_{2} \boldsymbol{p}_{2}=\boldsymbol{K}(\boldsymbol{R} \boldsymbol{P}+\boldsymbol{t})因为是齐次坐标，所以认为等式任意一边乘以非零常数，等式仍然成立。即： \boldsymbol{p}_{1}=\boldsymbol{K} \boldsymbol{P}, \quad \boldsymbol{p}_{2}=\boldsymbol{K}(\boldsymbol{R} \boldsymbol{P}+\boldsymbol{t})取$\boldsymbol{x}{1}, \boldsymbol{x}{2}$是两个像素点的归一化平面上的坐标： \boldsymbol{x}_{1}=\boldsymbol{K}^{-1} \boldsymbol{p}_{1}, \quad \boldsymbol{x}_{2}=\boldsymbol{K}^{-1} \boldsymbol{p}_{2}有： \boldsymbol{x}_{2}=\boldsymbol{R} \boldsymbol{x}_{1}+\boldsymbol{t}同时左乘$t^{\wedge}$，相当于同时与$t$做外积。 \boldsymbol{t}^{\wedge} \boldsymbol{x}_{2}=\boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}_{1}同时左乘$\boldsymbol{x}_{2}^{T}$ \boldsymbol{x}_{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{x}_{2}=\boldsymbol{x}_{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}_{1}因$t^{\wedge} x{2}$垂直于$\boldsymbol{x}{2}^{T}$或$t$，因此左侧为0。极线约束即： \boldsymbol{x}_{2}^{T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}_{1}=0将$\boldsymbol{x}{1}=\boldsymbol{K}^{-1} \boldsymbol{p}{1}, \quad \boldsymbol{x}{2}=\boldsymbol{K}^{-1} \boldsymbol{p}{2}$代回，可得极线约束的另一种形式： \boldsymbol{p}_{2}^{T} \boldsymbol{K}^{-T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{K}^{-1} \boldsymbol{p}_{1}=0意义： $O{1}, P, O{2}$三点共面，$\boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{x}{1}$表示极线，且极线一定通过$\boldsymbol{x}{2}$。 本质矩阵本质矩阵为： \boldsymbol{E}=\boldsymbol{t}^{\wedge} \boldsymbol{R}特点： 秩为2 仅依赖于外参 采用摄像机坐标系 基本矩阵基本矩阵为： \boldsymbol{F}=\boldsymbol{K}^{-T} \boldsymbol{E} \boldsymbol{K}^{-1}特点： 秩为2 仅依赖于外参和内参 采用像素坐标系 F是从左图到右图，有方向，从右图到左图就是F的转置 7个自由度。（$3\times3$矩阵本有9个自由度，因行列式值为零，相差常数因子，即$kF,k\neq 0$,也是基本矩阵，减去两个自由度。） 单应矩阵单应矩阵是齐次矩阵，有8个未知数，需要四个对应点。 张正友标定法A Flexible New Technique for Camera Calibration 摘要：张正友标定法只需要相机观察几个（至少两个）不同方向上显示的平面图案。相机或平面图案都可以自由移动。且相机或标定板的运动不需要知道。张正友标定法对径向透镜畸变进行了建模。该方法由一个封闭形式的解组成，然后根据最大似然准则进行非线性改进。 数学推导针孔相机模型三维点到二维点投影矩阵 符号 含义 $m=[u,v]^T$ 二维点 $M=[X,Y,Z]^T$ 三维点 $\widetilde{m}=[u,v,1]^T$ 二维点齐次坐标 $\widetilde{M}=[X,Y,Z,1]^T$ 三维点齐次坐标 s 随机尺度因子 $\bf{(R,t)}$ 外参，即将世界坐标系和相机坐标系联系起来的旋转矩阵和位移向量 $\bf{A}$ 相机内参矩阵 $\alpha,\beta$ 分别为图像u轴和v轴的尺度因子 $u_0,v_0$ 光心的图像坐标系坐标 $\gamma$ 描述图像轴u,v之间的倾斜 s \widetilde{\bf{m}} = \bf{A[R\quad t]\widetilde{M}}其中， A = \left[ \begin{array}{ccc} {\alpha} & {\gamma} & {u_0}\\ {0} & {\beta} & {v_0}\\ {0} & {0} & {1}\end{array}\right]标定板平面与图像之间的单应性矩阵这里假设标定板所在的平面为空间坐标系下的$Z=0$。 符号 含义 $\bf{r_i}$ 旋转矩阵$\bf{R}$的第i列 s\left[\begin{array}{c}{u}\\{v}\\{1}\end{array}\right]=\bf{A}[\begin{array}{cccc}{\bf{r_1}}&{\bf{r_2}}&{\bf{r_3}}&{\bf{t}}\end{array}]\left[\begin{array}{c}{X}\\{Y}\\{0}\\{1}\end{array}\right]=A[\begin{array}{ccc}{\bf{r_1}}&{\bf{r_2}}&{\bf{t}}\end{array}]\left[\begin{array}{c}{X}\\{Y}\\{1}\end{array}\right]即： s\widetilde{\bf{m}}=\bf{H\widetilde{M}}其中，$\bf{H}$为单应矩阵，$\bf{H=A[\begin{array}{ccc}{\bf{r_1}}&amp;{\bf{r_2}}&amp;{\bf{t}}\end{array}]}$。 内参约束假设$\bf{H}=\left[\begin{array}{ccc}{\bf{h_1}}&amp;{\bf{h_2}}&amp;{\bf{h_3}}\end{array}\right]$，根据单应关系有： \left[\begin{array}{ccc}{\bf{h_1}}&{\bf{h_2}}&{\bf{h_3}}\end{array}\right]=\lambda \bf{A}[\begin{array}{ccc}{\bf{r_1}}&{\bf{r_2}}&{\bf{t}}\end{array}]可推出 \mathbf{r}_{1}=\lambda \mathbf{A}^{-1} \mathbf{h}_{1} \mathbf{r}_{2}=\lambda \mathbf{A}^{-1} \mathbf{h}_{2} \mathbf{r}_{3}=\mathbf{r}_{1} \times \mathbf{r}_{2} \mathbf{t}=\lambda \mathbf{A}^{-1} \mathbf{h}_{3} \lambda=\frac{1}{\left\|\mathbf{A}^{-1} \mathbf{h}_{1}\right\|}=\frac{1}{\left\|\mathbf{A}^{-1} \mathbf{h}_{2}\right\|}根据$\bf{r_1}$和$\bf{r_2}$正交，根据 正交 模相等 有： h_1^TA^{-T}A^{-1}h_2=0 h_1^TA^{-T}A^{-1}h_1= h_2^TA^{-T}A^{-1}h_2几何解释需要大于等于三张图像才能确定唯一解。 SfM三角化设 $x_1 ,x_2$ 为两个特征点的归一化坐标，那么它们满足： s_{1} \boldsymbol{x}_{1}=s_{2} \boldsymbol{R} \boldsymbol{x}_{2}+\boldsymbol{t}现在我们已经知道了$\boldsymbol{R}, \boldsymbol{t}$，想要求解的是两个特征点的深度 $s{1}, s{2}$。 可以左侧使用$x_1$进行叉乘，使左侧为0，即可求得$s_2$： s_{1} \boldsymbol{x}_{1}^{\wedge} \boldsymbol{x}_{1}=0=s_{2} \boldsymbol{x}_{1}^{\wedge} \boldsymbol{R} \boldsymbol{x}_{2}+\boldsymbol{x}_{1}^{\wedge} \boldsymbol{t}求$s_1$时同理。 PnP求解 3D 到 2D 点对运动的问题。特征点的 3D 位置可以由三角化，或者由 RGB-D 相机的深度图确定。在单目视觉里程计中，必须先进行初始化，然后才能使用 PnP。 SLAMORB_SLAM流程 System类生成一个对象slam，初始化slam对象，设置三个线程：Tracking ，LocalMapping ，LoopClosing 订阅 GrabImage() ——&gt; TrackMonocular()——&gt;GrabImageMonocular()——&gt;Track() 三个线程作用Tracking： Extract ORB，提取关键点和描述子 Initialize pose：在Track() 中初始化位姿 pose ， 第一帧 ：mInitialFrame 当前帧：mCurrentFrame ，从这两帧得到 （R，t）。并且，这两帧转为KeyFrame，凡是关键帧KeyFrame都要插入地图 mpMap（mpMap-&gt;AddMapPoint(pMP);），根据关键帧与当前帧公共3D点的个数 更新关键帧间的连接关系。 MapPoint类表示 路标点，Map类用Hash表管理 路标点和关键帧。 track local map： 更新局部地图，包括局部关键帧和关键点 对局部MapPoints进行投影匹配 根据匹配对估计当前帧的姿态 根据姿态剔除误匹配 keyFrame decision Local Mapping:LocalMapping线程处理的关键帧都是Tracking线程发过来的 插入关键帧， 去除冗余的MapPoints； Local BA； 去除冗余的关键帧 : 检测并剔除当前帧相邻的关键帧中和关键帧，剔除的标准是：该关键帧的90%的MapPoints可以被其它关键帧观测到。将当前帧加入到闭环检测队列中。 Loop Closing 回环检测Loop decision：计算闭环候选帧，在候选帧中检测具有连续性的候选帧； 计算相似变换阵sim3，求 [ sR | t ]； Loop Correction： A. 通过求解的Sim3以及相对姿态关系，调整与当前帧相连的关键帧位姿以及这些关键帧观测到的MapPoints的位置；B. 将闭环帧以及 与闭环帧相连的关键帧的MapPoints和与当前帧相连的关键帧的点进行匹配；C. 通过MapPoints的匹配关系更新这些帧之间的连接关系，即更新covisibility graphD. 对Essential Graph（Pose Graph）进行优化，MapPoints的位置则根据优化后的位姿做相对应的调整E. 创建线程进行全局Bundle Adjustment main-&gt;构造SLAM对象，在构造函数中设置线程。 读取图像，循环调用trackMonocular，在其中先检查状态是否改变，再调用 1GrabImageMonocular 构造了CurrentFrame，最后进行Track]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>机器视觉</tag>
        <tag>单目</tag>
        <tag>SfM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀和、差分、线段树与树状数组]]></title>
    <url>%2F2019%2F06%2F08%2F%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组 时间复杂度：O（n） 适用于：单点更新，区间查询 理解 C[1] = C[0001] = A[1];C[2] = C[0010] = A[1]+A[2];C[3] = C[0011] = A[3];C[4] = C[0100] = A[1]+A[2]+A[3]+A[4];C[5] = C[0101] = A[5];C[6] = C[0110] = A[5]+A[6];C[7] = C[0111] = A[7];C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 即： $C[i]=A[i-2^k+1]+A[i-2^k+2]+\dots+A[i];$ $k$为 $i$ 的二进制中从最低位到高位连续零的长度。 $2^k$可通过$i\&amp;-i$获得。 补码为原码取反后加1，如果将补码+1进位，那么最末尾的1和原码最右边的1一定是同一个位置 lowbit123inline int lowbit(x)&#123; return x&amp;(-x);&#125; 单点更新12345678910void update(int *arr,int index,int diff,int len)&#123; /* * arr：树状数组 * index：待更新的位置 * diff：改变的值 * len：树状数组长度 */ for(int i=index;i&lt;=len;i+=lowbit(i)) arr[i] += diff;&#125; 区间查询12345678910int getsum(int *arr,int x)&#123; /* * arr：树状数组 * x：求从1到x的和 */ int ans = 0; for(int i=x;i;i-=lowbit(i)) ans += arr[i]; return ans;&#125; 样例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;int lowbit(const int t) &#123; return t &amp; (-t);&#125;void insert(int t, int d) &#123; while (t &lt;= n)&#123; a[t] += d; t = t + lowbit(t); &#125;&#125;int getSum(int t) &#123; int sum = 0; while (t &gt; 0)&#123; sum += a[t]; t = t - lowbit(t); &#125; return sum;&#125;int main() &#123; int t, k, d; scanf("%d", &amp;t); k= 1; while (t--)&#123; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;d); insert(i, d); &#125; string str; printf("Case %d:\n", k++); while (cin &gt;&gt; str) &#123; if (str == "End") break; int x, y; scanf("%d %d", &amp;x, &amp;y); if (str == "Query") printf("%lld\n", getSum(y) - getSum(x - 1)); else if (str == "Add") insert(x, y); else if (str == "Sub") insert(x, -y); &#125; &#125; return 0;&#125; 线段树模板一、RMQ，查询区间最值下标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt; using namespace std; #define MAXN 100 #define MAXIND 256 //线段树节点个数 //构建线段树,目的:得到M数组. void build(int node, int b, int e, int M[], int A[]) &#123; if (b == e) M[node] = b; //只有一个元素,只有一个下标 else &#123; build(2 * node, b, (b + e) / 2, M, A); build(2 * node + 1, (b + e) / 2 + 1, e, M, A); if (A[M[2 * node]] &lt;= A[M[2 * node + 1]]) M[node] = M[2 * node]; else M[node] = M[2 * node + 1]; &#125; &#125; //找出区间 [i, j] 上的最小值的索引 int query(int node, int b, int e, int M[], int A[], int i, int j) &#123; int p1, p2; //查询区间和要求的区间没有交集 if (i &gt; e || j &lt; b) return -1; if (b &gt;= i &amp;&amp; e &lt;= j) return M[node]; p1 = query(2 * node, b, (b + e) / 2, M, A, i, j); p2 = query(2 * node + 1, (b + e) / 2 + 1, e, M, A, i, j); //return the position where the overall //minimum is if (p1 == -1) return M[node] = p2; if (p2 == -1) return M[node] = p1; if (A[p1] &lt;= A[p2]) return M[node] = p1; return M[node] = p2; &#125; int main() &#123; int M[MAXIND]; //下标1起才有意义,否则不是二叉树,保存下标编号节点对应区间最小值的下标. memset(M,-1,sizeof(M)); int a[]=&#123;3,4,5,7,2,1,0,3,4,5&#125;; build(1, 0, sizeof(a)/sizeof(a[0])-1, M, a); cout&lt;&lt;query(1, 0, sizeof(a)/sizeof(a[0])-1, M, a, 0, 5)&lt;&lt;endl; return 0; &#125; 模板二、连续区间修改或者单节点更新的动态查询问题 （此模板查询区间和）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; #define lson l , m , rt &lt;&lt; 1 #define rson m + 1 , r , rt &lt;&lt; 1 | 1 #define root 1 , N , 1 #define LL long long const int maxn = 111111; LL add[maxn&lt;&lt;2]; LL sum[maxn&lt;&lt;2]; void PushUp(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void PushDown(int rt,int m) &#123; if (add[rt]) &#123; add[rt&lt;&lt;1] += add[rt]; add[rt&lt;&lt;1|1] += add[rt]; sum[rt&lt;&lt;1] += add[rt] * (m - (m &gt;&gt; 1)); sum[rt&lt;&lt;1|1] += add[rt] * (m &gt;&gt; 1); add[rt] = 0; &#125; &#125; void build(int l,int r,int rt) &#123; add[rt] = 0; if (l == r) &#123; scanf("%lld",&amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt); &#125; void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; add[rt] += c; sum[rt] += (LL)c * (r - l + 1); return ; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (m &lt; R) update(L , R , c , rson); PushUp(rt); &#125; LL query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; LL ret = 0; if (L &lt;= m) ret += query(L , R , lson); if (m &lt; R) ret += query(L , R , rson); return ret; &#125; int main() &#123; int N , Q; scanf("%d%d",&amp;N,&amp;Q); build(root); while (Q --) &#123; char op[2]; int a , b , c; scanf("%s",op); if (op[0] == 'Q') &#123; scanf("%d%d",&amp;a,&amp;b); printf("%lld\n",query(a , b ,root)); &#125; else &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); update(a , b , c , root); &#125; &#125; return 0; &#125; 前缀和一维前缀和有数组A，数组A对应的前缀和数组为S，有： S[k]=\sum_{i=0}^{k}A[i]由此方便了范围查询： \sum_{i=L}^RA[i]=S[R]-S[L-1]二维前缀和对于二维数组A，数组A对应的前缀和数组为S，有： S[i][j]=\sum_{m=0}^i\sum_{n=0}^jA[i][j]计算时二维前缀和时，可以使用递推公式： S[i][j]=A[i][j]+S[i-1][j]+S[i][j-1]-S[i-1][j-1]当求被点$(x_1,y_1)$和点$(x_2,y_2)$围起来的元素的和时，可以使用： \sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}A[i][j]=S[x_2][y_2]-S[x_1-1][y2]-S[x_2][y_1-1]+S[x_1-1][y_1-1]差分差分可解决范围更新的问题。 思想： 延后更新 更新的起点和终点 利用前缀和 样例： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+9;int a[maxn],b[maxn];int main()&#123; int i,j,k,n,m,p; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=1;i&lt;=m;i++)&#123; int L,R,t; cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p; if(t==1)&#123; b[L]+=p;b[R+1]-=p; &#125; else&#123; b[L]-=p;b[R+1]+=p; &#125; &#125; int add=0; for(i=1;i&lt;=n;i++)&#123; add+=b[i]; a[i]+=a[i-1]+add; &#125; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配算法Sunday]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95Sunday%2F</url>
    <content type="text"><![CDATA[Sunday算法在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1； 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。 偏移表在预处理中，计算偏移表。 shift[w] = \begin{cases} m - max\{i < m | P[i] = w\} & \mbox{ if } w \mbox{ is in } P[0..m-1] \\ m + 1 & \mbox{ otherwise } \end{cases}C++实现12345678910111213141516171819202122232425const int charnum = 1005;int shift[charnum];int Sunday(const string&amp; T, const string&amp; P) &#123; int n = T.length(); int m = P.length(); for(int i = 0; i &lt; charnum; i++) &#123; shift[i] = m + 1; &#125; for(int i = 0; i &lt; m; i++) &#123; shift[P[i]] = m - i; &#125; int s = 0; int j; while(s &lt;= n - m) &#123; j = 0; while(T[s + j] == P[j]) &#123; j++; if(j &gt;= m) &#123; return s; &#125; &#125; s += shift[T[s + m]]; &#125; return -1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLAM之单目视觉里程计]]></title>
    <url>%2F2019%2F05%2F12%2FSLAM%E4%B9%8B%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[SLAM之单目视觉里程计基础知识旋转矩阵和位移矩阵建议参考计算机图形学教材，学习“图形变换”章节。重点掌握以下概念： 旋转矩阵 平移向量 齐次坐标 变换矩阵（旋转矩阵与平移向量的结合） 参考： 旋转变换（一）旋转矩阵 旋转矩阵、欧拉角、四元数理论及其转换关系 三个坐标系图像坐标系： 一般来说，图像坐标系包括像素坐标系以及物理坐标系。 对于图像直角坐标系上的坐标$(u,v)$，分别能从像素的行数和列数得到，叫做像素坐标系。为表示像素点在图像中的位置我们需要借助物理坐标系，以图像中某一点$O{1}$当作原点建立坐标系，其中$x$轴，$y$轴分别与像素坐标系的横、竖轴平行，方向一致。其中$(x, y)$坐标单位为毫米，$O{1}$在$(u, v)$坐标系下的坐标为$\left(u{0}, v{0}\right)$，$d_{x}$和$d_y$表示每个像素点在$x$,$y$轴上的尺寸大小，则有： \left\{\begin{array}{l}{u=\frac{x}{d x}+u_{0}} \\ {v=\frac{y}{d y}+v_{0}}\end{array}\right.即： \left[ \begin{array}{c}{u} \\ {v} \\ {1}\end{array}\right]=\left[ \begin{array}{ccc}{\frac{1}{d x}} & {0} & {u_{0}} \\ {0} & {\frac{1}{d y}} & {v_{0}} \\ {0} & {0} & {1}\end{array}\right] \left[ \begin{array}{l}{x} \\ {y} \\ {1}\end{array}\right]相机坐标系：相机坐标系原点位于光心。如图所示，相机光心为点$O$，$Z{c}$与像平面垂直，为相机的光轴，$X{c}, Y{c}$分别与$x,y$轴相平行，焦距大小为线段$O O{1}$的长度，则将$O-X{c} Y{c} Z_{c}$坐标系称作相机坐标系。 世界坐标系:世界坐标系可以对场景的中的任何物体进行描述，同时能表示出相机坐标。如上图中，将坐标系$O{w}-X{w} Y{w} Z{w}$称为世界坐标系，其与相机坐标系的相互变换可以通过$3 \times 1$的平移向量$t$以及$3\times 3$的旋转矩阵$R$来表示，设点$P$在世界坐标系中的齐次坐标为$\left(X{w}, Y{w}, Z{w}, 1\right)^{T}$，在相机坐标系中的齐次坐标为$\left(X{c}, Y{c}, Z{c}, 1\right)^{T}$，那么二者的转换关系为： \left[ \begin{array}{c}{X_{c}} \\ {Y_{c}} \\ {Z_{c}} \\ {1}\end{array}\right]=\left[ \begin{array}{cc}{R} & {t} \\ {0^{T}} & {1}\end{array}\right] \left[ \begin{array}{c}{X_{w}} \\ {Y_{w}} \\ {Z_{w}} \\ {1}\end{array}\right]=M_{1} \left[ \begin{array}{c}{X_{w}} \\ {Y_{w}} \\ {Z_{w}} \\ {1}\end{array}\right]针孔相机模型针孔相机模型是将空间坐标映射到图像点的模型。 请阅读: 视觉SLAM十四讲 5.1.1 对于使用的数据集，一般会提供拍摄照片所用的相机的内参和畸变系数。如果使用自己的相机，则需要采用张正友标定法进行相机标定，以获取相机内参及畸变系数。 最终有： Z \boldsymbol{P}_{u v}=Z \left[ \begin{array}{c}{u} \\ {v} \\ {1}\end{array}\right]=\boldsymbol{K}\left(\boldsymbol{R} \boldsymbol{P}_{w}+\boldsymbol{t}\right)=\boldsymbol{K} T \boldsymbol{P}_{w}其中$Z$为空间点三维坐标中的$Z$坐标值，$P_{uv}$代表空间点投影到像平面，在像平面上的坐标，$K$为相机内参，$R$为相机外参中的旋转矩阵，$t$为相机外参中的位移向量，$P_w$为空间点在世界坐标系下的三维坐标。其中： K=\left( \begin{array}{ccc}{f_{x}} & {0} & {c_{x}} \\ {0} & {f_{y}} & {c_{y}} \\ {0} & {0} & {1}\end{array}\right)单目视觉里程计单目视觉里程计主要需要了解对极约束、三角化和PnP。 对极约束 对极约束用于通过二维点之间的匹配关系，求解相邻两张图像之间的运动。关于对极约束的内容，请阅读视觉SLAM十四讲7.3，7.4。 使用对极约束求解本质矩阵可以通过调用opencv中的findEssentialMat函数完成。 12345678910111213//函数原型Mat findEssentialMat( InputArray points1, InputArray points2, InputArray cameraMatrix, int method = RANSAC, double prob = 0.999, double threshold = 1.0, OutputArray mask = noArray());//示例调用using namespace cv;Mat E = findEssentialMat(p1, p2, M); 其中： points1与points2是vector类型，两vector的size相同，对应位置上的Point2f互相匹配。 cameraMatrix是相机内参矩阵 method是计算方法，RANSAC是openCV中被define的常量，表示采用RANSAC方法进行本征矩阵计算 prob是估计矩阵正确的可信度 参数threshold用于RANSAC的参数。 它是从点到极线的最大距离（以像素为单位），超出此点时，该点被视为异常值，不用于计算最终的基本矩阵。 根据点定位精度，图像分辨率和图像噪声的不同，可将其设置为1-3。 参数mask输出N个元素的数组，其中每个元素对于异常值设置为0，对其他点设置为1。 求解出本征矩阵E后，调用recoverPose求解旋转矩阵和位移向量。 1234567891011//函数原型int recoverPose(Mat E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, OutputArray mask = noArray()); //示例调用using namespace cv;int pass_count = recoverPose(E,p1, p2, M, R, t,mask); 其中： E是经过findEssentialMat求解出的本征矩阵 points1，points2，cameraMatrix，mask与findEssentialMat函数中的意义相同 R是求解出的旋转矩阵 t是求解出的位移向量 R和t组成变换矩阵T，这里的T是是第一张图到第二张图的坐标变换矩阵。或者可以理解为第一张图相机相对于相机初始位置的变换矩阵是X。因为第一张图相机所处的位置是初始位置，所以有：$X = eye(4)$，其中$eye(4)$是四阶单位矩阵。那么T左乘X是第二个图的相机的坐标变换矩阵。 对极约束可以求解出两张图像之间的相机变换矩阵，但是它是2D和2D之间求解的变换矩阵，t的尺度无法确定，t可能是1米，可能是1cm。 三角化 1234567891011121314151617181920212223242526272829void reconstruct(Mat&amp; K, Mat&amp; R1, Mat&amp; T1, Mat&amp; R2, Mat&amp; T2, vector&lt;Point2f&gt;&amp; p1, vector&lt;Point2f&gt;&amp; p2, vector&lt;Point3f&gt;&amp; structure)&#123; //两个相机的投影矩阵[R T]，triangulatePoints只支持float型 Mat proj1(3, 4, CV_32FC1); Mat proj2(3, 4, CV_32FC1); R1.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_32FC1); T1.convertTo(proj1.col(3), CV_32FC1); R2.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_32FC1); T2.convertTo(proj2.col(3), CV_32FC1); Mat fK; K.convertTo(fK, CV_32FC1); proj1 = fK*proj1; proj2 = fK*proj2; //三角重建 Mat s; triangulatePoints(proj1, proj2, p1, p2, s); structure.clear(); structure.reserve(s.cols); for (int i = 0; i &lt; s.cols; ++i) &#123; Mat_&lt;float&gt; col = s.col(i); col /= col(3); //齐次坐标，需要除以最后一个元素才是真正的坐标值 structure.push_back(Point3f(col(0), col(1), col(2))); &#125;&#125; 三角化在得到两个相机的旋转矩阵、位移向量后，可以根据匹配的特征点进行三角化，最终能够求得特征点对应的空间点云的坐标。 PnP PnP在得知了对应的空间点的三维坐标和新加入的图像中的特征点的二维坐标之后，可以求解新加入的图像的相机的旋转矩阵和位移向量。 参考opencv中solvePnPRansac函数求解相机位姿 12345678910//函数原型bool solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray dist， OutputArray rvec, OutputArray tvec, ...);//调用示例solvePnPRansac(object_points, image_points, K, noArray(), r, T); 其中： objectPoints为三维坐标，imagePoints为二维坐标，对应位置的坐标互相匹配。 cameraMatrix为相机内参。 dist为畸变参数矩阵。 rvec为求解出的相机旋转向量，不是旋转矩阵。可经过罗德里格斯变换获取旋转矩阵。 1Rodrigues(r, R); tvec为求解出的相机位移向量。 这里的objectPoints为原有空间点云三维坐标。imagePoints为新加入的一张图像中的特征点的图像坐标。假设刚开始运行程序时候，点云$C_{12}$由前两张图像的相机的旋转矩阵、位移向量和匹配的特征点经过三角化求解出来。 上述过程涉及到的前两张图像中第一张图像的相机旋转矩阵为三阶单位矩阵，位移向量为0，即第一张图像的相机处于起始位置；第二张图像的旋转矩阵和位移向量通过对极几何被求解出来。 进行求解PnP需要构建已有空间点云三维坐标和新加入图像中的特征点二维坐标的匹配关系。那么这个关系是怎么建立的呢？是在图一、图二进行三角化生成空间点云时候，会生成空间点云中点与图二中特征点的匹配关系。图二与图三进行匹配，可获得图二与图三中特征点的匹配关系。由此可获得图三中特征点与原有空间点云中点的匹配关系。 程序经过一次PnP，求解出第三张图像的相机的旋转矩阵和位移矩阵后，可以使用第三张图像的相机的旋转矩阵和位移向量与第二张图像的旋转矩阵和位移向量进行三角化，生成第二张图像和第三张图像共同构建的空间点云$C_{23}$。 之后，空间点云可以进行点的添加和旧点的消除，每次新加入的一张图像的相机位姿可以通过PnP求解出来。 参考资料【1】《视觉SLAM十四讲》 —— 高翔 【2】 葛均强. 基于无人机航拍图像序列的三维重建研究与实现[D]. 电子科技大学,2015. 【3】线性代数的本质——3blue1brown]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>机器视觉</tag>
        <tag>单目</tag>
        <tag>视觉里程计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OJ技巧]]></title>
    <url>%2F2019%2F05%2F10%2FOJ%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[OJ中的奇技淫巧使用异或进行swap12345void swap(int&amp; a,int&amp; b)&#123; a=a^b; b=a^b; a=a^b;&#125; 单行多字符串处理123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); stringstream ss; ss&lt;&lt;s; while(ss&gt;&gt;s)&#123; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 加快cin速度1std::ios::sync_with_stdio(false); while和scanf12345678910//读到文件的结尾，程序自动结束while( ( scanf( " %d " ,&amp;a) ) != -1 )while( ( scanf( " %d " ,&amp;a) ) != EOF)while( ( scanf( " %d " ,&amp;a) ) == 1 )while( ~( scanf( " %d " ,&amp;a) ) )//读到一个 0 时，程序结束while( scanf( " %d " ,&amp;a) ,a)//读到多个0时，程序结束while( scanf( " %d%d%d " ,&amp;a,&amp;b,&amp;c),a+b+c ) //a,b,c非负while( scanf( " %d%d%d " ,&amp;a,&amp;b,&amp;c),a|b|c ) vector定义二维数组12int len=100;vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len,0));]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs229]]></title>
    <url>%2F2019%2F05%2F10%2Fcs229%2F</url>
    <content type="text"><![CDATA[CS229 课程讲义 CSDN博主中文翻译]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro装机配置]]></title>
    <url>%2F2019%2F05%2F09%2Fmanjaro%E8%A3%85%E6%9C%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置镜像源:1sudo pacman-mirrors -i -c China -m rank 打开配置文件sudo nano /etc/pacman.conf在文件末尾添加123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 导入GPG Key12sudo pacman -Syysudo pacman -S archlinuxcn-keyring 安装软件123sudo pacman -S vim cmake firefox-i18n-zh-cn gdb nodejs fcitx-im fcitx-configtool fcitx-sogoupinyin yarn visual-studio-code-bin texmaker sudo pacman -S google-chrome deepin.com.qq.office netease-cloud-music typora vlc wewechat wps-office ttf-wps-fontssudo pacman -S mysql eclipse-jee opencv webstorm clion pycharm-professional intellij-idea-ultimate-edition qtcreator qt4 maven android-studio nginx 配置搜狗环境1sudo vim ~/.xprofile 添加以下内容 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx" 配置firefox地址栏输入about:config 搜索intl.locale.requested 将其值修改为zh_CN 配置yarn123yarn global binsudo vim /etc/profile appendpath &apos;/home/douxl/.yarn/bin&apos; 禁用pcspkr12sudo rmmod pcspkrsudo vim /etc/modprobe.d/nobeep.conf 输入 1blacklist pcspkr nodejs包1yarn global add hexo vue-cli pip1vim ~/.pip/pip.conf 输入以下内容 12345[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com python 包1sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy pandas sklearn matplotlib requests minepy 配置git123git config --global user.email &quot;douxl5516@163.com&quot;git config --global user.name &quot;douxl5516&quot;git config --global credential.helper store 与windows时间同步1timedatectl set-local-rtc 1 SSH1ssh-keygen -t rsa -C &quot;douxl5516@163.com&quot; WPS字体缺失问题国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzo 1234sudo cp * /usr/share/fontssudo mkfontscalesudo mkfontdirsudo fc-cache]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科研中用到的数学基础]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%A7%91%E7%A0%94%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数学基础范数 在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。 LP范数不是一个范数，而是一组范数。定义如下： L_p=\Vert x \Vert_p=\sqrt[p]{\sum_{i=1}^{n}{x_i^p}},x=(x_1,x_2,\dots,x_n) L0范数表示向量中非零元素的个数。 L1范数表示向量x中非零元素的绝对值之和。定义如下： L_1=\Vert x \Vert_1=\sum_{i=1}^{n}{|x_i|},x=(x_1,x_2,\dots,x_n) L2范数表示向量元素的平方和再开平方，即欧氏距离。 二范数指矩阵A的2范数，就是A的转置共轭矩阵与矩阵A的积的最大特征根的平方根值，是指空间上两个向量矩阵的直线距离。类似于求棋盘上两点间的直线距离。 定义如下： L_2=\Vert x \Vert_2=\sqrt{\sum_{i=1}^{n}{x_i^2}},x=(x_1,x_2,\dots,x_n) 百度百科 几种范数 梯度即对于一般标量函数$f(x)$ , 其中向量为$x=(x_1,x_2,\dots,x_n)$，导数为： \frac{\partial{f}}{\partial{x}}=(\frac{\partial{f}}{\partial{x_1}},\dots,\frac{\partial{f}}{\partial{x_2}})雅可比矩阵 在向量微积分中，雅可比矩阵(Jacobi Matrix)是一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。因此，雅可比矩阵类似于多元函数的导数。 J(f)=\left|\frac{\partial{(f_1,\dots,f_n)}}{\partial{(x_1,\dots,x_n)}}\right|= \left|\begin{matrix} \frac{\partial{f_1}}{\partial{x_1}}&\dots&\frac{\partial{f_1}}{\partial{x_n}}\\ \vdots&\ddots&\vdots\\ \frac{\partial{f_n}}{\partial{x_1}}&\dots&\frac{\partial{f_n}}{\partial{x_n}}\\ \end{matrix}\right|若m=n，则雅可比矩阵为方阵，方阵的行列式为雅可比行列式。 雅可比矩阵 海森矩阵 黑塞矩阵（Hessian Matrix），又译作海森矩阵、海瑟矩阵、海塞矩阵等，是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。黑塞矩阵最早于19世纪由德国数学家Ludwig Otto Hesse提出，并以其名字命名。黑塞矩阵常用于牛顿法解决优化问题，利用黑塞矩阵可判定多元函数的极值问题。在工程实际问题的优化设计中，所列的目标函数往往很复杂，为了使问题简化，常常将目标函数在某点邻域展开成泰勒多项式来逼近原函数，此时函数在某点泰勒展开式的矩阵形式中会涉及到黑塞矩阵。 H(f)=\left[\begin{matrix} \frac{\partial^2{f}}{\partial{x_1^2}}&\frac{\partial^2{f}}{\partial{x_1}\partial{x_2}}&\dots&\frac{\partial^2{f}}{\partial{x_1}\partial{x_n}}\\ \frac{\partial^2{f}}{\partial{x_2}\partial{x_1}}&\frac{\partial^2{f}}{\partial{x_2^2}}&\dots&\frac{\partial^2{f}}{\partial{x_2}\partial{x_n}}\\ \vdots&\vdots&\ddots&\vdots\\ \frac{\partial^2{f}}{\partial{x_n}\partial{x_1}}&\frac{\partial^2{f}}{\partial{x_n}\partial{x_2}}&\dots&\frac{\partial^2{f}}{\partial{x_n^2}}\\ \end{matrix}\right] 海森矩阵 泰勒公式 数学中，泰勒公式是一个用函数在某点的信息描述其附近取值的公式。如果函数足够平滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值。泰勒公式还给出了这个多项式和实际的函数值之间的偏差。 f(x)=\frac{f(a)}{0!}+\frac{f'(a)}{1!}(x-a)+\frac{f''(a)}{2!}(x-a)^2+\dots+\frac{f^n(a)}{n!}(x-a)^n+R_n(x)李代数首先特殊正交群SO(3)可以代表旋转矩阵，SE(3)可以代表欧式变换矩阵。矩阵对于乘法封闭，对于加法不封闭，所以具有群的特性。 李群是指具有连续(光滑)性质的群。 外积 \boldsymbol{a}\times\boldsymbol{b}= \left[ \begin{matrix} \boldsymbol{i}&\boldsymbol{j}&\boldsymbol{k}\\ a_1&a_2&a_3\\ b_1&b_2&b_3\\ \end{matrix} \right]= \left[ \begin{matrix} a_2b_3-a_3b_2\\ a_3b_1-a_1b_3\\ a_1b_2-a_2b_1\\ \end{matrix} \right]= \left[ \begin{matrix} 0&-a_3&a_2\\ a_3&0&-a_1\\ -a_2&a_1&0\\ \end{matrix} \right]\boldsymbol{b}\triangleq\boldsymbol{a}^{\wedge}\boldsymbol{b}相应的，有 \boldsymbol{a}=[a_1\boldsymbol{i},a_2\boldsymbol{j},a_3\boldsymbol{k}],\\ \boldsymbol{a}^{\wedge}=\boldsymbol{A}=\left[ \begin{matrix} 0&-a_3&a_2\\ a_3&0&-a_1\\ -a_2&a_1&0\\ \end{matrix} \right],\\\boldsymbol{A}^{\vee}=\boldsymbol{a} 特殊正交群 $SO(3)$ SO(3)=\{R\in\mathbb{R}^{3\times3}|RR^T=I,\det(R)=1\} 特殊欧式群$SE(3)$ SE(3)=\{T=\left[ \begin{matrix} R&t\\ 0^T&1\\ \end{matrix} \right]\in\mathbb{R}^{4\times4}|R\in SO(3),t\in \mathbb{R}^3\} 李代数$\mathfrak{so}(3)$ 在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{‘}R(t)^T$是一个反对称矩阵，那么就用一个$\phi(t)\in\mathbb{R}^3$与之对应。有： R(t)^{'}R(t)^T=\phi(t)^{\wedge}之后求解微分方程，可以得到： R(t)=exp(\phi^{\wedge}t)实际求解时利用到指数映射和对数映射。 奇异值分解参考资料 分解原理 方阵的迹 百度百科词条 在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)。 性质 tr(AB)=tr(BA) tr(ABC)=tr(CAB)=tr(BCA) f(a)=tr(AB)，$\bigtriangledown_Atr(AB)=B^T$ $tr(A)=tr(A^T)$ tr(a)=a,$a \in R$ $\bigtriangledown_Atr(ABA^TC)=CAB+C^TAB^T$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake入门]]></title>
    <url>%2F2018%2F09%2F13%2FCMake%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文转载自yaoyuanyylyyCMake入门1——CMake与VS编译器和nmake的结合使用CMake入门2——复杂项目的构建配置CMake入门3——更多指令的使用本文描述在Win10-64位系统中安装CMake、cmake-gui的简单使用及其与VS2015编译器的结合使用，以及cmake命令行与nmake的结合使用。 下载从CMake官网上下载最新版本的安装包，本文中下载的是 cmake-3.10.1-win64-x64.msi。若不想安装，可直接下载压缩包版本cmake-3.10.1-win64-x64.zip。 安装CMake的安装非常简单。压缩包版本直接解压即可，安装版本也可一直点击下一步进行安装。为了使用方便，可将CMake配置到环境变量中，当然，这一步也可以在安装过程中设置。另外需要注意的是为了避免不必要的麻烦，路径中最好不要包括中文字符。下面简单描述一下安装过程。 双击下载的安装包，进入安装界面，点击[Next]。 勾选同意许可后，点击[Next]。 可在此处选择将CMake路径添加到环境变量中，并且创建CMake GUI程序的桌面快捷方式。然后点击[Next]。 可在此处自定义安装目录，设置好后点击[Next]。 开始安装，安装完成后点击[Next]。 安装完成，点击[Finish]，结束安装过程。 安装完成后，即可使用CMake了。在命令行中输入&quot;cmake --version&quot;，可看到如下图所示的输出。 例1 使用cmake-gui与VS生成器本例使用cmake-gui和VS生成器构建出VS工程，然后用VS工具打开项目进行编译。 新建CMakeTest目录，在CMakeTest目录下新建demo1目录，作为测试项目的根目录。在demo1下新建main.cpp和CMakeLists.txt文件。main.cpp文件的内容很简单，就是输出一个提示字符串： 1234567#include &lt;iostream&gt;using namespace std;void main()&#123; cout&lt;&lt;&quot;cmake test demo 1&quot;&lt;&lt;endl; getchar();&#125; CMakeLists文件内容如下： 123456# CMake最低版本要求 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo1)# 指定生成目标add_executable(demo main.cpp) CMakeLists.txt 的语法比较简单，由命令、注释和空格组成。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔，且命令是不区分大小写的。符号 # 后面的内容被认为是注释。对于上面的 CMakeLists.txt 文件，依次出现了几个命令： cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本，如果低于3.10.1版本，则构建过程会被终止 project：参数值是 demo1，该命令表示项目的名称是 demo1 add_executable： 将名为 main.cpp 的源文件编译成一个名称为 demo 的可执行文件 打开cmake-gui程序，在上方配置两个目录: 第一个是CMakeLists文件目录，cmake据此开始执行 第二个是cmake构建后的项目目录 配置好点击[Configure]开始执行配置过程。首先会弹出编译器选择界面，此处使用默认的VS2015-32位编译器，直接点击[Finish]，开始配置。 第一次配置完成后如图所示，红色的两行是新的配置值，再次点击[Configure]即可。 配置完成后，在build目录生成了如下的文件 点击[Generate]，开始生成VS项目 生成完成后，在build目录下生成了demo1对于的VS项目 通过点击cmake-gui中下放的[Open Project]按钮或者直接双击build目录下的demo1.sln，即可在VS中打开工程。 cmake生的demo1工程总共有3个项目 ZERO_CHECK：该项目会检查生成工程的 CMake 配置文件（ CMakeLists.txt ）是否更新。如更新，将运行 CMake 重新生成工程文件。如果确信 CMakeLists.txt 不会被更新，或者希望手工运行 CMake 重新生成工程文件，可以在 CMakeLists.txt 配置文件中添加 set(CMAKE_SUPPRESS_REGENERATION FALSE) 命令， ZERO_CHECK 目标将不会生成。 ALL_BUILD：该目标会导致工程中所有项目被构建，类似 Visual Studio 的 Build All 或者 make 的 make all命令。 demo：项目本身，就是在CMakeLists.txt文件中配置的project(demo1) 在VS中通过单独生成项目demo1或者直接生成项目All_BUILD后，可以在build下的相应目录看到可执行文件demo.exe已经生成。双击demo.exe后，可以看到程序输出。 如果不想用VS打开工程，也可以使用msbuild.exe编译demo1工程。首先需要打开VS命令行，因为cmake-gui中选择的编译器是32位的，所以此处选择”VS2015 x86 本机工具命令提示符”。 打开后在命令行中进入到demo1的build目录，执行msbuild demo1.sln即可编译demo1项目。编译完成后可以在debug中看到生成的demo.exe文件，双击可运行。 例2 使用cmake命令与nmake生成器 本例使用cmake命令行与nmake生成器构建Makefile，然后用nmake编译项目。 新建项目demo2，将demo1中的main.cpp和CMakeLists.txt文件拷贝过来。将CMakeLists.txt文件中的project项目配置为demo2。 2. 同样从VS命令行进入到demo2目录，执行命令： 1cmake -G "NMake Makefiles" . 执行完毕后，即可看到在demo2目录中生成了一些文件： 其中重要的是Makefile文件，这是用来编译项目的。在命令行中继续执行nmake命令开始编译，编译完成后可以看到在demo2目录生成了demo.exe程序。允许后可以看到输出。 例3 PreLoad.cmake用法在命令行下使用cmake，需要用”-G”选项指定生成器。每次都输入感觉比较麻烦，可以将其配置在”PreLoad.cmake”文件中。新建项目demo3，准备好main.cpp和CMakeLists.txt文件，然后demo3目录下新建文件”PreLoad.cmake”，输入： 1set(CMAKE_GENERATOR "NMake Makefiles" CACHE INTERNAL "" FORCE) 然后执行&quot;cmake .&quot;即可配置，然后执行&quot;nmake&quot;就可以编译。 例4 多文件单目录测试此测试项目将所有的文件都放在根目录下。 在CMakeTest目录下新建demo4目录。demo4项目文件列表如下： 其中实现了算术运算的加减乘除，每个功能分别实现在各自的文件中： 1234int my_add(int a, int b);int my_minus(int a, int b);int my_multiply(int a, int b);int my_divide(int a, int b); 然后在main.cpp中调用各个函数，代码如下： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;#include "add.h"#include "minus.h"#include "multiply.h"#include "divide.h"void main()&#123; cout&lt;&lt;"cmake test demo 4"&lt;&lt;endl; int a=20; int b=10; cout&lt;&lt;a&lt;&lt;"+"&lt;&lt;b&lt;&lt;"="&lt;&lt;my_add(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;"-"&lt;&lt;b&lt;&lt;"="&lt;&lt;my_minus(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;"*"&lt;&lt;b&lt;&lt;"="&lt;&lt;my_multiply(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;"/"&lt;&lt;b&lt;&lt;"="&lt;&lt;my_divide(a, b)&lt;&lt;endl; getchar();&#125; CMakeLists.txt文件内容如下： 1234567891011# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo4)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;) 此配置文件中使用了一条新命令： aux_source_directory：该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。这样，就不用在add_executable中列出所有源文件了，而是直接引用变量即可。从VC命令行进入到demo4目录，然后执行cmake命令和nmake命令，即可编译出执行程序。 例5 多文件单子目录测试此测试项目将main入口函数文放在根目录下，其他文件放在独立目录下。新建demo5目录，使用例3中的项目文件，将main.cpp放在demo5目录下，将其他的加减乘除的相关文件放在math子目录下。然后在demo5目录和math目录下分别放一个CMakeLists.txt文件。 其中demo5目录下的CMakeLists.txt文件内容如下： 1234567891011121314151617181920# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo5)# 添加头文件目录include_directories(math)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;)# 添加math子目录add_subdirectory(math)# 添加链接库target_link_libraries(demo math) 在这个配置文件中，依次出现了几条新的cmake命令： include_directories：头文件包含目录，因为main.cpp中使用了加减乘除函数，因此需要指明头文件目录所在之处。当然，也可以在main.cpp中包含都文件时指定目录 add_subdirectory：添加子目录命令，表示需要编译该子目录 target_link_libraries：添加要依赖的库文件，此处的math库是在子目录math中编译出来的math目录下的CMakeLists.txt文件内容如下： 12345678# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_LIB_SRCS)# 指定生成目标add_library(math $&#123;DIR_LIB_SRCS&#125;) 在上面这个配置文件中，出现了一条新命令： add_library：将指定的文件编译为库，前面是库名称，后面是源文件进demo5目录，然后执行cmake命令和nmake命令，即可编译出执行程序。可以看到，在math子目录下生成了一个”math.lib”的库文件。 例6 多目录和多级目录测试本例子demo6中把加减乘除四个运算分散在不同的目录下，形成了多个目录、多级目录的形式。具体的文件布局如下图所示： 多个子目录和多级目录在用cmake来构建时的一种方式是：将所有源文件按功能或目录来分别构建为库，然后在需要用到库的地方链接上所需的一个或多个库。 对于此例来说，各目录的说明和构建方式如下： demo6根目录下包括了math和divide两个目录； divide目录是除法目录，由其目录中的配置文件单独构建为一个库； math目录包括了add_minus和multiply两个目录； add_minus目录包括加法的实现文件和减法目录minus; 减法不单独构建为库，而是和加法一起，用add_minus中的配置文件构建为一个库； 乘法的库也不再它自己的目录中构建，而是在math目录下构建为单独的乘法库； 最后，在demo6根目录下的配置文件中构建demo.exe程序，并连接了乘法库、除法库、加减法合在一起的库；首先，divide目录下构建除法库的配置文件比较简单，使用了 aux_source_directory 和add_library两条指令。 12345678# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_LIB_DIVIDE_SRCS变量中aux_source_directory(. DIR_LIB_DIVIDE_SRCS)# 指定生成目标add_library(lib_divide $&#123;DIR_LIB_DIVIDE_SRCS&#125;) 其次，加减法库的构建如下： 12345678910# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_MINUS_SRCS变量中aux_source_directory(./minus DIR_MINUS_SRCS)# 把要编译的文件都列在此处，存入ADD_SRCS变量中set(ADD_SRCS add.cpp)# 指定生成目标add_library(lib_add_minus $&#123;ADD_SRCS&#125; $&#123;DIR_MINUS_SRCS&#125;) 这个也很简单，只是有3点小改变： aux_source_directory指令中指定的目录为./minus，表示当前文件夹下的minus子目录，也就是把minus子目录下的减法源文件存在了DIR_MINUS_SRCS变量中 使用了一条新的指令set，这也是一条用来设置变量的，不过变量放在前面，变量的值放在后面。这里指定为将当前目录下的加法实现源文件存入变量ADD_SRCS中。需注意的是，后面的文件可以列出多个各处的文件 在add_library命令将前面的两个保存了加法和减法源文件的变量一起用来生成一个库lib_add_minus再次，math目录下的配置文件如下： 1234567891011# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 添加子目录add_subdirectory(add_minus)# 把要编译的文件都列在此处，存入DIR_MULTIPLY_SRC变量中set(DIR_MULTIPLY_SRC multiply/multiply.cpp)# 指定生成目标add_library(lib_multiply $&#123;DIR_MULTIPLY_SRC&#125;) 在这个配置文件中，将multiply目录下的乘法编译成了单独的一个库，然后添加了add_minus子目录。所用的指令都是已使用过的。最后，根目录demo6下的配置文件如下： 123456789101112131415161718192021222324# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo6)# 添加头文件目录include_directories(math/add_minus math/add_minus/minus math/multiply)include_directories(divide)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;)# 添加math子目录add_subdirectory(math)# 添加divide子目录add_subdirectory(divide)# 添加链接库target_link_libraries(demo lib_add_minus)target_link_libraries(demo lib_multiply lib_divide) 在这个配置文件中，有几点小说明： 这个根目录下的配置文件为cmake的入口配置文件，所以在其中指定了最低版本。这样其实在子目录下的配置文件中就可以不用再用cmake_minimum_required指令了 用include_directories指令指明了头文件所在目录，一条命令中可以指定多个头文件包含目录。在实际项目中可将头文件提取到一个目录中，然后指定一个目录就可以了 用add_subdirectory指明了divide和math两个子目录 用target_link_libraries将各个库连接到目标程序”demo”中，此命令也可以一次指定多个库。至此，所有的工作就做好了，在命令下执行cmake命令和nmake命令，就可编译出执行程序。同时可以看到，在math子目录下生成了一个”lib_multiply.lib”库，在math/add_minus目录下生成了一个lib_add_minus.lib库，在divide目录下生成了lib_divide库。 基本语法规则从前面的几个例子中，我们使用了cmake的几条基本指令，在这里，总结一下： cmake由指令、注释和空白字符组成 以#开头，到行末尾的是注释 形如指令(参数1 参数2 参数3 ...)的是指令，参数间使用空格或者分号;隔开 指令不区分大小写，但参数是区分大小写的 cmake中可以设置变量，变量的引用方式为${变量名} cmake的构建指令为“cmake path [参数选项]”；当前我们都使用的是“cmake .”，表示构建当前目录下的项目 内部构建与外部构建在前面的例子中，danger构建项目后，会发现cmake构建过程中产生的中间文件和项目文件混在一起，多了就不好区分；而且cmake不能跟踪这些中间文件，所以也没有一条可以清除它们的指令。 这样的情况是因为我们使用的是cmake的内部构建，而cmake提供的另外一种称为外部构建的构建方式，可以解决这个问题。 内部构建：in-source build，在项目的入口配置文件目录下执行“cmake .”时，就是内部构建；这种方式下，生成的临时中间文件就放在了构建目录下，导致和源文件混在一起 外部构建：out-of-source build，在其他目录下执行cmake构建命令，然后指定入口配置文件的目录，这样就可以将临时文件存放于单独的目录中。比如我们在项目下新建一个build目录，然后在build目录下执行“cmake ..”，那么我们就可以看到构建后的所有临时文件都产生在build目录中，这样就方便我们管理和清理了 例7 外部构建以及“project”和“message”指令首先，我们新建一个项目demo7，其中的源文件和demo6的是一样的，唯一的区别只有demo7根目录下的CMakeLists.txt文件不同，我们添加了几条“message”指令，这是用来在构建过程中显示消息的。 配置文件的前面部分如下： 12345678910111213# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo7)message(STATUS "the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;")message(STATUS "the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;")message(STATUS "the BINARY dir is $&#123;demo7_BINARY_DIR&#125;")message(STATUS "the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;")# ... 后面的没有改变，此处省略不显示 因为要采用外部构建的方式，因此我们先新建一个build目录，然后在build目录下执行cmake构建指令。过程如下： 可以从以一个红框中看到外部构建的一般过程。这里我们来看看第二个红框中的输出内容，这就是“message”指令的输出。 “message”指令的语法如下： 1message([SEND_ERROR | STATUS | FATAL_ERROR] "message" ...) 第一个参数是消息类型，后面的参数是一条或多条要显示的消息。错误类型有3种： SEND_ERROR：表示产生错误信息 STATUS：表示一般的状态信息 FATAL_ERROR：我们知道肯定是严重错误信息，cmake会立即停止执行参数个数： 一条消息显示指令后可以跟上多条消息，它们会依次连在一起进行显示我们修改一下前面的配置文件如下： 12345678910111213141516# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo7)message(STATUS "------------------------------" "this is " "another message")message(STATUS "the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;")message(STATUS "------------------------------")message(SEND_ERROR "the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;")message(STATUS "------------------------------")message(STATUS "the BINARY dir is $&#123;demo7_BINARY_DIR&#125;")message(STATUS "------------------------------")message(FATAL_ERROR "the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;")message(STATUS "------------------------------") 在每条消息前后我们用分割线分割开，构建后，可以看到消息显示如下： 第一个红框中的是前两条消息，其中第一条消息的多个消息是连续显示的；第二个红框中的是”SEND_ERROR”类型的错误消息，cmake会提示错误所在的行，然后项目会继续构建；最后一个红框中的是”FATAL_ERROR”类型的消息，cmake首先也输出了错误消息，然后便中止了构建过程。下面我们来关注一下这个配置文件中在message指令中使用的几个变量： ${PROJECT_BINARY_DIR} ${PROJECT_SOURCE_DIR} ${demo6_BINARY_DIR} ${demo6_SOURCE_DIR}首先，”project” 指令在使用后会定义两个隐式的变量 “PROJECT_BINARY_DIR” 和 “PROJECT_SOURCE_DIR”。从输出的消息我们也可以看到，前者就是我们执行构建命令时所在的目录，也是我们的中间文件存放的目录；后者就是我们的配置文件和源文件所在的目录。 同时，因为用 “project” 指令将项目名称指定为 “demo7” ，所以这两个变量中的”PROJECT”部分也可以中”demo7来代替。但是，不推荐用这种方式。 另外，当我们使用内部构建时，这两个变量的值是一样的。 最后，这两个值和我们使用cmake-gui时，要设置的两个目录是相对应的。]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java平台下Opencv图像展示的简便实现]]></title>
    <url>%2F2018%2F08%2F12%2FJava%E5%B9%B3%E5%8F%B0%E4%B8%8BOpencv%E5%9B%BE%E5%83%8F%E5%B1%95%E7%A4%BA%E7%9A%84%E7%AE%80%E4%BE%BF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在C++环境下的OpenCV中，展示Mat图像可以通过imshow()实现。但在Java平台上该怎样简便地实现呢？ 通常的做法是将读取到的Mat转化为BufferedImage，将BufferedImage作为GUI中的icon进行展示。下方是将Mat转化为BufferedImage的代码。12345678910111213141516171819202122/** * Mat转换成BufferedImage * * @param matrix 要转换的Mat * @param fileExtension 格式为 ".jpg", ".png", etc * @return 转换后的BufferedImage */ public static BufferedImage Mat2BufferedImage (Mat matrix, String fileExtension) &#123; // convert the matrix into a matrix of bytes appropriate for this file extension MatOfByte mob = new MatOfByte(); Imgcodecs.imencode(fileExtension, matrix, mob); // convert the "matrix of bytes" into a byte array byte[] byteArray = mob.toArray(); BufferedImage bufImage = null; try &#123; InputStream in = new ByteArrayInputStream(byteArray); bufImage = ImageIO.read(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bufImage; &#125; 这里提供一种简单的方法，实现了类似C++的图像展示方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.awt.Graphics;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.BufferedImage;import javax.swing.JFrame;import javax.swing.JPanel;import org.opencv.core.Mat;public class ImageUI extends JPanel implements KeyListener &#123; public ImageUI(Mat m, String window) &#123; super(); init(m, window); &#125; //Elements for paint. private Mat mat; private boolean firstPaint = true; private BufferedImage out; int type; private String WINDOW = ""; private JFrame jframe = new JFrame(); byte[] data; private void Mat2BufIm()&#123; mat.get(0, 0, data); out.getRaster().setDataElements(0, 0, mat.cols(), mat.rows(), data); &#125; private void init(Mat m,String window)&#123; this.mat = m; data = new byte[mat.cols() * mat.rows() * (int)mat.elemSize()]; WINDOW = window; if(mat.channels() == 1) type = BufferedImage.TYPE_BYTE_GRAY; else type = BufferedImage.TYPE_3BYTE_BGR; out = new BufferedImage(mat.cols(), mat.rows(), type); Mat2BufIm(); jframe.add(this); jframe.setSize(mat.cols(), mat.rows()); jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jframe.setTitle(WINDOW); jframe.addKeyListener(this); &#125; @Override public void paintComponent(Graphics g) &#123; g.drawImage(out, 0, 0, null); &#125; public ImageUI imshow()&#123; if(firstPaint)&#123; jframe.setVisible(true); firstPaint = false; &#125; Mat2BufIm(); this.repaint(); return this; &#125; //Elements for waitKey. private static Object mt = new Object(); private static int lastKey = 0; private static int key = 0; public static int waitKey(int millisecond)&#123; //TODO 实现监听键盘 try &#123; if(millisecond == 0)&#123; synchronized(mt)&#123; mt.wait(); &#125; &#125; Thread.sleep(millisecond); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; int ret = -1; if(key != lastKey)&#123; ret = key; lastKey = key; &#125; return ret; &#125; @Override public void keyPressed(KeyEvent e) &#123; synchronized(mt)&#123; mt.notifyAll(); &#125; this.key = e.getKeyCode(); &#125; @Override public void keyReleased(KeyEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent arg0) &#123; // TODO Auto-generated method stub &#125; &#125; 在项目中添加上面的源码后，可以通过以下方式实现图像的展示： 12345Mat mat = Mat.eye(1000, 2000, CvType.CV_8UC3);String window_name = "mat"ImageUI ig = new ImageGui(mat,window_name);ig.imshow();ig.waitKey(0); 或者，可以通过另一种简单的方法实现： 12Mat mat = Mat.eye(1000, 2000, CvType.CV_8UC3);new ImageGui(mat,"mat").imshow().waitKey(0);]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java下OpenCV中Mat的初始化及赋值方法]]></title>
    <url>%2F2018%2F08%2F08%2FJava%E4%B8%8BOpenCV%E4%B8%ADMat%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[利用函数构造特殊Mat 12A = Mat.eye(3,3, CvType.CV_64FC1);A = Mat.zero(3,3,CvType.CV_64FC1); 诸如MatOfDouble之类的矩阵，还支持将矩阵转换为List或者从List（array）转换成矩阵。所以可以直接这样创建矩阵： 1MatOfDouble A = new MatOfDouble(1,2,3,4,5,6,7,8,9); 或者 12MatOfDouble A = new MatOfDouble();A.fromArray(1,2,3,4,5,6,7,8,9); 这样得到的矩阵实际上是一个列向量，也就是$91$的矩阵。如果想得到一个$33$的矩阵，可以使用reshape。 1A.reshape(1,3); 注意这里第一个参数为通道数，第二个参数为行数]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows远程桌面连接阿里云Ubuntu服务器]]></title>
    <url>%2F2018%2F08%2F02%2FWindows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地Windows远程桌面连接阿里云Ubuntu 16.04服务器: 1、目的:希望通过本地的Windows远程桌面连接到阿里云的Ubuntu服务器,通过远程桌面图形界面的方式操作服务器。 2、条件:申请的阿里云Ubuntu服务器一台,本地Windows操作系统电脑一台。 3、如何远程桌面连接: (1)首先通过Windows系统下连接Linux系统的命令行工具连接Ubuntu服务器,(工具:xshell,securecrt,putty等)。 (2)通过Windows下工具连接到linux操作系统,之后打开命令窗口,切换到root权限。 (3)先安装更新:apt-get upate。 (4)安装xrdp:输入apt-get install xrdp—&gt;回车—&gt;输入”y”—&gt;回车,安装完成。 (xrdp: An open source remote desktop protocol(rdp) server) (5)安装vnc4server:输入apt-get install vnc4server”—&gt;回车—&gt;输入”y”—&gt;回车,安装完成。 (VNC (Virtual Network Console)是虚拟网络控制台的缩写) (6)安装xfce4:输入apt-get install xubuntu-desktop”—&gt;回车—&gt;输入”y”—&gt;回车。 —&gt;输入echo “xfce4-session” &gt;~/.xsession—&gt;回车—&gt;输入 service xrdp restart—&gt;回车,安装完成。 (Xfce是一个自由软件,运行在类Unix操作系统 (如Linux、FreeBSD 和 Solaris)上,提供轻量级桌面环境。) (7)在本地Windows电脑上,使用”窗口键+R”打开”运行对话框”—&gt;输入”mstsc”—&gt;回车—&gt;输入Ubuntu主机的IP地址—&gt;”连接”。 (8)选择”sesman-Xvnc”—&gt;输入”用户名和密码”—&gt;回车,成功登录到Ubuntu桌面,现在可以进行远程操作了。]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
