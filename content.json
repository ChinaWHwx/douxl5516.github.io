{"meta":{"title":"平崖","subtitle":"平崖远望，踽踽独行。","description":"平崖远望，踽踽独行。","author":"窦星磊","url":"https://douxl5516.github.io","root":"/"},"pages":[{"title":"分类","date":"2015-11-15T10:50:06.000Z","updated":"2019-05-05T13:16:58.926Z","comments":false,"path":"categories/index.html","permalink":"https://douxl5516.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2014-05-08T09:06:30.000Z","updated":"2019-06-09T11:45:22.170Z","comments":false,"path":"about/index.html","permalink":"https://douxl5516.github.io/about/index.html","excerpt":"","text":"关于我 窦星磊，吉林大学软件学院软件工程专业（国家卓越工程师教育培养计划）本科在读。 联系我 邮箱:douxl5516@163.com QQ:562125370 版权与协议 若无特殊说明，本站所有文章均为原创文章，并遵循 CC BY-SA 4.0 协议发布。 你可以自由地对博客中内容进行分享、创作演绎直至商业性的使用，但必须在文章末尾或参考文献处注明文章的出处（文章链接）。完整的协议可以参看这里。"},{"title":"随笔","date":"2018-08-01T02:24:00.000Z","updated":"2019-06-28T07:32:32.383Z","comments":false,"path":"notes/index.html","permalink":"https://douxl5516.github.io/notes/index.html","excerpt":"","text":"2019 6月28日 如果十年以后，你以快而脏的方式做什么事的时候，能想象我在你的肩后看着，然后对自己说：「Dijkstra 不会希望这样的。」那么对我来说，这就和永生一样了。 — Edsger Wybe Dijkstra 5月7日 朱砂痣与白月光 5月4日 祝工作顺利，身体健康。 2018 8月8日 Already with thee! Tender is the night. —— 济慈《夜莺颂》 8月2日 平崖远望，踽踽独行。"},{"title":"标签云","date":"2015-11-15T10:48:58.000Z","updated":"2019-05-05T13:16:58.972Z","comments":false,"path":"tags/index.html","permalink":"https://douxl5516.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSAPP3e","slug":"CSAPP3e","date":"2020-01-27T15:23:28.000Z","updated":"2020-01-29T01:26:56.799Z","comments":true,"path":"2020/01/27/CSAPP3e/","link":"","permalink":"https://douxl5516.github.io/2020/01/27/CSAPP3e/","excerpt":"","text":"12345678910/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~( ~(~x&amp;y) &amp; ~(x&amp;~y) );&#125; 123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1&lt;&lt;31;&#125; 12345678910/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; return (!(x+1+x+1))&amp;(!!(x+1));&#125; 12345678910111213/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int mask=0xAA; mask+=(mask&lt;&lt;8)+(mask&lt;&lt;16)+(mask&lt;&lt;24); return !(mask^(mask&amp;x));&#125; 12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 123456789101112/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; return !((x+(~0x30+1))&gt;&gt;31) &amp; (x+(~0x3a+1))&gt;&gt;31;&#125; 12345678910/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; return ((!x+~1+1)&amp;y)|((~!x+1)&amp;z);&#125;","categories":[{"name":"体系结构","slug":"体系结构","permalink":"https://douxl5516.github.io/categories/体系结构/"}],"tags":[{"name":"CMU","slug":"CMU","permalink":"https://douxl5516.github.io/tags/CMU/"},{"name":"体系结构","slug":"体系结构","permalink":"https://douxl5516.github.io/tags/体系结构/"}]},{"title":"matplot绘图尺寸设置","slug":"matplot绘图尺寸设置","date":"2019-10-30T03:10:11.000Z","updated":"2019-10-30T03:14:12.878Z","comments":true,"path":"2019/10/30/matplot绘图尺寸设置/","link":"","permalink":"https://douxl5516.github.io/2019/10/30/matplot绘图尺寸设置/","excerpt":"","text":"12def get_figsize(w,h,dpi): return [w*0.3937008*dpi/100,h*0.3937008*dpi/100]","categories":[{"name":"编程","slug":"编程","permalink":"https://douxl5516.github.io/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://douxl5516.github.io/tags/Python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://douxl5516.github.io/tags/matplotlib/"}]},{"title":"图的社区发现算法","slug":"图的社区发现算法","date":"2019-09-24T12:36:18.000Z","updated":"2019-09-24T13:16:36.690Z","comments":true,"path":"2019/09/24/图的社区发现算法/","link":"","permalink":"https://douxl5516.github.io/2019/09/24/图的社区发现算法/","excerpt":"","text":"网络，数学上称为图，最早研究始于1736年欧拉的哥尼斯堡七桥问题，但是之后关于图的研究发展缓慢，直到1936年，才有了第一本关于图论研究的著作。20世纪60年代，两位匈牙利数学家Erdos和Renyi建立了随机图理论，被公认为是在数学上开创了复杂网络理论的系统性研究。之后的40年里，人们一直讲随机图理论作为复杂网络研究的基本理论。然而，绝大多数的实际网络并不是完全随机的。1998年，Watts及其导师Strogatz在Nature上的文章《Collective Dynamics of Small-world Networks》揭示了复杂网络的小世界性质。随后，1999年，Barabasi及其博士生Albert在Science上的文章《Emergence of Scaling in Random Networks》又揭示了复杂网络的无标度性质(度分布为幂律分布)，从此开启了复杂网络研究的新纪元。 随着研究的深入，越来越多关于复杂网络的性质被发掘出来，其中很重要的一项研究是2002年Girvan和Newman在PNAS上的一篇文章《Community structure in social and biological networks》，指出复杂网络中普遍存在着聚类特性，每一个类称之为一个社团(community)，并提出了一个发现这些社团的算法。从此，热门对复杂网络中的社团发现问题进行了大量研究，产生了大量的算法，本文试图简单整理一下复杂网络中聚类算法，希望对希望快速了解这一部分的人有所帮助。本文中所谓的社团跟通常我们将的聚类算法中类(cluster)的概念是一致的。 0. 预备知识 为了本文的完整性，我们首先给出一些基本概念。 一个图通常表示为G=(V,E)，其中V表示点集合，E表示边集合，通常我们用n表示图的节点数，m表示边数。一个图中，与一个点的相关联的边的数量称为该点的度。对于一个图，图中所有点的度的和恰好等于边数的两倍。图通常用邻接矩阵A表示，邻接矩阵的(i,j)位置元素是1表示点i到点j右边，0表示无边。 本文中我们会用到随机图的概念，所谓随机图，就是指一个图中任何两个点之间连边的概率相等。首先确定n个点，然后以固定概率p去给图中的一对顶点连边，就形成了一个随机图。在研究中,随机图通常用来作为一个null model来与实际网络进行比较，从而得出一些性质结论。 研究社团的划分，一个需要解决的问题是，如何来衡量一个社团的划分的好坏？一个比较简单直观的原则是使得社区内部的边尽可能地多，社区之间的边间可能地少。另外一个稍微复杂点但是更为常用的度量是Newman等人提出的模块度(modularity)的概念，基本的想法是这样的：我们假设在随机图中是不存在这种社团结构的，将实际网络跟其相应的随机网络进行比较，如果一个网络跟随机网络之间的差异越大，表示社团结构越明显。这样，我们对划分后的每一个子网络计算一个“密度”，然后计算该子网络随机情况下的“密度”，这两个“密度”存在一个差值，表示了该子网络偏离随机情况的一种程度，并且这个值越大表示这个子网络相对随机网络越稠密。一个网络中包含的所有子网络的这个差值加到一起的和就是这个复杂网络的模块度，数学公式表示如下： [![1](http://img2.tbcdn.cn/L1/461/1/4fd7d50ff78d5231045859f0e8a56fd6cda7e749)](http://img2.tbcdn.cn/L1/461/1/4fd7d50ff78d5231045859f0e8a56fd6cda7e749) 其中Aij表示图的邻接矩阵，ki 表示点i 的度，m是图的边数，ki*kj/2m表示点 i 和点 j之间边的期望。进一步将模块度可以化为等式右边的形式，nc是社团的总个数，lc是社团c内的边数，dc是社团内的点的度数之和 (note: 社团内的每一个点可能跟本社团内部的点有边，也可能有跟其他社团点连边，故通常 dc&gt; lc) 有了这些知识，我们来看一下复杂网络社团划分的各种算法吧。 1. 图的剖分 把一个网络划分成多个社团就是把一个图剖分成多个图，图的剖分问题是图论中一个比较难的问题，也是研究比较多的问题，理论上是NP-hard的。因此，人们通常研究比较简单的情况：图的二剖分，即把一个图分成两个(一般要求大小相等)的图，比较有名的算法是Kernighan-Lin 算法和谱平分法。 1.1 Kernighan-Lin 算法[1] 思想：不断交换两个子图中的点，使得两个子图之间的边尽可能地少 定义增益函数: Q=两个社团内的边数-社团之间的边数 算法步骤： Step1 随机划分为已知大小的两个社团 Step2 从两个社团各取一个点，尝试交换并计算ΔQ = Q交换后-Q交换前，选择使ΔQ最大的一对节点对交换 Step3 规定每个节点只能交换一次，对剩余节点重复step2, 直到 ΔQ &lt;0，或者某个子图的所有节点都被交换了一次为止。 Step4 允许每个节点的第二次交换,开始新一轮迭代,直到没有节点对可以交换 1.2 谱平分法 所谓“谱”，就是矩阵的特征值；所谓“平分”，就是将一个图分成大小相等的两个子图。谱平分法就是利用图的拉普拉斯矩阵的第二小特征向量来进行聚类的一种方法。 这里暂且先放一下，下面介绍完谱算法之后再回头具体介绍谱平分法。 1.3 总结 图的剖分常常需要制定子图的个数(否则，整体作为一个)，甚至每个子图的大小(否则，常常会将一个点分为一个子图)。但是如果已知一个图就是两个社团组成，谱评分法往往可以得到很好的效果。 2. 凝聚法 这是一大类算法，总体思想是寻找社团“最中心”的边，不断地把最相似的两个点聚到一起，从点聚到小社团，再聚成大社团。根据定义两个点的相似性的不同，产生了很多不同的算法。有的算法并不直接计算相似性，而是看两个点合并到一起后模块度的变化情况，根据变化的大小来选择需要合并的两个点。比较有代表性的算法是Newman在2004年的一个算法[2] 2.1 Newman算法 思想：不断地选择是模块度增长最大的两个社团进行合并 算法步骤： Step1. 每个点当作一个社团 Step2. 计算两个社团合并后模块度的变化(增长) ΔQ，选取使得ΔQ最大的两个社团进行合并 Step3. 重复step2直到最后合并为一个社团 2.2 Newman算法的优化 Newman算法复杂性是O((m+n)n),Clause,Newman和Moore利用最大堆将该算法复杂度降低为O(n(logn)^2)[3] 对于该算法, 人们想出了很多改进措施，例如以下两个策略： \\1. multistep贪婪算法：每次迭代合并多个社团 \\2. 归一化ΔQ，消除社团大小的影响 2.3 总结 凝聚法优点是简单，限制少,不需要预先指定社团个数,可以发现社团的层次关系。缺点是缺乏全局目标函数; 两个点一旦合并，就永远在一个社团中了，无法撤消；另外，这种算法往往对单个的点比较敏感 3. 分裂法 分裂法的基本思想是找出最有可能位于社团之间的边，把这些边去掉，就自然产生了不同的社团。代表性的算法是Girvan 和Newman在2002年的一个算法 [4]. 3.1 GN 算法[4] 首先给出介数(etweenness)的定义，一个边的介数(edge betweenness)是指通过该边的最短路的条数。 直观上，社团之间的边有较高的betweenness,而社团内部的边betweenness相对较小，这样，通过逐个去掉这些高betweenness的边，社团结构就会逐步显现出来。 算法步骤: Step1. 计算每条边的介数 （O(nm) with BFS） Step2. 去掉具有最高介数的边 Step3. 如果满足了社团划分的要求, stop; 否则, 转step1. 利用各种其他度量(如边聚类系数等)来代替边介数，该算法也产生了各种各样的变种。 3.2 其他分裂方法 分裂法还有很多，如MST，JP算法等等，在此就不一一描述了。 3.3 总结 凝聚法跟分裂法是对应的，一个自下而上，一个自上而下，一个不断把点连在一起，一个不断去边把点分开。分裂法的优缺点跟凝聚法类似。 4. 谱算法 首先给出一个概念——图的Laplacian 矩阵（L-矩阵）。设A为图的邻接矩阵； D为一个对角阵(对角元素为点 i 的度)，则图的Laplacian矩阵L=D-A。关于L-矩阵，有很多性质，如：(1) 矩阵的每一行的元素之和为0 ，由此可以知道该矩阵至少一个0特征值，并且0特征值对应的特征向量为全1向量（1,1,...,1）。（2）0 特征向量的个数与连通分支的个数相同；如果一个图是连通的，那么其Laplacian矩阵只有一个0特征值，其余特征值都是正的。(3)不同特征值的特征向量正交的。 所谓谱，就是指矩阵的特征值。谱算法就是利用邻接矩阵或者拉普拉斯矩阵的特征向量，将点投影到一个新的空间，在新的空间用传统的聚类方法(如k-means)来聚类。 谱算法的一般步骤是: Step1. 计算相似矩阵(如邻接矩阵A)的前 s 个特征向量 Step2. 令 U 是一个 n× s 矩阵，每一列是一个特征向量 Step3. U 的第 i 行作为点 i 的坐标，用层次聚类法或者k-means等得到最终的社团 需要说明一点是: 如果是计算邻接矩阵的特征值，一般取最大的s个特征值；如果是计算Laplacian矩阵的特征值，则是计算最小的（除0外）s个特征值。 前面我们提到过谱平分法，就是利用Laplacian矩阵倒数第二个小的特征值对应的特征向量(称为Fiedler 向量)来聚类的。因为需要把一个图平分成两个子图，因此就把Fiedler向量中正的分量对应的点分成一类，负的分量对应的点分成另一类。 谱算法的计算瓶颈是计算矩阵的特征值，因为少数的几个特征向量就可以得到很好的聚类，所以只需要计算最大的几个特征值既可以，可以考虑用Lanczos method。 5. 矩阵分解 谱算法的实质是矩阵分解，其他的矩阵分解方法还有SVD 和 NMF 等，矩阵分解的整体思想就是把点从一个空间映射到另一个空间，在新的空间利用传统的聚类方法来聚类。 6. 标签传播算法 标签传播(Label propagation)算法是由Zhu X J于2002年提出[5]，它是一种基于图的半监督学习方法，其基本思路是用已标记节点的标签信息去预测未标记节点的标签信息。2007年，Raghavan U N等最早提出将LPA最早应用于社区发现，该算法被简称为RAK算法[6] 思想: 每个节点赋予一个标签标志着其所在社区，每次迭代，每个节点标签根据其大多数邻近节点的标签而修改，收敛后具有相同标签的节点属于同一个社区。 算法步骤: Step1 给每一个节点随机生成一个标签 Step2 随机生成一个所有节点的顺序，按照该顺序将每一个节点的标签修改为其大多数邻居节点的标签。 Step3 重复step2，直到每个节点的标签都不再变化，具有相同标签的节点组成了一个社区。 7. 随机游走 随机游走: 从一个顶点向下一个顶点移动时，以相等的概率来选择当前顶点的一个邻居作为下一个顶点。 基本思想: 社团时相对比较稠密的子图，因此在图中进行随机游走时很容易“陷入”一个社团中。 随机游走的过程构成了一个Markov链。图中每一个顶点对应一种状态；不同状态之间的转移概率为 t 步随机游走从 i 到 j 的概率是 Pij 的t次幂 下面我们介绍一个代表性的随机游走算法，叫做Walktrap 算法[7] Walktrap 算法 定义如下距离： 顶点 i 和 j 的距离: 社团C到点j的距离: 社团C1到C2的距离: 算法步骤: Step1 每一个点当做一个社区，计算相邻的点(社团)之间的距离 Step2 选取使得下式最小的两个社团C1和C2 合并为一个社团， 重复这一步骤直到所有点合并为一个社团。 标签传播算法尽管速度快，但是效果并不太理想。 8. Louvain (BGLL) 算法 Louvain (BGLL) 算法[8]是一个基于模块度最优化的启发式算法，算法两层迭代，外层的迭代是自下而上的凝聚法，内层的迭代是凝聚法加上交换策略，避免了单纯凝聚方法的一个很大的缺点(两个节点一旦合并，就没法再分开)。 算法步骤： Step1 每一个点初始时被看作一个社团, 按一定次序依次遍历每一个顶点. 对每一个顶点i ，考虑将 i 移至其邻居顶点 j 的社团中模块度的变化ΔQ 。如果 ΔQ&gt;0，将 顶点i 移至使得ΔQ变化最大的顶点的社团中; 否则，顶点 i 保持不动。重复这个过程，直到任何顶点的移动都不能使模块度增大。 Step2 将step1得到的每一个社团看作一个新的顶点，开始新的一轮迭代，直到模块度不再变化。 该算法简单、直观，容易实现；速度快，并且效果也很好。综合效率和效果两方面考虑，该算法应该是目前最好的方法之一。 9.Canopy算法 + K-Means 9.1 Canopy算法 思想：选择计算代价较低的方法计算相似性，将相似的对象放在一个子集中，这个子集被叫做Canopy,不同Canopy之间可以是重叠的 算法步骤: Step1 设点集为 S，预设两个距离阈值 T1和 T2（T1&gt;T2）； Step2 从S中任选一个点P，用低成本方法快速计算点P与所有Canopy之间的距离，将点P加入到距离在T1以内的Canopy中；如果不存在这样的Canopy，则把点P作为一个新的Canopy的中心，并与点P距离在 T2 以内的点去掉； Step3 重复step2, 直到 S 为空为止。 该算法精度低，但是速度快，常常作为“粗”聚类，得到一个k值，再用k-means进一步聚类，不属于同一Canopy 的对象之间不进行相似性计算。 9.2 K-Means K-Means大家都比较熟悉，基本思想是首先找各个社团的“中心点”, 然后就近分配每个顶点 算法步骤：选取k个点作为 k个社团的初始中心点 Step1. 把每个点分配到最近的中心点所在的社团; Step2. 重新计算中心点，如果中心点不变, stop; 否则, 转 step1. K-Means算法计算量相对比较大，效果往往还不错，但是使用前要考虑一点：通过各个分量求平均得到的中心点是否有意义， 也就是说在你的问题中欧式距离是否有意义。 10. 基于密度的快速聚类 今年science上有一篇关于聚类的文章[9]，提出一种快速的聚类方法，基本思想是: 找出每个类的中心点，将剩余的点按一定策略分配到每个类中。思想很简单，但是文中找每个类中心点的做法还是很有新意的。 算法步骤 Step1 对每一个点i，计算两个量：点i的密度 和点 i 到比其密度更高的其他所有点的最小距离 Step2 选取 都较大的点作为每一社团的中心点(背后的思想是：类的中心应该密度比较大，不同类的中心相互之间应该离的比较远) Step3 对于剩余的非中心点，分配给离它最近且密度比它高的邻点所坐在的社团 参考文献 [1].Kernighan &amp; Lin ,An efficient heuristic procedure for partitioning graphs. Bell System Technical Journal 49: 291–307,1970. [2] Newman. Fast Algorithm for Detecting Community Structure in Networks. Phy.Rev.E, 2004. [3] Clauset et al. Finding community structure in very large networks, Phy.Rev.E, 2004. [4] Girvan&amp; Newman，Community structure in social and biological networks, PNAS, 2002 [5] Zhu et al . Learning From Labeled and Unlabeled Data With Label Propagation, Technical Report, CMU-CALD-02-107,2002 [6] Raghavan et al. Near linear time algorithm to detect community structures in large-scale networks, Phy.Rev.E., 2007. [7] P. Pons et al. Computing communities in large networks using random walks. Journal of Graph Algorithms and Applications,2006. [8] Vincent D. Blondel et al, Fast Unfolding of Communities in Large Networks, Phy.Rev.E, 2008 [9] Rodriguez &amp; Laio, Clustering by fast search and find of density peaks. Science.2014","categories":[{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/tags/算法/"},{"name":"图论","slug":"图论","permalink":"https://douxl5516.github.io/tags/图论/"}]},{"title":"shell脚本开发","slug":"shell脚本开发","date":"2019-09-22T05:50:43.000Z","updated":"2019-09-22T06:05:12.410Z","comments":true,"path":"2019/09/22/shell脚本开发/","link":"","permalink":"https://douxl5516.github.io/2019/09/22/shell脚本开发/","excerpt":"","text":"特殊变量 ？ 前一个命令的退出状态 $ 当前shell进程的PID - 当前shell启动时调用的选项 ! 在后台运行的上一个命令的PID 0 当前脚本的文件名 1-9 调用当前脚本时给出第1个到第9个命令行参数。$n是第n个参数的值 _(下划线) 传递最近调用的命令的最后一个参数 * 所有参数列表.如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数，此选项参数可超过9个。 @ 所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 # 添加到Shell的参数个数 # 流程控制 条件流程控制 123456789if some_condition then then-command(s)elif some_condition_2then then-command(s)else else-command(s)fi 条件控制 写法 ( test expression） [ expression ] 用途 文件检测 字符串检测 整数检测","categories":[{"name":"编程","slug":"编程","permalink":"https://douxl5516.github.io/categories/编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://douxl5516.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://douxl5516.github.io/tags/shell/"}]},{"title":"qiskit开发","slug":"qiskit开发","date":"2019-08-05T11:02:10.000Z","updated":"2019-09-02T13:41:46.832Z","comments":true,"path":"2019/08/05/qiskit开发/","link":"","permalink":"https://douxl5516.github.io/2019/08/05/qiskit开发/","excerpt":"","text":"名词 ancilla:virtual qubits (ancilla) that are specified in the layout, but not present in the circuit 三种simulator StatevectorSimulator：只执行一次QuantumCircuit，返回最终的statevector， UnitarySimulator：每个门都是对单位矩阵施加的酉矩阵操作，只包含门矩阵，不能包含reset或measure操作。 qasmSimulator","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"},{"name":"qiskit","slug":"qiskit","permalink":"https://douxl5516.github.io/tags/qiskit/"}]},{"title":"论文阅读-量子计算-ISCA-量子程序数据分析","slug":"论文阅读-量子计算-ISCA-量子程序数据分析","date":"2019-07-25T03:26:17.000Z","updated":"2019-07-27T06:19:56.477Z","comments":true,"path":"2019/07/25/论文阅读-量子计算-ISCA-量子程序数据分析/","link":"","permalink":"https://douxl5516.github.io/2019/07/25/论文阅读-量子计算-ISCA-量子程序数据分析/","excerpt":"","text":"Statistical Assertions for Validating Patterns and Finding Bugs in Quantum Programs","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://douxl5516.github.io/tags/论文阅读/"},{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"}]},{"title":"论文阅读-量子计算-DAC-QURE","slug":"论文阅读-量子计算-DAC-QURE","date":"2019-07-23T08:31:52.000Z","updated":"2019-07-27T06:19:48.389Z","comments":true,"path":"2019/07/23/论文阅读-量子计算-DAC-QURE/","link":"","permalink":"https://douxl5516.github.io/2019/07/23/论文阅读-量子计算-DAC-QURE/","excerpt":"","text":"QURE: Qubit Re-allocation in Noisy Intermediate-Scale Quantum Computers 不理解 蒙特卡洛方法 密度矩阵和kraus算子 线形排布的映射种数有：$(^NC_W)$ 名词定义 DOQA 前提知识 量子操作 量子操作（又称量子动态映射或量子过程）是对量子系统所能经历的一系列变换的数学表述。这一概念是由乔治·苏德尔辛（英语：George Sudarshan）在讨论密度矩阵的广义随机变换时首度引入。[1]量子操作的表述需要系统采用密度矩阵描述。严格而言，量子操作是一个密度算符集到其自身的线性完全正映射。在量子运算领域，量子操作通常称作**量子通道**（英语：quantum channel）。“量子操作”有时会被一些学者用来描述密度矩阵空间的完全正（英语：completely positive）或非迹增映射，而“量子通道”则特指其中严格的保迹映射。[2]量子操作不仅仅涉及孤立系统的幺正（英语：Unitary transformation）时间演化及对称变换，同时还涉及测量效应以及系统与环境间的暂态相互作用。 量子系统所能经历的一些过程并不能用量子操作描述[3]。原则上，量子系统的密度矩阵可以经过任意的时间演化。量子操作可以通过“量子仪器（英语：quantum instrument）”这一概念进行推广。量子仪器可以捕捉测量过程中量子信息外的经典信息。 定义 密度算符是带有单位迹的希尔伯特空间上的非负算符。 摘要 NISQ发展，量子位状态不稳定，易受影响。量子位和连接的错误率在空间上具有变化性。如果不考虑这些可变性，会导致可靠性差。在文章中，我们分析了一台实际NISQ的不同噪音源对总体可靠性的影响，提出了创新的优化技术：QURE来最大化可靠性。在模拟中提升1.54X，在实际中提升1.7X，不会产生物理开销。 简介 多种技术被用于构建量子计算机。量子计算机有如下错误 保持性错误 操作性错误 解决noisy的方法有： 建造更好的量子位 QEC 概率性，多次执行取最可能结果 验证了错误的变化性。提出了模拟框架。 提出了以下贡献： 构建量子程序模拟框架 启发式量子位分配 模拟和在量子计算机上实际操作的实验 建模和模拟 状态向量、模拟矩阵和可信度 使用复数系统表示，ket符号表示一个列矩阵的状态向量。 密度矩阵可以描述混合态，包含了不同纯态出现的概率。 Fidelity，保真度，度量两个量子态的相似度，对于相同态，为1。偏离程度越大，其值越低。 $$ F=\\operatorname{tr} \\operatorname{ace}\\left(\\sqrt{\\rho^{1 / 2} \\sigma \\rho^{1 / 2}}\\right) $$ 模拟噪声量子系统 门错误 1-p是经过X、Y和Z Pauli门之后系统维持正常状态的概率。经过一个门产生错误的概率为p/3。 门保真率：单量子位门为$1-\\frac{p}{2}$，双量子位门为$1-\\frac{3p}{4}$ T1错误 T1错误用振幅阻尼模型来模拟，也就是量子位从1衰变到0的模型。 出错概率记为$exp(\\frac{-t}{T_1})$ T2错误 T2错误用相阻尼模型来模拟。 经过退相位，纠缠态可能变为混合态。 出错概率记为$exp(\\frac{-t}{T_2})$ Kraus算子和表示 量子操作$\\mathcal{E}( )$可以映射输入态到输出态。其中$E_k$被认为是操作元素，通过合适的选择操作元素，可以表示量子门对一个量子位的操作。 $$ \\rho_{i n} \\mapsto \\mathcal{E}\\left(\\rho_{i n}\\right)=\\rho_{o u t}=\\sum_{k} E_{k} \\rho_{i n} E_{k}^{\\dagger} $$ 如果选择合适的Kraus操作符作为操作元素，则可以使用操作符和表示来模拟不同错误对量子位状态的影响。本文在适当的Kraus算子下，模拟了含噪声量子处理单元在门误差、T1弛豫和T2去相位条件下的行为。 模拟流 创建了基于Python的量子模拟平台。使用了QuTip中的模块来进行量子计算相关的矩阵操作。 输入为： 用密度矩阵格式表示量子位元的输入状态 1量子位门的错误率 对每对允许的操作的2量子位门的错误率 T1驰豫时间 T2退相位时间 1量子位和2量子位门时间 一个用特定硬件的门集编译的量子程序 采用Rigetti提供的数据进行模拟。对于第二项以后，不同机器的数据输入后，可以模拟不同的量子计算机。 采用Rigetti QuilC 编译器编译电路到指定的门集合。当时的QuilC编译器不能编译8Q架构，因此假设出了9Q，并对9Q提出了以下假设： 1-qubit gate error, T1 time and T2 time是其他8个量子位的平均数。 在Q4和其中一个最近的门之间的2-qubit gate-error and gate-time是任意两个相邻比特位的2-qubit gate-error and gate-time的平均值 模拟器读取程序并执行，执行后，对一份结果按概率注入错误，最终对比正确结果和错误结果，得到可信度。 噪声源的相对影响 采用蒙特卡洛方法，对于每一种噪声，都生成了置信度的分布。置信度分布的均值等于各个错误发生概率的均值，标准差是均值的10%。 对于QF3，2比特位门置信度最低，其次：1比特位门，T2，T1。 对其他的也做了实验，Hamming - 3, QFT - 5, Graycode 6, and QFT - 7,找出了对应的平均置信度。 二比特位门错误对所有的样例造成的错误都最多。 层次越深的样例，去相关造成的影响更大。 应该： 减少深度 选择具有更好平均门置信度的量子位 在硬件上实施量子电路 硬件无关的量子电路 Hardware Agnostic Quantum Circuits (HAQC)，采用高级量子门，对人类友好。 线路编译 量子计算机都有可用的门集，因此高层HAQC被首先编译为考虑量子计算机可用门集的量子程序。 量子位分配映射 逻辑程序被映射到物理量子计算机上。不相邻的可以用SWAP操作使其挨在一块。 depth optimal qubit allocation (DOQA)。之前的方法强调使SWAP数最少，使深度最小。但现在有了VQA。但是VQA没有考虑到SWAP层数增加而导致的decoherence errors，因此文章提出了一种深度优化的量子位分配策略。 QURE 同构子图可以帮助减少搜索空间 子图搜索 步骤有： 找到所有IM的同构子图 提供保真性最大的子图 找同构子图 coupling graph 是无向图。但是近期的量子计算机都是grid型的物理架构，因此，其内部节点有一个特性，即相邻节点数都相同。这个发现可以减少搜索同构子图的时间空间复杂度。 步骤： 在使用DOQA方法获取到初始化应设置后，从coupling graph提取一个方形的格子架构，这个格子架构足够实施给定的工作负载，将其称为V-Grid。将其旋转90度，称为H-Grid。如果提出来的格子是一个正方形，那么V和H代表同样的架构。在每个V和H中，给定的工作负载至少能以四种方式（沿X和Y轴做镜像映射）被映射。 我们计算QC中的V-Grids和H-Grids。让QC中的量子位在横竖方向的数目为QH和QV。V-Grid中的量子位在横竖方向的数目为VQH和VQV。H-Grid中的量子位在横竖方向的数目为HQH和HQV。那么有：the number of uniquely fitted V-Grid (NVG) and H-Grid (NHG) within the QC $$ NVG=(QH-VQH+1)(QV-VQV+1)\\ NHG=(QH-HQH+1)(QV-HQV+1) $$ total number of unique mapping (NISG) 代表总的映射种类数。 $$ NISQ=\\left{\\begin{matrix}4(NVG+NHG),&amp;VQV,VQH,HQH,HQV&gt;1且VQH!=HQH\\ 4NVG,&amp;VQV,VQH,HQH,HQV&gt;1且VQH=HQH \\end{matrix}\\right. $$ 如果VQV,VQH,HQH,HQV中任意一个等于1，则是线性的，这样子最多的映射种数有：$(^NC_W)$ 找近似全局最优解 暴力方法全部搜索。成功率为： $$ S P=\\prod_{i=1}^{N}\\left(1-\\eta_{i}\\right) $$ $\\eta_{i}$是第i个门操作的错误率，根据模拟出的错误率p来计算。 单比特位门： $$ \\eta=3 p / 4 $$ 双比特位门： $$ \\eta=15 p / 16 $$ 两种评估方式的峰谷都相同，因此可以作为评价标准，在大图中可以使用模拟退火算法来实现寻找最大可信度。 贪婪算法 将所有的物理量子位按照它们的平均二量子位门可信度来进行排序。 将所有程序中的量子位按照二量子位门操作个数进行排序。 During the allocation process, we need to maintain the lists of Assigned_Physical_Qubits, andAllocated_Loдical_Qubits with two ancillary lists unallocated (logical) neighbors and unallocated physical neighbors. Initially, these lists are empty. At the start ofeach iteration, we find the unallocated neighbors of the Allocated_Loдical_Qubits. IfAllocated_Loдical_Qubits is empty, we select all the logical qubits in the workload (q0, q1, q2, q3) as the unallocated neighbors. We pick the logical qubit from the list of unallocated neighbors with the highest rank. We find the logical neighbors of the selected qubit (for LNN it can be at most 2) and check whether they are already allocated or not. If one of them is allocated, we find its unallocated physical neighbors (UPN), if both are allocated, we set UPN to their common unallocated physical neighbors, otherwise, we set UPN to all the currently unallocated physical qubits. We pick the physical qubit from UPN with the highest rank and assign it to the selected logical qubit. Then we add the selected logical qubit to Allocated_Loдical_Qubits and the physical qubit to Assiдned_Physical_Qubits before moving on to the next iteration. We stop when the length ofAllocated_Loдical_Qubits is equal to the number of logical qubits.","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://douxl5516.github.io/tags/论文阅读/"},{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"}]},{"title":"学术论文中的英文表达","slug":"学术论文中的英文表达","date":"2019-07-21T12:57:37.000Z","updated":"2020-01-02T08:22:33.496Z","comments":true,"path":"2019/07/21/学术论文中的英文表达/","link":"","permalink":"https://douxl5516.github.io/2019/07/21/学术论文中的英文表达/","excerpt":"","text":"prioritize state-of-the-art twice as many number respectively pair wise Whereas infrastructure benchmark identical merit figure of merit in the stage of infancy representative application-agnostic fidelity crucial hurdle exploit Iterate through all the layers temporal spatial Figure-of-Merit that using cost function and heuristics based on the number of hops or Manhattan distance Revised in terms of overhead outperform analogous fidelity address these drawbacks mentioned above trade-off leveraging overhead mathematically equivalent unitary implies that accounts for dictates comprised of resultant metric：度量标准 leads to mitigate：缓和 cascade Algorithms exist that does：主语从句 Concerted efforts by error-prone corroborate to To this end emulate delineate pertinent to paramount inflection On the flip side crop up We determine X describing to which physical qubit alogical qubit is mapped scrutinize","categories":[{"name":"英语","slug":"英语","permalink":"https://douxl5516.github.io/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://douxl5516.github.io/tags/英语/"},{"name":"论文","slug":"论文","permalink":"https://douxl5516.github.io/tags/论文/"}]},{"title":"2019-07-21-论文阅读-量子计算-ISCA_2019_Kaitlin","slug":"论文阅读-量子计算-ISCA-2019-Kaitlin","date":"2019-07-21T05:53:18.000Z","updated":"2019-07-27T06:19:40.249Z","comments":true,"path":"2019/07/21/论文阅读-量子计算-ISCA-2019-Kaitlin/","link":"","permalink":"https://douxl5516.github.io/2019/07/21/论文阅读-量子计算-ISCA-2019-Kaitlin/","excerpt":"","text":"A Quantum Computational Compiler and Design Tool for Technology-Specifific Targets 前提知识 酉矩阵 一个矩阵的共轭转置和它的逆相等。 即： $$ U^{-1}=U^{\\dagger} $$ $$ U^{H} U=U U^{H}=E_{n} $$ 其中，$U^{H}$为$U$的共轭转置，$E_n$为n阶单位矩阵。 不理解 Local optimizations based on removing partitions of gates that equal the identity function are implemented recursively until technology library cost function cannot be further reduced.（P6） single-target gate？ 关键词汇理解 technologically-independent：技术无关，即没有映射到实际量子计算机，不考虑量子计算机实际物理体系结构的 technology-dependent ：考虑量子计算机体系结构的 Quantum Multiple valued Decision Diagram (QMDD)，量子多值决策图 quantum information processing（QIP），量子信息处理 quantum operator=quantum gate connectivity tree reroute algorithm（CTR），连接树重新路由算法 switching functions，可逆的二进制转换函数，即量子电路 摘要 为了充分利用量子计算机性能，编译器需要对细节做优化，将量子程序映射到实际结构上。现有的大多数技术并没有考虑量子计算机本身的特点。我们的方法基于实际架构的约束来执行。这个工具基于实际结构执行优化，具有高质量的架构相关的映射结果。并进行了数学方面的等价检查，使我们的映射结果与原有算法等价。 简介 QC体系结构各不相同，需要特殊的技术使合成工具能够将广义量子线路映射到特定QC体系结构上。这个工具需要重新配置一个量子线路，让一个量子计算机上的可执行的量子线路映射到另一个设备上。该技术促进了量子逻辑自动转化工具的发展、硬件编译器的发展。技术利用形式等价性验证产生的物理映射结果和最初的逻辑线路是否相等。该技术也可以自动优化逻辑线路。 过去已经产生了可逆逻辑、考虑架构限制的网格模型量子结构、单双量子门。 此处讨论的特点是： 逻辑量子线路被映射到物理量子线路的体系结构上。 形式等价性检查，确认生成的最终电路在功能上与原始形式等价。 通过形式验证达到了高效的量子线路合成和映射。编译过程中，实现了量子多值决策图（QMDD），用于电路等价性检查。 原型工具实现了对原始量子线路图到实际量子计算机上的量子线路图的映射、优化和验证转换。文中以IBMQ系列量子计算机为例，是因为这些计算机提供了他们具体的架构，但本文工作也可以用于其他的架构，因此是模块化的。 第2节提供了量子逻辑，计算和操作的背景信息，并介绍了QMDD数据结构。 第3节描述了IBM量子机器和工具。 第4节概述了基于量子计算机物理体系结构的量子逻辑综合和编译的方法。第5节回顾了实验结果。第6节得出了当前研究的结论，并详述了量子合成和编译工具的未来发展和改进。 背景 量子计算 叠加态和纠缠态在经过观测后消失 量子算子表示量子态的特定时间演化，从而有目的地转换量子位状态，从而产生有意义的QIP。如果将量子算法建模为一个电路，那么量子运算可以看作是量子逻辑门。 量子位多，退相干性高，superconducting solid-state qubits是目前效果最好的量子位实现手段。 量子费用 维持量子在计算中的稳定性是非常重要的 减少操作数是非常重要的 提出了量子位费用，其中T门为三比特位操作，额外成本设为0.5，C门额外成本为0.25，量子成本越高说明退相干可能性越大。 $$ q_{c o s t}=0.5 \\times t+0.25 \\times c+a $$ 可逆逻辑 可逆逻辑指的是理论上可以通过反向执行算法来恢复输入信息的实现 为了实现可逆性，要求输入和输出端口相同，输入输出有闲余端口用于维持可逆性。编译和优化工具的优化目标是：在维持可逆性的前提下，最小化闲余端口。 与QIP操作对应的状态转换被建模为酉转换，及具有可逆性。 希望可以实现用户输入不可逆算法，由工具转换为可逆。 存在将二进制切换函数变成可逆函数的算法，一旦转换了切换功能，就可以将它们转换成QIP电路或QC程序，以便在量子机器上进行评估。 所有的QIP和QC过程在逻辑和物理上都是可逆的，这是量子力学假设和公理的结果。 对应于QIP操作的状态变换是酉变换。 一种方法：对输入的以ESOP形式表达的转换函数进行转换，转换为可逆的Toffoli流的形式。占用时间短。 后来的一项工作，包含了ESOP的工作，使用决策图（DD，decision diagram）来进行表示。一个顺序二维决策图用一堆不相交的立方体表示了一个不可逆函数。 现有的量子合成工作使用诸如ESOP和DD表示之类的技术将经典规范转换为可逆逻辑[2,6]，但由于可逆逻辑在实际QC上是不可实现的，因此产生的输出与技术无关。 量子多值决策表 对于n个量子位的逻辑门需要的酉矩阵大小为$2^n\\times 2^n$ QMDD可以用有向无环图表示量子逻辑门，类似空间八叉树。 量子多值决策表被用于等价性检测，因为对于初始量子线路和映射到物理量子线路上的量子程序，只要操作顺序不变，量子多值决策表是相同的。 IBM Q 可以讲IBM Q系列表示为一个字典，键为CNOT的控制位，值列表为CNOT控制位对应的目标。 设计了一个称为“耦合复杂度”的度量，用于描述物理量子位的耦合复杂度。 将耦合复杂度定义为耦合映射中发现的允许CNOT耦合数量与量子机器的所有量子的二排列之比。越接近1，两个量子位互联的可能性更高。 ibmqx2 = {0:[1,2], 1:[2], 3:[2,4], 4:[2]} $complex=\\frac{6}{C_5^2}=\\frac{6}{20}=0.3$ 量子逻辑合成方法 最终量子程序要以量子汇编语言展示。 前端接受多种输入，包括经典的开关函数，前端都会对其进行处理。 前端的处理结果是一个与实际物理量子设备无关的可逆表示。 前端生成的可逆表示被后端的设计工具处理。 后端进行转化和优化，映射到一个具体的物理量子机器上。 后端可以进行多量子位门的分解，也进行了两量子位操作的优化。 多量子位操作在物理上难以实现，分解的方法是必要的。树的数据结构有助于为CNOT找到最短的SWAP路由。 CRT算法被用来自动路由不符合硬件条件的CNOT操作。基于耦和图的树结构决定了SWAP操作的最短路径。 SWAP操作继续移动控制量子位，直到可以在指定目标上执行所需的CNOT操作。 在执行CNOT操作之后，控制量子位反向遍历SWAP路径以返回其原始位置，以便保留电路中的原始量子位分配。 构建CRT 树时，只要两者之间有连接，即可构建CRT树枝，因为CNOT其实可以通过四个H门进行转向。 后端构建基于实际架构的QASM，主要符合两个方面：1.符合物理架构2.最小化量子代价 实现了以下的映射和优化过程：1.CNOT可翻转。2.CTR用于路由不直接连接的量子位。3.广义Toffoli门被分解为Toffoli流。4.将Toffoli操作分解为一个和两个量子位操作符。5.在不能进一步降低技术库成本函数之前，将递归地实现基于删除等同于标识函数的门的分区的本地优化。6.在不能进一步降低技术库成本函数之前，递归地实现基于移除逻辑上相同的电路标识可以最小化的门分区的局部优化。 所有的综合优化程序完成后，调用形式验证，使用QMDD进行等价测试。非常重要，因为验证了工具的转换和优化不会改变算法逻辑。 实验 负责映射和优化，用于合成和编译的后端工具使用Python完成。 工具的目的是使用经典的计算方法，而不是模拟量子算法，来合成依赖于技术的算法。 工具可以对IBM Q系列设备、和自己提出来的96qubits设备进行计算，可直接在个人电脑上进行计算。 benchmarks：Optimal Single-target Gates，大小为3-6。他们中药师因为他们被作为查表法的的重要部分 单目标门可以被分解为一个和两个量子位操作。作为独立于物理线路的.qc文件被输入到合成工具中。 映射到模拟器时，是和物理线路无关的。 模拟器的结果是一个技术独立的线路，考虑了T数和总门数，没有考虑多比特位操作要放在哪。 在没有被物理线路限制的情况下，基准线路的量子位和连接已经是最精简的了，经过基于费用的优化和映射，其门数和成本函数并不会减少。 不被物理结构支持的门需要被分解或重路由，具有低“耦合复杂度”的线路往往需要更多的门来实现技术相关的映射。 映射结束后，结果线路可能被内建的局部优化器优化。","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://douxl5516.github.io/tags/论文阅读/"},{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"}]},{"title":"论文阅读_量子计算_1809.02573v2","slug":"论文阅读-量子计算-1809-02573v2","date":"2019-07-19T12:05:39.000Z","updated":"2020-01-27T15:24:06.179Z","comments":true,"path":"2019/07/19/论文阅读-量子计算-1809-02573v2/","link":"","permalink":"https://douxl5516.github.io/2019/07/19/论文阅读-量子计算-1809-02573v2/","excerpt":"","text":"Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices 问题 不理解的名词 保留遍历搜索技术 全局优化初始映射 名词 quantum circuit：量子线路，是在抽象概念下，对量子信息存储单元进行操作的线路。组成包括：量子位、线路（时间线）、逻辑门。 Directed Acyclic Graph：DAG，有向非循环图 摘要 由于对量子计算的硬件条件考虑不足，比如说没有考虑二量子位操作的物理连接不足的问题，一般的NISQ无法执行大多数的量子算法。动态重映射策略被创建，来解决这些问题。但是动态重映射策略不能保证程序的可靠性，策略复杂度高，初始映射差，可控性和灵活性低。 提出了一种基于交换的双向启发式搜索算法(SABRE)，适用于量子位任意连接的NISQ设备。通过优化每一次搜索尝试，采用新型的反向遍历技术，全局优化了初始映射。引入了了衰减效应，能够衡量搜索的深度和整个系统的门的个数。SABRE比其他的已知最好的指数级算法好一些。 介绍 量子计算机虽然无法实现QEC，但是也可以干很多事情。软硬差距存在，现有的NISQ体系结构无法支持大型量子程序有效执行。本文章专注于由于NISQ设备限制而产生的二量子位操作问题。逻辑量子位分配到物理量子位上，类比传统计算机就是寄存器分配。 实际量子线路无法直接在NISQ上执行，因此需要进行量子电路转换，实现量子程序在NISQ设备上的使用，步骤有： 初始逻辑量子位到物理量子位的映射 映射变换，使要进行门运算的两个逻辑量子位重映射到两个相邻物理量子位上。 之前的方法有： 构建数学问题，采用求解器解决。缺点是求解速度慢，只能对小规模数据使用，不能利用问题内部特征。 启发式搜索算法，大多数是在理想的1D / 2D晶格模型上开发的，不适用于具有更多不规则和受限制的耦合连接的NISQ器件。 针对IBM QX的搜索算法，穷尽搜索，运行速度慢，缺少全局优化能力，在多目标优化条件下，无法保证生成的量子电路的质量。 本文提出了： 基于交换的双向启发式搜索算法，解决量子位映射问题。 穷尽搜索很多步骤是多余的，SABRE方法大量减少了搜索空间。 初始化映射极为重要，可以影响最终电路质量。采用创新的保留遍历搜索技术。通过遍历反向电路，可以产生高质量的初始映射。在这个过程中更重视电路开始的位置，不忽视电路其他部分。 引入衰减效应，可以使重叠的SWAP操作造成启发式代价函数值变高，因此更支持不重叠的SWAP操作。这种优化可以鼓励并行性，并且可以在电路深度和门数之间进行权衡，从而进一步生成不同的硬件兼容电路。 本文贡献在于： 对基于启发式搜索算法的量子位映射问题总结了目标和度量标准 提出了基于SWAP的搜索模式，比穷尽搜索模式优秀，允许向NISQ时代的可扩展性。 提出了反向遍历策略，利用量子位映射问题的内在可逆性，在初始映射解决方案中实现全局优化。 在启发式搜索策略中提出衰减代价函数，能产生适用于不同硬件的量子电路。 背景 软件基础 多种量子模型是数学等价的，量子电路模型是最流行的。 量子位 量子操作 量子线路 在NISQ时代的QC硬件 实现量子计算的硬件方法有：超导量子电路、离子阱、量子点、中性原子等。目前最可靠的技术是超导量子电路。 文章中考虑硬件约束包括： 量子位生存时间 量子位操作错误率，因为量子门会导致错误，因此要尽可能缩减量子门的数目 量子位连接。 问题分析 SWAP操作解决不连通问题 其他方法解决不连通问题：基于先前的架构，不予考虑。 SWAP操作带来如下问题：操作指令数增加，导致总体错误率增加；电路层次增加，总执行时间增加，由decoherence导致的错误增加。由此要尽量减少SWAP操作个数。 构建问题 找初始mapping、中间mapping的变换，最小化门操作个数，最小化量子线路层次。 目标和度量标准 灵活性：对以后的量子计算机也需适用 可靠性：要尽量减少门个数 并行性：减少量子线路层次，允许更多的操作 可扩展性：在不使用QEC的情况下，问题是不变的。使用了QEC，会将问题转化为另一个。 度量标准：门总数和量子线路深度。 找初始化映射和SWAP 预处理 使用Floyd-Warshall算法计算距离矩阵 使用有向非循环图（DAG）表示在一个量子线路中的双量子比特位门的执行限制。单量子位的操作在这不予考虑，因为他们不涉及到其他量子位。 找到第一层：没有前驱节点，即入度为零的控制非门可以被放在第一层中。 临时初始映射生成：随机产生初始映射，作为启发式搜索的起始状态。 基于SWAP的启发式搜索 算法1是一次遍历的搜索过程，从头到尾扫描，并插入SWAP操作，使得所有的CNOT都可以被执行。这个算法会被多次使用来更新优化初始映射。 拓扑排序方法 检查F是否为空，若是，则停止，若否，则初始化Execute gate list。 对于F中现在的所有的门，取出这个门涉及到的两个量子位，查看他们所在的物理量子位有没有连接，如果有，则加入Execute gate list，否则不加入。 如果Execute gate list不为空，则将里面的所有门从F中删除掉。接下来检查后继的门，对于后继门的两个量子位，如果如果F中没有任何门指向这两个量子位的其中一个，则把这个后继门添加到F中。回到2。 如果Execute gate list为空，则所有的F中的门在硬件中不能被执行。需要插入SWAP操作。 启发式搜索插入SWAP：初始化score。通过F和G找到SWAP的候选列表。对于F中的所有门的所有程序量子位，找到它对应的物理量子位，通过G找到和这个物理量子位相邻的其他物理量子位，根据映射找到这些物理量子位对应的程序量子位。原量子位和这些程序量子位可以被进行SWAP。加入到候选SWAP列表中。对于候选列表中的每一个候选SWAP，更新原映射，作为临时图，对其进行评分，选择评分最小的SWAP操作，并将原映射更新。回到1。 在这里每次启发式搜索只搜索一步SWAP，下一次可能还是处于EExecute gate list为空的状态，这样就需进行下一步的启发式搜索，如果不为空，则可以继续进行拓扑排序。 算法中： Front layer F：其中的门都可以在逻辑上被执行 Mapping $\\pi$：表示了从逻辑量子位到物理量子位的映射 Distance Matrix D：表示了两点间最少的SWAP数 Circuit Dag：有向无环图，代表量子线路结构 Chip Coupling Graph G：无向图，代表任意两个物理量子位之间的连接 算法的优势： 不是去搜索一个映射，而是去搜索在F中的量子位的SWAP。 解释关键设计决策 只有F中的门涉及到的量子位元参与的SWAP才有意义。 F后紧邻的量子位的距离也加入启发式函数的考虑，但不考虑再后面的，因为执行过程中，mapping的变化可能会很大。 时间复杂度分析（暂不理解） 时间复杂度上限可以通过最坏情况来估计，也就是每两个比特位门都需要单独满足。 满足一个比特位门的时间复杂度是满足在搜索空间中的潜在选项、最大可能搜索空间、二比特位最大数目的搜索步数的一次搜索的乘积。启发式代价函数的时间复杂度是O（N）。 搜索空间从可以从O(exp(N))降到O(N)（最坏情况下所有量子比特位都在首层）， 初始映射的反遍历 Siraichi没有考虑时间因素，Zulehner只考虑了最初映射，没有全局考虑。 量子电路是可逆的，可以获取到一个量子电路的逆电路。如果知道了最终电路，我们就可以把最终电路作为初始电路，解决映射问题。如果一次执行完成，得到的结果映射，可以作为我们开始执行时的初始映射，这样能够提供更好的效果。 首先随机生成初始映射，进过原量子线路，获得最终映射。将最终映射通过反向量子线路，获得更新后的初始映射。更新后的初始映射就在以后被作为优秀的映射方案。 量子线路深度和门数的衡量 深度优先 门数少优先 衰减效果被应用，来尽可能选择不相交的SWAP操作。 启发式函数设计 H应该能代表SWAP的移动步数 能够帮助后期的SWAP采用更少的步数 能够鼓励并行操作，考虑线路深度和并行度的取舍。 设计： F中所有元素对之间的距离和（来自Distance Matrix） 扩展集中的距离和 swap是否被重复使用 $$ H=\\max \\left(\\operatorname{decay}\\left(SWAP . q_{1}\\right), \\operatorname{decay}\\left(SWAP . q_{2}\\right)\\right)\\ *\\left{\\frac{1}{|F|} \\sum_{g a t e \\in F} D\\left[\\pi\\left(g a t e \\cdot q_{1}\\right)\\right]\\left[\\pi\\left(g a t e . q_{2}\\right)\\right]\\ +W * \\frac{1}{|E|} \\sum_{g a t e \\in E} D\\left[\\pi\\left(g a t e . q_{1}\\right)\\right]\\left[\\pi\\left(g a t e . q_{2}\\right)\\right] \\right} $$ 总结 物理量子位不能比程序量子位少 有限的物理连接","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://douxl5516.github.io/tags/论文阅读/"},{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"}]},{"title":"论文阅读_量子计算_ASPLOS_2019_1","slug":"论文阅读_量子计算_ASPLOS_2019_1","date":"2019-07-17T10:57:39.000Z","updated":"2019-08-05T11:13:34.576Z","comments":true,"path":"2019/07/17/论文阅读_量子计算_ASPLOS_2019_1/","link":"","permalink":"https://douxl5516.github.io/2019/07/17/论文阅读_量子计算_ASPLOS_2019_1/","excerpt":"","text":"Not All Qubits Are Created Equal 前提知识 希尔伯特空间(Hilbert Space) 希尔伯特空间是复向量内积空间。 内积空间是两个向量上的函数并返回一个标量的二元运算，它的结果是欧几里得空间的标准内积。 一个量子系统的态空间一般用有限维度的Hilbert空间来表述，即可以用来表述量子系统的各种可能的量子态。 量子两个基本状态 叠加态 量子叠加态就是一个量子能在同一时间处于两种不同属性0和1的状态，而对于经典物理中，一个粒子只能处于一种状态，如要么左旋，要么右旋。 纠缠态 量子纠缠态，就是满足一定条件的情况下一个量子的行为将会影响到另一个量子的状态。即其中一个量子被操作改变而发生状态变化时，比如进行量子观测时，一个量子被观测为左旋。则另一个量子其状态立即发生相应的状态变化。而两个量子之间不存在一定相同或者相反的绝对规则。因此两个被纠缠的粒子可以是状态相同，也可以是状态相反。 Bloch 球面 百度百科 对量子位元这样的二阶量子系统而言，其存在的可能状态 $ |\\psi\\rangle $可以由两个互相正交的基底以复数线性叠加所构成，这两个基底可以选用$|0\\rangle,|1\\rangle$为代表。在物理实作上,$|0\\rangle,|1\\rangle$代表了做投影式量子测量所会得到的唯二结果。 从任意纯态出发，有： $$ |\\psi\\rangle=\\alpha|0\\rangle+\\beta|1\\rangle, \\alpha, \\beta \\in \\mathbb{C}, \\quad|\\alpha|^{2}+|\\beta|^{2}=1 $$ 可设： $$ \\alpha=\\cos \\theta e^{i \\delta} $$ $$ \\beta=\\sin \\theta e^{i(\\delta+\\phi)} $$ 有： $$ |\\psi\\rangle=\\cos \\theta e^{i \\delta}|0\\rangle+\\sin \\theta e^{i(\\delta+\\phi)}|1\\rangle= e^{i \\delta}\\left(\\cos \\theta|0\\rangle+\\sin \\theta e^{i \\phi}|1\\rangle\\right) $$ $e^{i \\delta}$称共同相位，可以省略。$e^{i \\phi}$称相对相位。有： $$ |\\psi\\rangle=\\cos \\theta|0\\rangle+\\sin \\theta e^{i \\phi}|1\\rangle $$ 因$cos\\theta$和$sin\\theta$为长度，所以都为非负实数，可以确定： $$ 0 \\leq \\theta \\leq \\frac{\\pi}{2} \\Rightarrow 0 \\leq 2 \\theta \\leq \\pi, \\quad 0 \\leq \\phi&lt;2 \\pi $$ $x=\\sin 2 \\theta \\times \\cos \\phi$的所有分布在三维空间中画出来，即布洛赫球面。 $$ \\begin{array}{rlrl}{x} &amp; {=} &amp; {\\sin 2 \\theta \\times \\cos \\phi} \\ {y} &amp; {=} &amp; {\\sin 2 \\theta \\times \\sin \\phi} \\ {z} &amp; {=} &amp; {\\cos 2 \\theta}\\end{array} $$ 欧拉公式 $e^{ix}=cosx+isinx$ 得到一个模为1的复向量,$x$是向量的角 k-core 一个图G的 KCore 是G的子图 这个子图的每个顶点的度≥K 计算方法 每个顶点记录is_delete，current_degree 如果一个顶点的度数小于k，则从图中删除该顶点，给邻居发消息 顶点收到消息之后，更新自己的度。 论文阅读 待了解 希尔伯特空间 Bloch球面 k-core算法 问题 noisy是什么意思？ SWAP操作如何理解？和量子纠缠的关系是什么？ baseline mapping policy中 普通方法与本论文的本质区别在哪里？普通方法也知道有错误率，但是认为普通方法的错误率是全局一致的。 Algorithm2 中的量子位活动是什么？ error-configs？ 量子程序中的Cx代表什么意思? Fig15中的执行过程是怎么回事？其中的SWAP操作为什么是3次方的失败概率？ 概念 NISQ： Noisy Intermediate Scale Quantum computers，噪声中尺度量子计算机，具有10至1000量子位。容错率低，但能为量子应用提供一些优势。 Qubit-Allocation：处理程序量子位到物理量子位的映射问题。 Qubit-Movement：选择将一个量子位状态移动到另一个量子位状态的路径的问题 量子纠缠：两个暂时耦合的粒子，不再耦合之后彼此之间仍旧维持的关联。通过“2量子位操作完成”。如果两量子位不存在connection，可以通过swap操作，使得两量子位挨在一起，之后通过2量子位操作完成量子纠缠。 VQM：Variation-Aware Qubit Movement，可变感知量子位移动 VQA：Variation-Aware Qubit Allocation，可变感知量子位分配 qubit device：量子位设备 QEC：Quantum error correction codes，量子位防止错误的方法：量子误差校正码 SWAP操作：量子计算机中，用来交换两个量子状态的操作，即量子纠缠 data qubit：量子位数据 phycal qubit：物理量子位 PST：Probability of Successful Trial，成功试验概率，表示程序在没有任何错误的情况下成功完成的概率，用于度量量子计算机性能 量子门 (Quantum gate，或量子逻辑门)是一个基本的，操作一个小数量量子位的量子线路 ，使用酉矩阵表示。 Coherence Time：相干时间，一个物理量子位保持一个数据所能持续的时间 Operational errorrate：操作错误率定义为在执行操作时引入错误的概率 ANS,aggregate node strength，$A N S=\\sum_{i}^{k} d_{i}$ where $d_{i}=\\sum_{j}^{N} w_{i j}$ activity，(total number of CNOT operations) benchmark：标准检查程序 STPT，Successful Trials per Unit Time，单位时间成功尝试次数 摘要 现有量子计算机的不足：容错性不好。造成容错性不好的原因是： 量子位数太少 系统噪声大，工作不稳定 NISQ应运而生（量子位相对较多），本paper研究量子位分配和量子位移动。 不同的量子位和不同的量子位间的连接（link）拥有不同的错误率，这可能会影响量子位元移动和量子位元分配的**&lt;u&gt;决策&lt;/u&gt;**。因此作者分析了IBM-Q20的公开可用的特性数据，确实发现了上述差异，确定了&lt;u&gt;设备&lt;/u&gt;的变异性对整个系统的可靠性有重要的影响。 为了利用**&lt;u&gt;错误率&lt;/u&gt;**的可变性，作者提出了 可变感知量子位移动(VQM) 可变感知量子位分配(VQA) 这些策略可避免较弱的量子位和链接，鼓励更多的操作向较强的量子位和链接发展。 基于IBM-Q20仿真模型，变量感知策略可以将系统可靠性提高1.7倍。基于IBM-Q5，可靠性可高达1.9倍。 介绍 量子计算机： 能够加速求解普通困难问题的求解，如： 素因子分解 模拟物质和化学反应 通过创建纠缠集合状态实现运算，创建纠缠集合所用到的操作是：“两量子位操作”，这个操作只能对有**&lt;u&gt;联系&lt;/u&gt;**的量子位元进行。 量子算法 利用叠加和纠缠的性质，依靠量子运算来改变量子位元的状态。 历史 过去20年：从理论模型到被实践 过去2年：各公司设计出了量子计算机蓝图 过去10年：一致性时间（coherence times）从1纳秒上升到了100微秒 量子位 具有易变的特性，因为：退相干和操作错误 具有避免错误的方法，即：QEC，但QEC有不足：需要10-100个物理量子位元来编码一个容错量子位元。当前有数十或数百量子位的计算机因量子位限制，不能使用QEC。 VOM and VOA VOM 以前的做法是让SWAP次数更少的路径 选择成功率最高的纠缠路径 VOA 以前的做法是选择让SWAP次数更少的的放置位置，这些研究假设了swap代价均等 将数据量子位放置在成功率更高的的物理量子位上 需要考虑量子位设备的多样性，认为SWAP操作代价不等 文章工作 给出了所有20个量子位的相干时间统计量，执行单量子位运算时的误码率，以及在不同量子位上执行双量子位运算的误码率。 证明确实不同的量子位和连接是存在差异的。 提出Variation-Aware Qubit Movement：如果想对两个数据量子位进行纠缠，VQM方法会找出是成功率最高的path，而不是SWAP最小的path 提出Variation-Aware Qubit Allocation：在将数据量子位映射到物理量子位上时，选择最强的链接，提升系统整体的可靠性。 背景和动机 量子计算背景 传统计算机的一个位可看做球体上的南北两极，而一个量子位代表的数据可看做在一个球面**&lt;u&gt;（布洛赫球面）&lt;/u&gt;**上的任意一点 量子操作：将一个量子位从球面上的一点移动到另一点 存储和操作量子位是量子算法的关键 量子纠缠是创建有联系的量子位之间的集合状态的操作 量子纠缠通过“二量子位操作”完成，例如控制非门 IBM量子机中，两量子位比特操作通过他们之间的连接环（coupling-link）完成。 超导量子计算机通常不会采用全互联量子位，而是采用一种受限制的网络，如mesh，只在相邻的量子位之间连接。 SWAP操作可以交换邻接的量子位位，能使任意两个量子进行纠缠，SWAP可以通过三个控制非门完成 量子计算机中的错误 很有可能因为量子设备的环境发生变化而产生错误 分类：连贯性错误和操作错误 连贯性错误：量子位只能在有限时间内保持数据，高能状态$(|1\\rangle)$总会向低能状态$(|0\\rangle)$衰变。与这种衰变相关的时间常量被称为T1相干时间（T1 Coherence Time）。T1表示一个量子位自然放松的时间。T2表示被环境影响的量子位放松时间。 操作错误：量子操作不精确，不完美，可能导致错误。操作错误率定义为在执行操作时引入错误的概率。单量子操作错误率量级：$10^{-3}$，双量子操作错误率量级：$10^{-2}$。本文主要研究双量子操作错误。 近期的量子计算机 QEC可实现错误免疫，但一个容错量子位需要10x-100x物理量子位来编码。现阶段量子位少的量子计算机（NISQ）无法实现QEC。 大程序需要几百万量子位，已存在或近期的量子计算机无法达到。对只需要几十位的量子程序，错误更正无法达到。 NISQ没办法执行错误更正，但能执行有用的工作。 可通过多次执行，根据大数定律可知，一个事件出现的次数与实验总次数比值随着实验次数的增加，趋近于事件的概率。 量子位元之间有限的连通性 若实现量子位全连通，连接需$O(N^2)$，不可行。 连接包括导线、以特定频率工作的谐振器，使连接做到可靠，是一项艰难的任务。因此大多量子计算机使用网格网络。 由于使用网格网络，所以产生了两个子问题：Qubit-Allocation：处理程序量子位到物理量子位的映射问题。Qubit-Movement：选择将一个量子位状态移动到另一个量子位状态的路径的问题。 Qubit-Movement 策略：此策略决定在将数据从芯片上的一个位置移动到另一个位置时应该使用的路由。 Qubit-Allocation 策略：该策略决定程序量子位元到数据量子位元的初始映射。经常通信的量子位元最好放在彼此附近。 本文工作采用Zulehner开发的编译器，对于给定链接的量子程序进行编译，生成指令队列、SWAPs和初始量子位映射。他开发的编译器采用贪婪算法减少SWAP次数，在执行交换操作时，用于qubit移动和qubit分配的基线策略假定统一的成本(特别是可靠性影响)。但是不正确，会有易变性。 分析 IBM-Q20 中的可变性 相干时间分布 标准差是离均差平方的算术平均数的平方根。平均偏差是数列中各项数值和其对应的算术平均数的离差绝对值的算术平均数。 单量子位位操作错误率 IMB量子计算机中的量子位操作是通过在量子位元装置上应用具有一定持续时间和频率的微波信号来实现的。但量子位器件是高度非线性的，微小的扰动或实验条件都会引起器件特性的漂移。 单位操作比双位操作更加稳定。 双量子位位操作错误率 IBM量子计算机中双量子位操作通过在目标设备、控制量子位设备以及连接两者的耦合链路上应用微波脉冲来执行的。与单量子位操作类似，双量子位操作的错误率也会发生变化。有一小部分耦合链路比大多数链路明显不可靠 双量子位位门误差的时间变化 链接的错误率可能随时间变化 强连接保持平均错误率的能力较强，弱连接保持平均错误率的能力较弱 双量子位位门误差的空间变化 不同节点和连接之间的误差率不一样 评估方法 系统级别可靠性的品质因数 以PST作为主要指标 评估基准 微基准是按照比例缩小的大的量子应用和子程序 选取准则：选取了纠缠模式不同的数据集 评估所用的工具 采用基于蒙特卡洛方法的错误注入模拟器 采用NISQ的迭代执行，分析结果模型 错误注入模拟器接收：1.NISQ程序 2.框架、配置和错误率 3. 管理策略 评估了以下方面的失败可能性：两量子位、单量子位、测量操作 对每个数据集执行100万次 错误建模为具有独立概率的不相关事件 映射和编译策略可以被一阶模拟器评估 架构和错误率参数 架构参数规定了量子位的数量和连通性 错误率参数规定了单比特、双比特和测量操作的错误率 文章对coherence错误进行了建模 IBM-Q20的门错误比coherence错误更加严重 量子位移动和分配的基准策略 Zulehner提出的基本映射策略 构建无权图，节点为量子位，边为量子位与量子位之间的连通 采用Floyd算法，计算任意两点之间的最短路径 对输入程序**&lt;u&gt;分层&lt;/u&gt;**，使得每一层都包含能够被并行执行的独立操作。分层为： $$ L=\\left{l_{0}, \\ldots, l_{i}, l_{i+1}, \\ldots, l_{n-1}\\right} $$ 对于每一个分层$l_{i}$，都要找到一个对应的映射$m_{i}$，使得这一层的控制非门都能有足够的物理连通性被执行 为每对相邻层$l_{i}$ 和 $l_{i+1}$找到最优swap操作集合$\\left(S_{i \\rightarrow i+1}\\right)$，**这个操作集合能够将映射$m_{i}$转化到$m_{i+1}$。*搜索时要采用A算法。 可变感知的量子位移动 由于量子计算机的量子位大多数以网格状分布，因此两点之间沿任意路径的曼哈顿距离相同。 现有的方法采用插入的交换数作为代价函数。但文章的方法是将量子位从源移动到目标的总体失败率。但在失败率相同的时候，选择最小的交换数。 VQM利用了基线的局部性保留特性，同时使用了一种可变感知的启发式。 VQM算法流程 初始化权图，边的权值是失败概率，使用N次Dijkstra算法，获取任意两点之间的纠缠最小失败概率。 计算每个量子位的节点强度$d_{i}$，$d_{i}=\\sum_{j}^{N} w_{i j}$ 将输入程序分层，使得每一层都包含能够被并行执行的独立操作。分层为： $$ L=\\left{l_{0}, \\ldots, l_{i}, l_{i+1}, \\ldots, l_{n-1}\\right} $$ 找映射，量子位节点强度更高的量子位会被优先选中。 选择能够根据最小失败概率矩阵，找到最优交换操作。使用A*算法进行搜索，启发函数使用可靠性消耗和MAH（最大附加跳数）的加和。 MAH：Maximum Additional Hop，用于限制最大跳数，如果超过最大跳数的做法，即使cost低，也不予考虑。 可变感知的量子位分配 普通方法只注意分配过程使SWAP数最小，而VQA方法要使出错概率最小。 基线策略从精心选择的初始映射开始，然后尝试收敛到具有最小SWAP数量的配置。 VQA方法将最频繁使用的量子位分配到最稳定的物理量子位上，并保持局部性。VQA方法通过采用最可靠的初始映射，限制最常用的量子位到最可靠的连接上来实现。VQA方法通过分析程序中的前N条指令、跟踪控制非门操作涉及的对象，来估计最常被纠缠的量子位。 VQA算法流程 找到具有k个节点的具有最高ANS的子图，ANS等于k个节点的临边权值和的和 通过计算前t层的每一个量子位的控制非门数，找出***&lt;u&gt;量子位活动&lt;/u&gt;*** 优先映射量子位活动多的量子位到子图上 用基线算法找到层$l_{i}$ 和 $l_{i+1}$的SWAP数 VQA使用K-core算法来计算最强的子图集，该算法递归删除度数小于k的节点。 VQA对系统可靠性的影响 VQA具有高活动性(CNOT操作总数)的程序量子位元到具有较高节点强度的物理量子位的映射。这提高了在少数几个qubit对之间重复纠缠操作的工作负载的可靠性。 和IBM编译器的比较 baseline比原始IBM编译器提升了4倍，VQA和VQM可提升7倍 每天不同数据的比较 错误率变化程度大的数据，PST相对较高，反之则较低 对错误率大小变化的敏感性 错误率无论大小，总会有变化，总是适用。 VQM+VQA提供了显著的好处，这些好处随着相对变化的增加而增加。 改变了两个变量：一个是平均错误率，一个是Covariation（相关变异） 在IBM-Q5上的测试 two-qubit error rate is 4.2%, the worst link-error is 12%. We run each experiment with 4096 trials and analyze the output log to compute the PST for each program and policy. 分区的量子计算机 在实际所需的量子位比物理量子位少一半甚至更少的时候，探究分区是否有意义。 产生了2 copy mode 同时运行的两个副本每次可以提供两倍的无错误试验次数。但是这限制了物理量子位的映射的选择。因为单次实验可以选择连接较强，错误率较低的物理量子位进行映射，而两个副本导致了不得不选用连接较弱、错误率较高的物理量子位进行映射。 局限性分析 benchmarks可能不典型 错误模型可能假设有问题 总结 强调了量子位和量子位之间的连接的错误率中的可变性 提出了VQM，能使量子位的移动有最低失败概率 提出了VQA，能将程序量子位映射到更健壮的物理量子位上 提出了一套评价方法论来评估设备变化和管理策略对量子计算机系统级可靠性的影响 论文总结和评价 关于量子计算的知识 量子计算中，量子计算机是不可靠不稳定的。可能发生操作错误和保持性错误。操作错误分单比特位操作和双比特位操作。严重程度：双比特位操作错误&gt;单比特位操作错误&gt;保持性错误。 量子计算通过多次执行量子程序，记录每次的观测结果，根据大数定律，正确事件出现的次数与总试验次数的比值会趋近于该事件的概率。 简介 传统噪声中尺度量子计算机（NISQ, Noisy Intermediate Scale Quantum computers），由于量子位太少（10x-100x），不能够采用QEC来执行错误检测和错误更正，因为QEC需要10-100个量子位来编码一个错误检测位。那么该如何有效提升量子计算机的可靠性呢？ 作者通过分析IBM-Q20的特征数据发现，量子位和量子位之间的连接的错误率是不完全一致的，是多变的。为了利用这一特性，作者提出了VQM和VQA，能使程序量子位被分配到更好的物理量子位上，能使swap操作更多地发生在更可靠的链接上。 基线策略 VQM和VQA是在基线准则上进行改进所得到的策略。 基线策略采用SWAP次数作为价值参数。 前提假设：所有的SWAP操作代价相同 基线映射策略 初始化无权无向图 使用最短路算法，计算任意两点纠缠所需最少的swap次数 程序指令分为n层，不同层包含不同的指令，不同层之间可以并行执行。 遍历所有的层，对于每一层，都要找到从程序量子位到物理量子位的映射，这样每一层的CNOT就可以有足够的物理连接被执行了。 对于每两层中间，通过A*搜索算法，以成本函数和基于曼哈顿距离的启发函数，搜索最优的SWAP集合，能使第一层的程序量子位到物理量子位的映射转化到第二层程序量子位到物理量子位的映射。 存疑： 量子程序中的指令是什么样子的？ 分层是什么意思？分层依据的准则是什么？ 这里的分层，每一层的所包含的程序量子位都完全一样？否则第5步中无法通过SWAP方法来把第一层的映射改为第二层的映射。 VQM 可构造无向有权图，采用最短路算法，计算距离矩阵 对每一个物理量子位计算节点强度，节点强度等于节点上的所有连线的权值 将输入程序分层 每一层寻找映射，映射要优先选择介电强度高的节点 找到从第一层映射到第二层映射的最优swap集，依据标准是最短路矩阵，有最大跳数的限制 VQA 找一个具有k个节点的子图，子图应当具有最大的ANS，ANS是子图中所有节点的边权的和的加和。 在前t层中，通过计算CNOT数，计算每个量子位的量子位活动 映射程序量子位到物理量子位，优先映射量子位活动较高的程序量子位 运用基线策略，找到层$l_i$和层$l_{i+1}$之间的映射","categories":[{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/categories/量子计算/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://douxl5516.github.io/tags/论文阅读/"},{"name":"量子计算","slug":"量子计算","permalink":"https://douxl5516.github.io/tags/量子计算/"}]},{"title":"统计学习方法读书笔记","slug":"统计学习方法读书笔记","date":"2019-07-07T11:58:43.000Z","updated":"2019-07-08T10:54:42.142Z","comments":true,"path":"2019/07/07/统计学习方法读书笔记/","link":"","permalink":"https://douxl5516.github.io/2019/07/07/统计学习方法读书笔记/","excerpt":"","text":"[TOC] 资料 统计学习方法读书笔记 代码实现 笔记 CH1：统计学习方法概论 实现统计学习方法的步骤 统计学习方法三要素：模型，策略，算法 得到一个有限的训练数据集合； 确定包含所有可能的模型的假设空间，即学习模型的集合； 确定模型选择的准则，即学习的策略； 实现求解最优模型的算法，即学习的算法； 通过学习方法选择最优的模型； 利用学习的最优模型对新数据进行预测或分析。 统计学习分类 基本分类 监督学习：采用的数据集包含标签，如KNN 无监督学习：采用的数据集不包含标签，如k-means 半监督学习：监督学习与与无监督学习的结合 强化学习：通过接收环境对动作的奖励（反馈）获得学习信息并更新模型参数 按模型分类 概率模型：为生成模型 非概率模型：为判别模型 按算法分类 在线学习 批量学习 统计学习方法三要素 模型 在监督学习过程中，模型就是所要学习的条件概率分布或者决策函数。 假设空间$\\cal F$ 输入空间$\\cal X$ 输出空间$\\cal Y$ 参数空间 决策函数 $\\cal F\\it ={f_{\\theta} Y=f_{\\theta}(x), \\theta \\in \\bf R \\it ^n}$ 变量 变量 条件概率分布 $\\cal F\\it ={P P_{\\theta}(Y X),\\theta\\in \\bf R \\it ^n}$ 随机变量 策略 学习过程或选择最优的模型的过程所参照的准则。 损失函数与风险函数 损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 损失函数(loss function)或代价函数(cost function) 损失函数定义为给定输入$X$的预测值$f(X)$和真实值$Y$之间的非负实值函数，记作$L(Y,f(X))$ 风险函数(risk function)或期望损失(expected loss) 这个和模型的泛化误差的形式是一样的 $$ R_{exp}(f)=E_p[L(Y, f(X))]=\\int_{\\mathcal X\\times\\mathcal Y}L(y,f(x))P(x,y), {\\rm d}x{\\rm d}y模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失(期望损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是期望，以及平均意义下的。 $$ 模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失(期望损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是期望，以及平均意义下的。 这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏，$P(x,y)$转换成$\\frac {\\nu(X=x, Y=y)}{N}$更容易直观理解。 经验风险(empirical risk)或经验损失(empirical loss) $R_{emp}(f)=\\frac{1}{N}\\sum^{N}_{i=1}L(y_i,f(x_i))$ 模型$f$关于训练样本集的平均损失 根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险 结构风险(structural risk) $R_{srm}(f)=\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i))+\\lambda J(f)$ $J(f)$为模型复杂度, $\\lambda \\geqslant 0$是系数，用以权衡经验风险和模型复杂度。 常用损失函数 损失函数数值越小，模型就越好 0-1损失 $$ L(Y,f(X))=\\begin{cases}1, Y \\neq f(X) \\0, Y=f(X) \\end{cases} $$ 平方损失 $$ L(Y,f(X))=(Y-f(X))^2 $$ 绝对损失 $$ L(Y,f(X))=|Y-f(X)| $$ 对数损失 这里$P(Y|X)\\leqslant 1$，对应的对数是负值，所以对数损失中包含一个负号。 $$ L(Y,P(Y|X))=-\\log P(Y|X) $$ ERM与SRM 经验风险最小化(Empirical Risk Minimization,ERM)与结构风险最小化(Structural Risk Minimization,SRM) 极大似然估计是经验风险最小化的一个例子 当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计 贝叶斯估计中的最大后验概率估计是结构风险最小化的一个例子 当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化等价于最大后验概率估计 算法 这章里面简单提了一下，具体可以参考CH12表格中关于学习算法的描述。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://douxl5516.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://douxl5516.github.io/tags/机器学习/"},{"name":"统计学习方法","slug":"统计学习方法","permalink":"https://douxl5516.github.io/tags/统计学习方法/"}]},{"title":"在hexo博客中使用数学公式","slug":"在hexo博客中使用数学公式","date":"2019-07-01T01:49:14.000Z","updated":"2019-07-21T01:37:23.051Z","comments":true,"path":"2019/07/01/在hexo博客中使用数学公式/","link":"","permalink":"https://douxl5516.github.io/2019/07/01/在hexo博客中使用数学公式/","excerpt":"","text":"解决方法一 第一步： 安装Kramed 12yarn remove hexo-renderer-markedyarn add hexo-renderer-kramed 第二步：更改文件配置 打开/node_modules/hexo-renderer-kramed/lib/renderer.js，更改： 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed's rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');&#125; 为 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 第三步: 停止使用 hexo-math，并安装mathjax包 12yarn remove hexo-mathyarn add hexo-renderer-mathjax 第四步: 更新 Mathjax 的 配置文件 打开/node_modules/hexo-renderer-mathjax/mathjax.html 将&lt;script&gt;替换为： 1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 第五步: 更改默认转义规则 打开/node_modules\\kramed\\lib\\rules\\inline.js 1escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, 改为 1escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 1em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 改为 1em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第六步: 开启mathjax 在config.yml文件 中开启 Mathjax 12mathjax: enable: true 解决方法二 将这段代码放到 HTML 的 header 里，解决方案来自liam 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt;$(document).ready(function()&#123; $(\"code\").map(function()&#123; match = /^\\$(.*)\\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith(\"&lt;span class=hpl_mathjax_inline&gt;\" + $(this).html() + \"&lt;/span&gt;\"); MathJax.Hub.Queue([\"Typeset\",MathJax.Hub,$(this).get(0)]); &#125; match = /^\\$\\$(.*)\\$\\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith(\"&lt;span class=hpl_mathjax_inline&gt;\" + $(this).html() + \"&lt;/span&gt;\"); MathJax.Hub.Queue([\"Typeset\",MathJax.Hub,$(this).get(0)]); &#125; match = /^\\\\begin/.exec($(this).html()); if (match) &#123; $(this).replaceWith(\"&lt;span class=hpl_mathjax_inline&gt;\" + $(this).html() + \"&lt;/span&gt;\"); MathJax.Hub.Queue([\"Typeset\",MathJax.Hub,$(this).get(0)]); &#125; &#125;);&#125;);&lt;/script&gt; https://www.jianshu.com/p/7ab21c7f0674 https://www.jianshu.com/p/0c97df3a8491 https://blog.csdn.net/u014630987/article/details/78670258 https://liam.page/2015/09/09/fix-conflict-between-mathjax-and-markdown/","categories":[{"name":"hexo","slug":"hexo","permalink":"https://douxl5516.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://douxl5516.github.io/tags/hexo/"},{"name":"latex","slug":"latex","permalink":"https://douxl5516.github.io/tags/latex/"},{"name":"mathjax","slug":"mathjax","permalink":"https://douxl5516.github.io/tags/mathjax/"}]},{"title":"SfM和SLAM项目总结","slug":"SfM和SLAM项目总结","date":"2019-06-28T10:19:51.000Z","updated":"2019-07-21T01:53:00.083Z","comments":true,"path":"2019/06/28/SfM和SLAM项目总结/","link":"","permalink":"https://douxl5516.github.io/2019/06/28/SfM和SLAM项目总结/","excerpt":"","text":"前言：2019年6月27日，我进行了网易伏羲实验室虚拟人方向的电话面试。在电话中，我支支吾吾连自己的项目都讲不清楚。不管最后面试结果如何，自己做过的东西起码自己要懂。 基础知识 内积 $$ \\bf{a} \\cdot \\bf{b}=\\bf{a}^T\\bf{b}=\\sum_{i=1}^3a_ib_i=|\\bf{a}||\\bf{b}|cos&lt;\\bf{a,b}&gt; $$ 外积 $$ \\bf{a} \\times \\bf{b} = \\left[ \\begin{array}{ccc} {\\bf{i}} &amp; {\\bf{j}} &amp; {\\bf{k}}\\ {a_1} &amp; {a_2} &amp; {a_3}\\{b_1} &amp; {b_2} &amp; {b_3} \\end{array} \\right] = \\left[ \\begin{array}{c} {a_2b_3-a_3b_2}\\ {a_3b_1-a_1b_3}\\ {a_1b_2-a_2b_1} \\end{array} \\right] =\\left[ \\begin{array}{ccc} {0} &amp; {-a_3} &amp; {a_2}\\ {a_3} &amp; {0} &amp; {-a_1}\\ {-a_2} &amp; {a_1} &amp; {0} \\end{array} \\right] \\bf{b} \\triangleq \\bf{a} ^\\wedge \\bf{b} $$ 相应的，有 $$ \\boldsymbol{a}=[a_1\\boldsymbol{i},a_2\\boldsymbol{j},a_3\\boldsymbol{k}] $$ $$ \\boldsymbol{a}^{\\wedge}=\\boldsymbol{A}=\\left[\\begin{matrix}0&amp;-a_3&amp;a_2\\a_3&amp;0&amp;-a_1\\-a_2&amp;a_1&amp;0\\\\end{matrix}\\right] $$ $$ \\boldsymbol{A}^{\\vee}=\\boldsymbol{a} $$ 特殊正交群 $SO(3)$ $$ SO(3)={R\\in\\mathbb{R}^{3\\times3}|RR^T=I,\\det(R)=1} $$ （det为行列式） 特殊欧式群$SE(3)$ $$ SE(3)={T=\\left[ \\begin{matrix} R&amp;t\\ 0^T&amp;1\\ \\end{matrix} \\right]\\in\\mathbb{R}^{4\\times4}|R\\in SO(3),t\\in \\mathbb{R}^3} $$ 李代数$\\mathfrak{so}(3)$ 在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{'}R(t)^T$是一个反对称矩阵，那么就用一个$\\phi(t)\\in\\mathbb{R}^3$与之对应。有： $$ R(t)^{'}R(t)^T=\\phi(t)^{\\wedge} $$ 之后求解微分方程，可以得到： $$ R(t)=exp(\\phi^{\\wedge}t) $$ 实际求解时利用到指数映射和对数映射。 双目系统 左右相机只有在 x 轴上有位移，因此 P 的像也只在 x 轴（对应图像的 u 轴）上有差异。 $$ \\frac{z-f}{z}=\\frac{b-(u_{L}+u_{R})}{b} $$ 整理得: $$ z=\\frac{f b}{d}, \\quad d=u_{L}-u_{R} $$ 对极几何 两帧图像$I_{1},I_{2}$，两个相机中心分别为 $O_{1},O_{2}$。$p_{1},p_{2}$为互相匹配的特征点。 极平面：连线$\\overrightarrow{O_{1} p_{1}}$和连线$\\overrightarrow{O_{2} p_{2}}$在三维空间中会相交于点 P。这时候点$O_{1}, O_{2}, P$三个点可以确定一个平面，该平面称极平面。 极点：$O_{1} O_{2}$连线与像平面$I_{1},I_{2}$的交点被称为极点。 基线：$O_{1},O_{2}$的连线。 极线：极平面与两个像平面$I_{1},I_{2}$之间的相交线$l_{1},l_{2}$。 用途：双目匹配中，给定左图一个点，能将右图中对应的点的搜索空间缩减到一条线。 条件：需要八个或八个以上的点对 推导：设在第一帧的坐标系下，P坐标为：$\\boldsymbol{P}=[X, Y, Z]^{T}​$，两像素点 $p_{1},p_{2}​$ **（齐次化坐标）**的像素位置为： $$ s_{1} \\boldsymbol{p}{1}=\\boldsymbol{K} \\boldsymbol{P}, \\quad s{2} \\boldsymbol{p}_{2}=\\boldsymbol{K}(\\boldsymbol{R} \\boldsymbol{P}+\\boldsymbol{t}) $$ 因为是齐次坐标，所以认为等式任意一边乘以非零常数，等式仍然成立。即： $$ \\boldsymbol{p}{1}=\\boldsymbol{K} \\boldsymbol{P}, \\quad \\boldsymbol{p}{2}=\\boldsymbol{K}(\\boldsymbol{R} \\boldsymbol{P}+\\boldsymbol{t}) $$ 取$\\boldsymbol{x}{1}, \\boldsymbol{x}{2}$是两个像素点的归一化平面上的坐标： $$ \\boldsymbol{x}{1}=\\boldsymbol{K}^{-1} \\boldsymbol{p}{1}, \\quad \\boldsymbol{x}{2}=\\boldsymbol{K}^{-1} \\boldsymbol{p}{2} $$ 有： $$ \\boldsymbol{x}{2}=\\boldsymbol{R} \\boldsymbol{x}{1}+\\boldsymbol{t} $$ 同时左乘$t^{\\wedge}$，相当于同时与$t$做外积。 $$ \\boldsymbol{t}^{\\wedge} \\boldsymbol{x}{2}=\\boldsymbol{t}^{\\wedge} \\boldsymbol{R} \\boldsymbol{x}{1} $$ 同时左乘$\\boldsymbol{x}_{2}^{T}$ $$ \\boldsymbol{x}{2}^{T} \\boldsymbol{t}^{\\wedge} \\boldsymbol{x}{2}=\\boldsymbol{x}{2}^{T} \\boldsymbol{t}^{\\wedge} \\boldsymbol{R} \\boldsymbol{x}{1} $$ 因$t^{\\wedge} x_{2}$垂直于$\\boldsymbol{x}_{2}^{T}$或$t$，因此左侧为0。极线约束即： $$ \\boldsymbol{x}{2}^{T} \\boldsymbol{t}^{\\wedge} \\boldsymbol{R} \\boldsymbol{x}{1}=0 $$ 将$\\boldsymbol{x}{1}=\\boldsymbol{K}^{-1} \\boldsymbol{p}{1}, \\quad \\boldsymbol{x}{2}=\\boldsymbol{K}^{-1} \\boldsymbol{p}{2}$代回，可得极线约束的另一种形式： $$ \\boldsymbol{p}{2}^{T} \\boldsymbol{K}^{-T} \\boldsymbol{t}^{\\wedge} \\boldsymbol{R} \\boldsymbol{K}^{-1} \\boldsymbol{p}{1}=0 $$ 意义： $O_{1}, P, O_{2}$三点共面，$\\boldsymbol{t}^{\\wedge} \\boldsymbol{R} \\boldsymbol{x}{1}$表示极线，且极线一定通过$\\boldsymbol{x}{2}$。 本质矩阵 本质矩阵为： $$ \\boldsymbol{E}=\\boldsymbol{t}^{\\wedge} \\boldsymbol{R} $$ 特点： 秩为2 仅依赖于外参 采用摄像机坐标系 基本矩阵 基本矩阵为： $$ \\boldsymbol{F}=\\boldsymbol{K}^{-T} \\boldsymbol{E} \\boldsymbol{K}^{-1} $$ 特点： 秩为2 仅依赖于外参和内参 采用像素坐标系 F是从左图到右图，有方向，从右图到左图就是F的转置 7个自由度。（$3\\times3$矩阵本有9个自由度，因行列式值为零，相差常数因子，即$kF,k\\neq 0$,也是基本矩阵，减去两个自由度。） 单应矩阵 单应矩阵是齐次矩阵，有8个未知数，需要四个对应点。 张正友标定法 A Flexible New Technique for Camera Calibration 摘要：张正友标定法只需要相机观察几个（至少两个）不同方向上显示的平面图案。相机或平面图案都可以自由移动。且相机或标定板的运动不需要知道。张正友标定法对径向透镜畸变进行了建模。该方法由一个封闭形式的解组成，然后根据最大似然准则进行非线性改进。 数学推导 针孔相机模型三维点到二维点投影矩阵 符号 含义 $m=[u,v]^T$ 二维点 $M=[X,Y,Z]^T$ 三维点 $\\widetilde{m}=[u,v,1]^T$ 二维点齐次坐标 $\\widetilde{M}=[X,Y,Z,1]^T$ 三维点齐次坐标 s 随机尺度因子 $\\bf{(R,t)}$ 外参，即将世界坐标系和相机坐标系联系起来的旋转矩阵和位移向量 $\\bf{A}$ 相机内参矩阵 $\\alpha,\\beta$ 分别为图像u轴和v轴的尺度因子 $u_0,v_0$ 光心的图像坐标系坐标 $\\gamma$ 描述图像轴u,v之间的倾斜 $$ s \\widetilde{\\bf{m}} = \\bf{A[R\\quad t]\\widetilde{M}} $$ 其中， $$ A = \\left[ \\begin{array}{ccc} {\\alpha} &amp; {\\gamma} &amp; {u_0}\\ {0} &amp; {\\beta} &amp; {v_0}\\ {0} &amp; {0} &amp; {1}\\end{array}\\right] $$ 标定板平面与图像之间的单应性矩阵 这里假设标定板所在的平面为空间坐标系下的$Z=0$。 符号 含义 $\\bf{r_i}$ 旋转矩阵$\\bf{R}$的第i列 $$ s\\left[\\begin{array}{c}{u}\\{v}\\{1}\\end{array}\\right]=\\bf{A}[\\begin{array}{cccc}{\\bf{r_1}}&amp;{\\bf{r_2}}&amp;{\\bf{r_3}}&amp;{\\bf{t}}\\end{array}]\\left[\\begin{array}{c}{X}\\{Y}\\{0}\\{1}\\end{array}\\right]=A[\\begin{array}{ccc}{\\bf{r_1}}&amp;{\\bf{r_2}}&amp;{\\bf{t}}\\end{array}]\\left[\\begin{array}{c}{X}\\{Y}\\{1}\\end{array}\\right] $$ 即： $$ s\\widetilde{\\bf{m}}=\\bf{H\\widetilde{M}} $$ 其中，$\\bf{H}$为单应矩阵，$\\bf{H=A[\\begin{array}{ccc}{\\bf{r_1}}&amp;{\\bf{r_2}}&amp;{\\bf{t}}\\end{array}]}$。 内参约束 假设$\\bf{H}=\\left[\\begin{array}{ccc}{\\bf{h_1}}&amp;{\\bf{h_2}}&amp;{\\bf{h_3}}\\end{array}\\right]$，根据单应关系有： $$ \\left[\\begin{array}{ccc}{\\bf{h_1}}&amp;{\\bf{h_2}}&amp;{\\bf{h_3}}\\end{array}\\right]=\\lambda \\bf{A}[\\begin{array}{ccc}{\\bf{r_1}}&amp;{\\bf{r_2}}&amp;{\\bf{t}}\\end{array}] $$ 可推出 $$ \\mathbf{r}{1}=\\lambda \\mathbf{A}^{-1} \\mathbf{h}{1} $$ $$ \\mathbf{r}{2}=\\lambda \\mathbf{A}^{-1} \\mathbf{h}{2} $$ $$ \\mathbf{r}{3}=\\mathbf{r}{1} \\times \\mathbf{r}_{2} $$ $$ \\mathbf{t}=\\lambda \\mathbf{A}^{-1} \\mathbf{h}_{3} $$ $$ \\lambda=\\frac{1}{\\left|\\mathbf{A}^{-1} \\mathbf{h}{1}\\right|}=\\frac{1}{\\left|\\mathbf{A}^{-1} \\mathbf{h}{2}\\right|} $$ 根据$\\bf{r_1}$和$\\bf{r_2}$正交，根据 正交 模相等 有： $$ h_1^TA^{-T}A^{-1}h_2=0 $$ $$ h_1^TA^{-T}A^{-1}h_1= h_2^TA^{-T}A^{-1}h_2 $$ 几何解释 需要大于等于三张图像才能确定唯一解。 SfM 三角化 设 $x_1 ,x_2$ 为两个特征点的归一化坐标，那么它们满足： $$ s_{1} \\boldsymbol{x}{1}=s{2} \\boldsymbol{R} \\boldsymbol{x}{2}+\\boldsymbol{t} $$ 现在我们已经知道了$\\boldsymbol{R}, \\boldsymbol{t}$，想要求解的是两个特征点的深度 $s{1}, s_{2}$。 可以左侧使用$x_1$进行叉乘，使左侧为0，即可求得$s_2$： $$ s_{1} \\boldsymbol{x}{1}^{\\wedge} \\boldsymbol{x}{1}=0=s_{2} \\boldsymbol{x}{1}^{\\wedge} \\boldsymbol{R} \\boldsymbol{x}{2}+\\boldsymbol{x}_{1}^{\\wedge} \\boldsymbol{t} $$ 求$s_1$时同理。 PnP 求解 3D 到 2D 点对运动的问题。特征点的 3D 位置可以由三角化，或者由 RGB-D 相机的深度图确定。在单目视觉里程计中，必须先进行初始化，然后才能使用 PnP。 SLAM ORB_SLAM流程 System类生成一个对象slam，初始化slam对象，设置三个线程：Tracking ，LocalMapping ，LoopClosing 订阅 GrabImage() ——&gt; TrackMonocular()——&gt;GrabImageMonocular()——&gt;Track() 三个线程作用 Tracking： Extract ORB，提取关键点和描述子 Initialize pose：在Track() 中初始化位姿 pose ， 第一帧 ：mInitialFrame 当前帧：mCurrentFrame ，从这两帧得到 （R，t）。并且，这两帧转为KeyFrame，凡是关键帧KeyFrame都要插入地图 mpMap（mpMap-&gt;AddMapPoint(pMP);），根据关键帧与当前帧公共3D点的个数 更新关键帧间的连接关系。 MapPoint类表示 路标点，Map类用Hash表管理 路标点和关键帧。 track local map： 更新局部地图，包括局部关键帧和关键点 对局部MapPoints进行投影匹配 根据匹配对估计当前帧的姿态 根据姿态剔除误匹配 keyFrame decision Local Mapping: LocalMapping线程处理的关键帧都是Tracking线程发过来的 插入关键帧， 去除冗余的MapPoints； Local BA； 去除冗余的关键帧 : 检测并剔除当前帧相邻的关键帧中和关键帧，剔除的标准是：该关键帧的90%的MapPoints可以被其它关键帧观测到。将当前帧加入到闭环检测队列中。 Loop Closing 回环检测Loop decision：计算闭环候选帧，在候选帧中检测具有连续性的候选帧； 计算相似变换阵sim3，求 [ sR | t ]； Loop Correction： A. 通过求解的Sim3以及相对姿态关系，调整与当前帧相连的关键帧位姿以及这些关键帧观测到的MapPoints的位置； B. 将闭环帧以及 与闭环帧相连的关键帧的MapPoints和与当前帧相连的关键帧的点进行匹配； C. 通过MapPoints的匹配关系更新这些帧之间的连接关系，即更新covisibility graph D. 对Essential Graph（Pose Graph）进行优化，MapPoints的位置则根据优化后的位姿做相对应的调整 E. 创建线程进行全局Bundle Adjustment main-&gt;构造SLAM对象，在构造函数中设置线程。 读取图像，循环调用trackMonocular，在其中先检查状态是否改变，再调用 1GrabImageMonocular 构造了CurrentFrame，最后进行Track","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://douxl5516.github.io/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"https://douxl5516.github.io/tags/SLAM/"},{"name":"机器视觉","slug":"机器视觉","permalink":"https://douxl5516.github.io/tags/机器视觉/"},{"name":"单目","slug":"单目","permalink":"https://douxl5516.github.io/tags/单目/"},{"name":"SfM","slug":"SfM","permalink":"https://douxl5516.github.io/tags/SfM/"}]},{"title":"前缀和、差分、线段树与树状数组","slug":"前缀和、差分、线段树与树状数组","date":"2019-06-08T01:49:56.000Z","updated":"2019-06-08T07:07:36.659Z","comments":true,"path":"2019/06/08/前缀和、差分、线段树与树状数组/","link":"","permalink":"https://douxl5516.github.io/2019/06/08/前缀和、差分、线段树与树状数组/","excerpt":"","text":"树状数组 时间复杂度：O（n） 适用于：单点更新，区间查询 理解 C[1] = C[0001] = A[1]; C[2] = C[0010] = A[1]+A[2]; C[3] = C[0011] = A[3]; C[4] = C[0100] = A[1]+A[2]+A[3]+A[4]; C[5] = C[0101] = A[5]; C[6] = C[0110] = A[5]+A[6]; C[7] = C[0111] = A[7]; C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 即： $C[i]=A[i-2^k+1]+A[i-2^k+2]+\\dots+A[i];$ $k$为 $i$ 的二进制中从最低位到高位连续零的长度。 $2^k$可通过$i&amp;-i$获得。 补码为原码取反后加1，如果将补码+1进位，那么最末尾的1和原码最右边的1一定是同一个位置 lowbit 123inline int lowbit(x)&#123; return x&amp;(-x);&#125; 单点更新 12345678910void update(int *arr,int index,int diff,int len)&#123; /* * arr：树状数组 * index：待更新的位置 * diff：改变的值 * len：树状数组长度 */ for(int i=index;i&lt;=len;i+=lowbit(i)) arr[i] += diff;&#125; 区间查询 12345678910int getsum(int *arr,int x)&#123; /* * arr：树状数组 * x：求从1到x的和 */ int ans = 0; for(int i=x;i;i-=lowbit(i)) ans += arr[i]; return ans;&#125; 样例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;int lowbit(const int t) &#123; return t &amp; (-t);&#125;void insert(int t, int d) &#123; while (t &lt;= n)&#123; a[t] += d; t = t + lowbit(t); &#125;&#125;int getSum(int t) &#123; int sum = 0; while (t &gt; 0)&#123; sum += a[t]; t = t - lowbit(t); &#125; return sum;&#125;int main() &#123; int t, k, d; scanf(\"%d\", &amp;t); k= 1; while (t--)&#123; memset(a, 0, sizeof(a)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;d); insert(i, d); &#125; string str; printf(\"Case %d:\\n\", k++); while (cin &gt;&gt; str) &#123; if (str == \"End\") break; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); if (str == \"Query\") printf(\"%lld\\n\", getSum(y) - getSum(x - 1)); else if (str == \"Add\") insert(x, y); else if (str == \"Sub\") insert(x, -y); &#125; &#125; return 0;&#125; 线段树 模板一、RMQ，查询区间最值下标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt; using namespace std; #define MAXN 100 #define MAXIND 256 //线段树节点个数 //构建线段树,目的:得到M数组. void build(int node, int b, int e, int M[], int A[]) &#123; if (b == e) M[node] = b; //只有一个元素,只有一个下标 else &#123; build(2 * node, b, (b + e) / 2, M, A); build(2 * node + 1, (b + e) / 2 + 1, e, M, A); if (A[M[2 * node]] &lt;= A[M[2 * node + 1]]) M[node] = M[2 * node]; else M[node] = M[2 * node + 1]; &#125; &#125; //找出区间 [i, j] 上的最小值的索引 int query(int node, int b, int e, int M[], int A[], int i, int j) &#123; int p1, p2; //查询区间和要求的区间没有交集 if (i &gt; e || j &lt; b) return -1; if (b &gt;= i &amp;&amp; e &lt;= j) return M[node]; p1 = query(2 * node, b, (b + e) / 2, M, A, i, j); p2 = query(2 * node + 1, (b + e) / 2 + 1, e, M, A, i, j); //return the position where the overall //minimum is if (p1 == -1) return M[node] = p2; if (p2 == -1) return M[node] = p1; if (A[p1] &lt;= A[p2]) return M[node] = p1; return M[node] = p2; &#125; int main() &#123; int M[MAXIND]; //下标1起才有意义,否则不是二叉树,保存下标编号节点对应区间最小值的下标. memset(M,-1,sizeof(M)); int a[]=&#123;3,4,5,7,2,1,0,3,4,5&#125;; build(1, 0, sizeof(a)/sizeof(a[0])-1, M, a); cout&lt;&lt;query(1, 0, sizeof(a)/sizeof(a[0])-1, M, a, 0, 5)&lt;&lt;endl; return 0; &#125; 模板二、连续区间修改或者单节点更新的动态查询问题 （此模板查询区间和） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; #define lson l , m , rt &lt;&lt; 1 #define rson m + 1 , r , rt &lt;&lt; 1 | 1 #define root 1 , N , 1 #define LL long long const int maxn = 111111; LL add[maxn&lt;&lt;2]; LL sum[maxn&lt;&lt;2]; void PushUp(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void PushDown(int rt,int m) &#123; if (add[rt]) &#123; add[rt&lt;&lt;1] += add[rt]; add[rt&lt;&lt;1|1] += add[rt]; sum[rt&lt;&lt;1] += add[rt] * (m - (m &gt;&gt; 1)); sum[rt&lt;&lt;1|1] += add[rt] * (m &gt;&gt; 1); add[rt] = 0; &#125; &#125; void build(int l,int r,int rt) &#123; add[rt] = 0; if (l == r) &#123; scanf(\"%lld\",&amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt); &#125; void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; add[rt] += c; sum[rt] += (LL)c * (r - l + 1); return ; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (m &lt; R) update(L , R , c , rson); PushUp(rt); &#125; LL query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; LL ret = 0; if (L &lt;= m) ret += query(L , R , lson); if (m &lt; R) ret += query(L , R , rson); return ret; &#125; int main() &#123; int N , Q; scanf(\"%d%d\",&amp;N,&amp;Q); build(root); while (Q --) &#123; char op[2]; int a , b , c; scanf(\"%s\",op); if (op[0] == 'Q') &#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%lld\\n\",query(a , b ,root)); &#125; else &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); update(a , b , c , root); &#125; &#125; return 0; &#125; 前缀和 一维前缀和 有数组A，数组A对应的前缀和数组为S，有： $$ S[k]=\\sum_{i=0}^{k}A[i] $$ 由此方便了范围查询： $$ \\sum_{i=L}^RA[i]=S[R]-S[L-1] $$ 二维前缀和 对于二维数组A，数组A对应的前缀和数组为S，有： $$ S[i][j]=\\sum_{m=0}^i\\sum_{n=0}^jA[i][j] $$ 计算时二维前缀和时，可以使用递推公式： $$ S[i][j]=A[i][j]+S[i-1][j]+S[i][j-1]-S[i-1][j-1] $$ 当求被点$(x_1,y_1)$和点$(x_2,y_2)$围起来的元素的和时，可以使用： $$ \\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}A[i][j]=S[x_2][y_2]-S[x_1-1][y2]-S[x_2][y_1-1]+S[x_1-1][y_1-1] $$ 差分 差分可解决范围更新的问题。 思想： 延后更新 更新的起点和终点 利用前缀和 样例： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+9;int a[maxn],b[maxn];int main()&#123; int i,j,k,n,m,p; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=1;i&lt;=m;i++)&#123; int L,R,t; cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p; if(t==1)&#123; b[L]+=p;b[R+1]-=p; &#125; else&#123; b[L]-=p;b[R+1]+=p; &#125; &#125; int add=0; for(i=1;i&lt;=n;i++)&#123; add+=b[i]; a[i]+=a[i-1]+add; &#125; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://douxl5516.github.io/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/tags/算法/"},{"name":"OJ","slug":"OJ","permalink":"https://douxl5516.github.io/tags/OJ/"}]},{"title":"字符串匹配算法Sunday","slug":"字符串匹配算法Sunday","date":"2019-06-07T12:55:29.000Z","updated":"2019-06-11T08:22:26.277Z","comments":true,"path":"2019/06/07/字符串匹配算法Sunday/","link":"","permalink":"https://douxl5516.github.io/2019/06/07/字符串匹配算法Sunday/","excerpt":"","text":"Sunday算法在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1； 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。 偏移表 在预处理中，计算偏移表。 $$ shift[w] = \\begin{cases} m - max{i &lt; m | P[i] = w} &amp; \\mbox{ if } w \\mbox{ is in } P[0..m-1] \\ m + 1 &amp; \\mbox{ otherwise } \\end{cases} $$ C++实现 12345678910111213141516171819202122232425const int charnum = 1005;int shift[charnum];int Sunday(const string&amp; T, const string&amp; P) &#123; int n = T.length(); int m = P.length(); for(int i = 0; i &lt; charnum; i++) &#123; shift[i] = m + 1; &#125; for(int i = 0; i &lt; m; i++) &#123; shift[P[i]] = m - i; &#125; int s = 0; int j; while(s &lt;= n - m) &#123; j = 0; while(T[s + j] == P[j]) &#123; j++; if(j &gt;= m) &#123; return s; &#125; &#125; s += shift[T[s + m]]; &#125; return -1; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://douxl5516.github.io/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://douxl5516.github.io/tags/算法/"},{"name":"OJ","slug":"OJ","permalink":"https://douxl5516.github.io/tags/OJ/"}]},{"title":"SLAM之单目视觉里程计","slug":"SLAM之单目视觉里程计","date":"2019-05-12T01:15:10.000Z","updated":"2019-07-01T23:38:55.647Z","comments":true,"path":"2019/05/12/SLAM之单目视觉里程计/","link":"","permalink":"https://douxl5516.github.io/2019/05/12/SLAM之单目视觉里程计/","excerpt":"","text":"SLAM之单目视觉里程计 基础知识 旋转矩阵和位移矩阵 建议参考计算机图形学教材，学习“图形变换”章节。重点掌握以下概念： 旋转矩阵 平移向量 齐次坐标 变换矩阵（旋转矩阵与平移向量的结合） 参考： 旋转变换（一）旋转矩阵 旋转矩阵、欧拉角、四元数理论及其转换关系 三个坐标系 图像坐标系： 一般来说，图像坐标系包括像素坐标系以及物理坐标系。 对于图像直角坐标系上的坐标$(u,v)$，分别能从像素的行数和列数得到，叫做像素坐标系。为表示像素点在图像中的位置我们需要借助物理坐标系，以图像中某一点$O_{1}$当作原点建立坐标系，其中$x$轴，$y$轴分别与像素坐标系的横、竖轴平行，方向一致。其中$(x, y)$坐标单位为毫米，$O_{1}$在$(u, v)$坐标系下的坐标为$\\left(u_{0}, v_{0}\\right)$，$d_{x}$和$d_y$表示每个像素点在$x$,$y$轴上的尺寸大小，则有： $$ \\left{\\begin{array}{l}{u=\\frac{x}{d x}+u_{0}} \\ {v=\\frac{y}{d y}+v_{0}}\\end{array}\\right. $$ 即： $$ \\left[ \\begin{array}{c}{u} \\ {v} \\ {1}\\end{array}\\right]=\\left[ \\begin{array}{ccc}{\\frac{1}{d x}} &amp; {0} &amp; {u_{0}} \\ {0} &amp; {\\frac{1}{d y}} &amp; {v_{0}} \\ {0} &amp; {0} &amp; {1}\\end{array}\\right] \\left[ \\begin{array}{l}{x} \\ {y} \\ {1}\\end{array}\\right] $$ 相机坐标系：相机坐标系原点位于光心。如图所示，相机光心为点$O$，$Z_{c}$与像平面垂直，为相机的光轴，$X_{c}, Y_{c}$分别与$x,y$轴相平行，焦距大小为线段$O O_{1}$的长度，则将$O-X_{c} Y_{c} Z_{c}$坐标系称作相机坐标系。 世界坐标系:世界坐标系可以对场景的中的任何物体进行描述，同时能表示出相机坐标。如上图中，将坐标系$O_{w}-X_{w} Y_{w} Z_{w}$称为世界坐标系，其与相机坐标系的相互变换可以通过$3 \\times 1$的平移向量$t$以及$3\\times 3$的旋转矩阵$R$来表示，设点$P$在世界坐标系中的齐次坐标为$\\left(X_{w}, Y_{w}, Z_{w}, 1\\right)^{T}$，在相机坐标系中的齐次坐标为$\\left(X_{c}, Y_{c}, Z_{c}, 1\\right)^{T}$，那么二者的转换关系为： $$ \\left[ \\begin{array}{c}{X_{c}} \\ {Y_{c}} \\ {Z_{c}} \\ {1}\\end{array}\\right]=\\left[ \\begin{array}{cc}{R} &amp; {t} \\ {0^{T}} &amp; {1}\\end{array}\\right] \\left[ \\begin{array}{c}{X_{w}} \\ {Y_{w}} \\ {Z_{w}} \\ {1}\\end{array}\\right]=M_{1} \\left[ \\begin{array}{c}{X_{w}} \\ {Y_{w}} \\ {Z_{w}} \\ {1}\\end{array}\\right] $$ 针孔相机模型 针孔相机模型是将空间坐标映射到图像点的模型。 请阅读: 视觉SLAM十四讲 5.1.1 对于使用的数据集，一般会提供拍摄照片所用的相机的内参和畸变系数。如果使用自己的相机，则需要采用张正友标定法进行相机标定，以获取相机内参及畸变系数。 最终有： $$ Z \\boldsymbol{P}{u v}=Z \\left[ \\begin{array}{c}{u} \\ {v} \\ {1}\\end{array}\\right]=\\boldsymbol{K}\\left(\\boldsymbol{R} \\boldsymbol{P}{w}+\\boldsymbol{t}\\right)=\\boldsymbol{K} T \\boldsymbol{P}_{w} $$ 其中$Z$为空间点三维坐标中的$Z$坐标值，$P_{uv}$代表空间点投影到像平面，在像平面上的坐标，$K$为相机内参，$R$为相机外参中的旋转矩阵，$t$为相机外参中的位移向量，$P_w$为空间点在世界坐标系下的三维坐标。其中： $$ K=\\left( \\begin{array}{ccc}{f_{x}} &amp; {0} &amp; {c_{x}} \\ {0} &amp; {f_{y}} &amp; {c_{y}} \\ {0} &amp; {0} &amp; {1}\\end{array}\\right) $$ 单目视觉里程计 单目视觉里程计主要需要了解对极约束、三角化和PnP。 对极约束 对极约束用于通过二维点之间的匹配关系，求解相邻两张图像之间的运动。关于对极约束的内容，请阅读视觉SLAM十四讲7.3，7.4。 使用对极约束求解本质矩阵可以通过调用opencv中的findEssentialMat函数完成。 12345678910111213//函数原型Mat findEssentialMat( InputArray points1, InputArray points2, InputArray cameraMatrix, int method = RANSAC, double prob = 0.999, double threshold = 1.0, OutputArray mask = noArray());//示例调用using namespace cv;Mat E = findEssentialMat(p1, p2, M); 其中： points1与points2是vector&lt;Point2f&gt;类型，两vector的size相同，对应位置上的Point2f互相匹配。 cameraMatrix是相机内参矩阵 method是计算方法，RANSAC是openCV中被define的常量，表示采用RANSAC方法进行本征矩阵计算 prob是估计矩阵正确的可信度 参数threshold用于RANSAC的参数。 它是从点到极线的最大距离（以像素为单位），超出此点时，该点被视为异常值，不用于计算最终的基本矩阵。 根据点定位精度，图像分辨率和图像噪声的不同，可将其设置为1-3。 参数mask输出N个元素的数组，其中每个元素对于异常值设置为0，对其他点设置为1。 求解出本征矩阵E后，调用recoverPose求解旋转矩阵和位移向量。 1234567891011//函数原型int recoverPose(Mat E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, OutputArray mask = noArray()); //示例调用using namespace cv;int pass_count = recoverPose(E,p1, p2, M, R, t,mask); 其中： E是经过findEssentialMat求解出的本征矩阵 points1，points2，cameraMatrix，mask与findEssentialMat函数中的意义相同 R是求解出的旋转矩阵 t是求解出的位移向量 R和t组成变换矩阵T，这里的T是是第一张图到第二张图的坐标变换矩阵。或者可以理解为第一张图相机相对于相机初始位置的变换矩阵是X。因为第一张图相机所处的位置是初始位置，所以有：$X = eye(4)$，其中$eye(4)$是四阶单位矩阵。那么T左乘X是第二个图的相机的坐标变换矩阵。 对极约束可以求解出两张图像之间的相机变换矩阵，但是它是2D和2D之间求解的变换矩阵，t的尺度无法确定，t可能是1米，可能是1cm。 三角化 1234567891011121314151617181920212223242526272829void reconstruct(Mat&amp; K, Mat&amp; R1, Mat&amp; T1, Mat&amp; R2, Mat&amp; T2, vector&lt;Point2f&gt;&amp; p1, vector&lt;Point2f&gt;&amp; p2, vector&lt;Point3f&gt;&amp; structure)&#123; //两个相机的投影矩阵[R T]，triangulatePoints只支持float型 Mat proj1(3, 4, CV_32FC1); Mat proj2(3, 4, CV_32FC1); R1.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_32FC1); T1.convertTo(proj1.col(3), CV_32FC1); R2.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_32FC1); T2.convertTo(proj2.col(3), CV_32FC1); Mat fK; K.convertTo(fK, CV_32FC1); proj1 = fK*proj1; proj2 = fK*proj2; //三角重建 Mat s; triangulatePoints(proj1, proj2, p1, p2, s); structure.clear(); structure.reserve(s.cols); for (int i = 0; i &lt; s.cols; ++i) &#123; Mat_&lt;float&gt; col = s.col(i); col /= col(3); //齐次坐标，需要除以最后一个元素才是真正的坐标值 structure.push_back(Point3f(col(0), col(1), col(2))); &#125;&#125; 三角化在得到两个相机的旋转矩阵、位移向量后，可以根据匹配的特征点进行三角化，最终能够求得特征点对应的空间点云的坐标。 PnP PnP在得知了对应的空间点的三维坐标和新加入的图像中的特征点的二维坐标之后，可以求解新加入的图像的相机的旋转矩阵和位移向量。 参考opencv中solvePnPRansac函数求解相机位姿 12345678910//函数原型bool solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray dist， OutputArray rvec, OutputArray tvec, ...);//调用示例solvePnPRansac(object_points, image_points, K, noArray(), r, T); 其中： objectPoints为三维坐标，imagePoints为二维坐标，对应位置的坐标互相匹配。 cameraMatrix为相机内参。 dist为畸变参数矩阵。 rvec为求解出的相机旋转向量，不是旋转矩阵。可经过罗德里格斯变换获取旋转矩阵。 1Rodrigues(r, R); tvec为求解出的相机位移向量。 这里的objectPoints为原有空间点云三维坐标。imagePoints为新加入的一张图像中的特征点的图像坐标。假设刚开始运行程序时候，点云$C_{12}$由前两张图像的相机的旋转矩阵、位移向量和匹配的特征点经过三角化求解出来。 上述过程涉及到的前两张图像中第一张图像的相机旋转矩阵为三阶单位矩阵，位移向量为0，即第一张图像的相机处于起始位置；第二张图像的旋转矩阵和位移向量通过对极几何被求解出来。 进行求解PnP需要构建已有空间点云三维坐标和新加入图像中的特征点二维坐标的匹配关系。那么这个关系是怎么建立的呢？是在图一、图二进行三角化生成空间点云时候，会生成空间点云中点与图二中特征点的匹配关系。图二与图三进行匹配，可获得图二与图三中特征点的匹配关系。由此可获得图三中特征点与原有空间点云中点的匹配关系。 程序经过一次PnP，求解出第三张图像的相机的旋转矩阵和位移矩阵后，可以使用第三张图像的相机的旋转矩阵和位移向量与第二张图像的旋转矩阵和位移向量进行三角化，生成第二张图像和第三张图像共同构建的空间点云$C_{23}$。 之后，空间点云可以进行点的添加和旧点的消除，每次新加入的一张图像的相机位姿可以通过PnP求解出来。 参考资料 【1】《视觉SLAM十四讲》 —— 高翔 【2】 葛均强. 基于无人机航拍图像序列的三维重建研究与实现[D]. 电子科技大学,2015. 【3】线性代数的本质——3blue1brown","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://douxl5516.github.io/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"https://douxl5516.github.io/tags/SLAM/"},{"name":"机器视觉","slug":"机器视觉","permalink":"https://douxl5516.github.io/tags/机器视觉/"},{"name":"单目","slug":"单目","permalink":"https://douxl5516.github.io/tags/单目/"},{"name":"视觉里程计","slug":"视觉里程计","permalink":"https://douxl5516.github.io/tags/视觉里程计/"}]},{"title":"OJ技巧","slug":"OJ技巧","date":"2019-05-10T13:20:51.000Z","updated":"2019-06-11T08:15:37.950Z","comments":true,"path":"2019/05/10/OJ技巧/","link":"","permalink":"https://douxl5516.github.io/2019/05/10/OJ技巧/","excerpt":"","text":"OJ中的奇技淫巧 使用异或进行swap 12345void swap(int&amp; a,int&amp; b)&#123; a=a^b; b=a^b; a=a^b;&#125; 单行多字符串处理 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); stringstream ss; ss&lt;&lt;s; while(ss&gt;&gt;s)&#123; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 加快cin速度 1std::ios::sync_with_stdio(false); while和scanf 12345678910//读到文件的结尾，程序自动结束while( ( scanf( \" %d \" ,&amp;a) ) != -1 )while( ( scanf( \" %d \" ,&amp;a) ) != EOF)while( ( scanf( \" %d \" ,&amp;a) ) == 1 )while( ~( scanf( \" %d \" ,&amp;a) ) )//读到一个 0 时，程序结束while( scanf( \" %d \" ,&amp;a) ,a)//读到多个0时，程序结束while( scanf( \" %d%d%d \" ,&amp;a,&amp;b,&amp;c),a+b+c ) //a,b,c非负while( scanf( \" %d%d%d \" ,&amp;a,&amp;b,&amp;c),a|b|c ) vector定义二维数组 12int len=100;vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len,0));","categories":[{"name":"编程技巧","slug":"编程技巧","permalink":"https://douxl5516.github.io/categories/编程技巧/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://douxl5516.github.io/tags/C/"}]},{"title":"cs229","slug":"cs229","date":"2019-05-10T12:52:35.000Z","updated":"2019-05-10T12:57:10.125Z","comments":true,"path":"2019/05/10/cs229/","link":"","permalink":"https://douxl5516.github.io/2019/05/10/cs229/","excerpt":"","text":"CS229 课程讲义 CSDN博主中文翻译","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://douxl5516.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://douxl5516.github.io/tags/机器学习/"}]},{"title":"manjaro装机配置","slug":"manjaro装机配置","date":"2019-05-09T06:12:51.000Z","updated":"2019-06-11T08:15:02.692Z","comments":true,"path":"2019/05/09/manjaro装机配置/","link":"","permalink":"https://douxl5516.github.io/2019/05/09/manjaro装机配置/","excerpt":"","text":"配置镜像源: 1sudo pacman-mirrors -i -c China -m rank 打开配置文件sudo nano /etc/pacman.conf在文件末尾添加 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 导入GPG Key 12sudo pacman -Syysudo pacman -S archlinuxcn-keyring 安装软件 123sudo pacman -S vim cmake firefox-i18n-zh-cn gdb nodejs fcitx-im fcitx-configtool fcitx-sogoupinyin yarn visual-studio-code-bin texmaker sudo pacman -S google-chrome deepin.com.qq.office netease-cloud-music typora vlc wewechat wps-office ttf-wps-fontssudo pacman -S mysql eclipse-jee opencv webstorm clion pycharm-professional intellij-idea-ultimate-edition qtcreator qt4 maven android-studio nginx 配置搜狗环境 1sudo vim ~/.xprofile 添加以下内容 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\" 配置firefox 地址栏输入about:config 搜索intl.locale.requested 将其值修改为zh_CN 配置yarn 123yarn global binsudo vim /etc/profile appendpath &apos;/home/douxl/.yarn/bin&apos; 禁用pcspkr 12sudo rmmod pcspkrsudo vim /etc/modprobe.d/nobeep.conf 输入 1blacklist pcspkr nodejs包 1yarn global add hexo vue-cli pip 1vim ~/.pip/pip.conf 输入以下内容 12345[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com python 包 1sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy pandas sklearn matplotlib requests minepy 配置git 123git config --global user.email &quot;douxl5516@163.com&quot;git config --global user.name &quot;douxl5516&quot;git config --global credential.helper store 与windows时间同步 1timedatectl set-local-rtc 1 SSH 1ssh-keygen -t rsa -C &quot;douxl5516@163.com&quot; WPS字体缺失问题 国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzo 1234sudo cp * /usr/share/fontssudo mkfontscalesudo mkfontdirsudo fc-cache","categories":[{"name":"Linux","slug":"Linux","permalink":"https://douxl5516.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://douxl5516.github.io/tags/Linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://douxl5516.github.io/tags/manjaro/"}]},{"title":"科研中用到的数学基础","slug":"科研中用到的数学基础","date":"2019-05-04T07:09:36.000Z","updated":"2019-07-27T06:08:15.864Z","comments":true,"path":"2019/05/04/科研中用到的数学基础/","link":"","permalink":"https://douxl5516.github.io/2019/05/04/科研中用到的数学基础/","excerpt":"","text":"数学基础 范数 在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。 LP范数不是一个范数，而是一组范数。定义如下： $$ L_p=\\Vert x \\Vert_p=\\sqrt[p]{\\sum_{i=1}^{n}{x_i^p}},x=(x_1,x_2,\\dots,x_n) $$ L0范数表示向量中非零元素的个数。 L1范数表示向量x中非零元素的绝对值之和。定义如下： $$ L_1=\\Vert x \\Vert_1=\\sum_{i=1}^{n}{|x_i|},x=(x_1,x_2,\\dots,x_n) $$ L2范数表示向量元素的平方和再开平方，即欧氏距离。 二范数指矩阵A的2范数，就是A的转置共轭矩阵与矩阵A的积的最大特征根的平方根值，是指空间上两个向量矩阵的直线距离。类似于求棋盘上两点间的直线距离。 定义如下： $$ L_2=\\Vert x \\Vert_2=\\sqrt{\\sum_{i=1}^{n}{x_i^2}},x=(x_1,x_2,\\dots,x_n) $$ 百度百科 几种范数 梯度 即对于一般标量函数$f(x)$ , 其中向量为$x=(x_1,x_2,\\dots,x_n)$，导数为： $$ \\frac{\\partial{f}}{\\partial{x}}=(\\frac{\\partial{f}}{\\partial{x_1}},\\dots,\\frac{\\partial{f}}{\\partial{x_2}}) $$ 雅可比矩阵 在向量微积分中，雅可比矩阵(Jacobi Matrix)是一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。因此，雅可比矩阵类似于多元函数的导数。 $$ J(f)=\\left|\\frac{\\partial{(f_1,\\dots,f_n)}}{\\partial{(x_1,\\dots,x_n)}}\\right|= \\left|\\begin{matrix} \\frac{\\partial{f_1}}{\\partial{x_1}}&amp;\\dots&amp;\\frac{\\partial{f_1}}{\\partial{x_n}}\\ \\vdots&amp;\\ddots&amp;\\vdots\\ \\frac{\\partial{f_n}}{\\partial{x_1}}&amp;\\dots&amp;\\frac{\\partial{f_n}}{\\partial{x_n}}\\ \\end{matrix}\\right| $$ 若m=n，则雅可比矩阵为方阵，方阵的行列式为雅可比行列式。 雅可比矩阵 海森矩阵 黑塞矩阵（Hessian Matrix），又译作海森矩阵、海瑟矩阵、海塞矩阵等，是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。黑塞矩阵最早于19世纪由德国数学家Ludwig Otto Hesse提出，并以其名字命名。黑塞矩阵常用于牛顿法解决优化问题，利用黑塞矩阵可判定多元函数的极值问题。在工程实际问题的优化设计中，所列的目标函数往往很复杂，为了使问题简化，常常将目标函数在某点邻域展开成泰勒多项式来逼近原函数，此时函数在某点泰勒展开式的矩阵形式中会涉及到黑塞矩阵。 $$ H(f)=\\left[\\begin{matrix} \\frac{\\partial^2{f}}{\\partial{x_1^2}}&amp;\\frac{\\partial^2{f}}{\\partial{x_1}\\partial{x_2}}&amp;\\dots&amp;\\frac{\\partial^2{f}}{\\partial{x_1}\\partial{x_n}}\\ \\frac{\\partial^2{f}}{\\partial{x_2}\\partial{x_1}}&amp;\\frac{\\partial^2{f}}{\\partial{x_2^2}}&amp;\\dots&amp;\\frac{\\partial^2{f}}{\\partial{x_2}\\partial{x_n}}\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ \\frac{\\partial^2{f}}{\\partial{x_n}\\partial{x_1}}&amp;\\frac{\\partial^2{f}}{\\partial{x_n}\\partial{x_2}}&amp;\\dots&amp;\\frac{\\partial^2{f}}{\\partial{x_n^2}}\\ \\end{matrix}\\right] $$ 海森矩阵 泰勒公式 数学中，泰勒公式是一个用函数在某点的信息描述其附近取值的公式。如果函数足够平滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值。泰勒公式还给出了这个多项式和实际的函数值之间的偏差。 $$ f(x)=\\frac{f(a)}{0!}+\\frac{f'(a)}{1!}(x-a)+\\frac{f''(a)}{2!}(x-a)^2+\\dots+\\frac{f^n(a)}{n!}(x-a)^n+R_n(x) $$ 李代数 首先特殊正交群SO(3)可以代表旋转矩阵，SE(3)可以代表欧式变换矩阵。矩阵对于乘法封闭，对于加法不封闭，所以具有群的特性。 李群是指具有连续(光滑)性质的群。 外积 $$ \\boldsymbol{a}\\times\\boldsymbol{b}= \\left[ \\begin{matrix} \\boldsymbol{i}&amp;\\boldsymbol{j}&amp;\\boldsymbol{k}\\ a_1&amp;a_2&amp;a_3\\ b_1&amp;b_2&amp;b_3\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} a_2b_3-a_3b_2\\ a_3b_1-a_1b_3\\ a_1b_2-a_2b_1\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} 0&amp;-a_3&amp;a_2\\ a_3&amp;0&amp;-a_1\\ -a_2&amp;a_1&amp;0\\ \\end{matrix} \\right]\\boldsymbol{b}\\triangleq\\boldsymbol{a}^{\\wedge}\\boldsymbol{b} $$ 相应的，有 $$ \\boldsymbol{a}=[a_1\\boldsymbol{i},a_2\\boldsymbol{j},a_3\\boldsymbol{k}],\\ \\boldsymbol{a}^{\\wedge}=\\boldsymbol{A}=\\left[ \\begin{matrix} 0&amp;-a_3&amp;a_2\\ a_3&amp;0&amp;-a_1\\ -a_2&amp;a_1&amp;0\\ \\end{matrix} \\right],\\\\boldsymbol{A}^{\\vee}=\\boldsymbol{a} $$ 特殊正交群 $SO(3)$ $$ SO(3)={R\\in\\mathbb{R}^{3\\times3}|RR^T=I,\\det(R)=1} $$ 特殊欧式群$SE(3)$ $$ SE(3)={T=\\left[ \\begin{matrix} R&amp;t\\ 0^T&amp;1\\ \\end{matrix} \\right]\\in\\mathbb{R}^{4\\times4}|R\\in SO(3),t\\in \\mathbb{R}^3} $$ 李代数$\\mathfrak{so}(3)$ 在对$RR^T=I$进行求导及整理之后，可以得到$R(t)^{'}R(t)^T$是一个反对称矩阵，那么就用一个$\\phi(t)\\in\\mathbb{R}^3$与之对应。有： $$ R(t)^{'}R(t)^T=\\phi(t)^{\\wedge} $$ 之后求解微分方程，可以得到： $$ R(t)=exp(\\phi^{\\wedge}t) $$ 实际求解时利用到指数映射和对数映射。 奇异值分解 参考资料 分解原理 方阵的迹 百度百科词条 在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)。 性质 tr(AB)=tr(BA) tr(ABC)=tr(CAB)=tr(BCA) f(a)=tr(AB)，$\\bigtriangledown_Atr(AB)=B^T$ $tr(A)=tr(A^T)$ tr(a)=a,$a \\in R$ $\\bigtriangledown_Atr(ABA^TC)=CAB+C^TAB^T$ 欧几里得空间、希尔伯特空间 https://blog.csdn.net/weixin_36811328/article/details/81207753 欧拉公式 $e^{ix}=cosx+isinx$ 得到一个模为1的复向量,$x$是向量的角","categories":[{"name":"数学","slug":"数学","permalink":"https://douxl5516.github.io/categories/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://douxl5516.github.io/tags/数学/"},{"name":"笔记","slug":"笔记","permalink":"https://douxl5516.github.io/tags/笔记/"}]},{"title":"CMake入门","slug":"CMake入门","date":"2018-09-13T00:50:21.000Z","updated":"2019-06-11T08:13:41.706Z","comments":true,"path":"2018/09/13/CMake入门/","link":"","permalink":"https://douxl5516.github.io/2018/09/13/CMake入门/","excerpt":"","text":"本文转载自yaoyuanyylyy CMake入门1——CMake与VS编译器和nmake的结合使用 CMake入门2——复杂项目的构建配置 CMake入门3——更多指令的使用 本文描述在Win10-64位系统中安装CMake、cmake-gui的简单使用及其与VS2015编译器的结合使用，以及cmake命令行与nmake的结合使用。 下载 从CMake官网上下载最新版本的安装包，本文中下载的是 cmake-3.10.1-win64-x64.msi。若不想安装，可直接下载压缩包版本cmake-3.10.1-win64-x64.zip。 安装 CMake的安装非常简单。压缩包版本直接解压即可，安装版本也可一直点击下一步进行安装。为了使用方便，可将CMake配置到环境变量中，当然，这一步也可以在安装过程中设置。另外需要注意的是为了避免不必要的麻烦，路径中最好不要包括中文字符。下面简单描述一下安装过程。 双击下载的安装包，进入安装界面，点击[Next]。 勾选同意许可后，点击[Next]。 可在此处选择将CMake路径添加到环境变量中，并且创建CMake GUI程序的桌面快捷方式。然后点击[Next]。 可在此处自定义安装目录，设置好后点击[Next]。 开始安装，安装完成后点击[Next]。 安装完成，点击[Finish]，结束安装过程。 安装完成后，即可使用CMake了。在命令行中输入&quot;cmake --version&quot;，可看到如下图所示的输出。 例1 使用cmake-gui与VS生成器 本例使用cmake-gui和VS生成器构建出VS工程，然后用VS工具打开项目进行编译。 新建CMakeTest目录，在CMakeTest目录下新建demo1目录，作为测试项目的根目录。在demo1下新建main.cpp和CMakeLists.txt文件。 main.cpp文件的内容很简单，就是输出一个提示字符串： 1234567#include &lt;iostream&gt;using namespace std;void main()&#123; cout&lt;&lt;&quot;cmake test demo 1&quot;&lt;&lt;endl; getchar();&#125; CMakeLists文件内容如下： 123456# CMake最低版本要求 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo1)# 指定生成目标add_executable(demo main.cpp) CMakeLists.txt 的语法比较简单，由命令、注释和空格组成。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔，且命令是不区分大小写的。符号 # 后面的内容被认为是注释。 对于上面的 CMakeLists.txt 文件，依次出现了几个命令： cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本，如果低于3.10.1版本，则构建过程会被终止 project：参数值是 demo1，该命令表示项目的名称是 demo1 add_executable： 将名为 main.cpp 的源文件编译成一个名称为 demo 的可执行文件 打开cmake-gui程序，在上方配置两个目录: 第一个是CMakeLists文件目录，cmake据此开始执行 第二个是cmake构建后的项目目录 配置好点击[Configure]开始执行配置过程。首先会弹出编译器选择界面，此处使用默认的VS2015-32位编译器，直接点击[Finish]，开始配置。 第一次配置完成后如图所示，红色的两行是新的配置值，再次点击[Configure]即可。 配置完成后，在build目录生成了如下的文件 点击[Generate]，开始生成VS项目 生成完成后，在build目录下生成了demo1对于的VS项目 通过点击cmake-gui中下放的[Open Project]按钮或者直接双击build目录下的demo1.sln，即可在VS中打开工程。 cmake生的demo1工程总共有3个项目 ZERO_CHECK：该项目会检查生成工程的 CMake 配置文件（ CMakeLists.txt ）是否更新。如更新，将运行 CMake 重新生成工程文件。如果确信 CMakeLists.txt 不会被更新，或者希望手工运行 CMake 重新生成工程文件，可以在 CMakeLists.txt 配置文件中添加 set(CMAKE_SUPPRESS_REGENERATION FALSE) 命令， ZERO_CHECK 目标将不会生成。 ALL_BUILD：该目标会导致工程中所有项目被构建，类似 Visual Studio 的 Build All 或者 make 的 make all命令。 demo：项目本身，就是在CMakeLists.txt文件中配置的project(demo1) 在VS中通过单独生成项目demo1或者直接生成项目All_BUILD后，可以在build下的相应目录看到可执行文件demo.exe已经生成。双击demo.exe后，可以看到程序输出。 如果不想用VS打开工程，也可以使用msbuild.exe编译demo1工程。首先需要打开VS命令行，因为cmake-gui中选择的编译器是32位的，所以此处选择”VS2015 x86 本机工具命令提示符”。 打开后在命令行中进入到demo1的build目录，执行msbuild demo1.sln即可编译demo1项目。编译完成后可以在debug中看到生成的demo.exe文件，双击可运行。 例2 使用cmake命令与nmake生成器 本例使用cmake命令行与nmake生成器构建Makefile，然后用nmake编译项目。 新建项目demo2，将demo1中的main.cpp和CMakeLists.txt文件拷贝过来。将CMakeLists.txt文件中的project项目配置为demo2。 2. 同样从VS命令行进入到demo2目录，执行命令： 1cmake -G \"NMake Makefiles\" . 执行完毕后，即可看到在demo2目录中生成了一些文件： 其中重要的是Makefile文件，这是用来编译项目的。在命令行中继续执行nmake命令开始编译，编译完成后可以看到在demo2目录生成了demo.exe程序。允许后可以看到输出。 例3 PreLoad.cmake用法 在命令行下使用cmake，需要用”-G”选项指定生成器。每次都输入感觉比较麻烦，可以将其配置在”PreLoad.cmake”文件中。新建项目demo3，准备好main.cpp和CMakeLists.txt文件，然后demo3目录下新建文件”PreLoad.cmake”，输入： 1set(CMAKE_GENERATOR \"NMake Makefiles\" CACHE INTERNAL \"\" FORCE) 然后执行&quot;cmake .&quot;即可配置，然后执行&quot;nmake&quot;就可以编译。 例4 多文件单目录测试 此测试项目将所有的文件都放在根目录下。 在CMakeTest目录下新建demo4目录。demo4项目文件列表如下： 其中实现了算术运算的加减乘除，每个功能分别实现在各自的文件中： 1234int my_add(int a, int b);int my_minus(int a, int b);int my_multiply(int a, int b);int my_divide(int a, int b); 然后在main.cpp中调用各个函数，代码如下： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;#include \"add.h\"#include \"minus.h\"#include \"multiply.h\"#include \"divide.h\"void main()&#123; cout&lt;&lt;\"cmake test demo 4\"&lt;&lt;endl; int a=20; int b=10; cout&lt;&lt;a&lt;&lt;\"+\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;my_add(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"-\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;my_minus(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"*\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;my_multiply(a, b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"/\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;my_divide(a, b)&lt;&lt;endl; getchar();&#125; CMakeLists.txt文件内容如下： 1234567891011# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo4)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;) 此配置文件中使用了一条新命令： aux_source_directory：该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。这样，就不用在add_executable中列出所有源文件了，而是直接引用变量即可。 从VC命令行进入到demo4目录，然后执行cmake命令和nmake命令，即可编译出执行程序。 例5 多文件单子目录测试 此测试项目将main入口函数文放在根目录下，其他文件放在独立目录下。 新建demo5目录，使用例3中的项目文件，将main.cpp放在demo5目录下，将其他的加减乘除的相关文件放在math子目录下。然后在demo5目录和math目录下分别放一个CMakeLists.txt文件。 其中demo5目录下的CMakeLists.txt文件内容如下： 1234567891011121314151617181920# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo5)# 添加头文件目录include_directories(math)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;)# 添加math子目录add_subdirectory(math)# 添加链接库target_link_libraries(demo math) 在这个配置文件中，依次出现了几条新的cmake命令： include_directories：头文件包含目录，因为main.cpp中使用了加减乘除函数，因此需要指明头文件目录所在之处。当然，也可以在main.cpp中包含都文件时指定目录 add_subdirectory：添加子目录命令，表示需要编译该子目录 target_link_libraries：添加要依赖的库文件，此处的math库是在子目录math中编译出来的 math目录下的CMakeLists.txt文件内容如下： 12345678# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_LIB_SRCS)# 指定生成目标add_library(math $&#123;DIR_LIB_SRCS&#125;) 在上面这个配置文件中，出现了一条新命令： add_library：将指定的文件编译为库，前面是库名称，后面是源文件 进demo5目录，然后执行cmake命令和nmake命令，即可编译出执行程序。可以看到，在math子目录下生成了一个”math.lib”的库文件。 例6 多目录和多级目录测试 本例子demo6中把加减乘除四个运算分散在不同的目录下，形成了多个目录、多级目录的形式。具体的文件布局如下图所示： 多个子目录和多级目录在用cmake来构建时的一种方式是：将所有源文件按功能或目录来分别构建为库，然后在需要用到库的地方链接上所需的一个或多个库。 对于此例来说，各目录的说明和构建方式如下： demo6根目录下包括了math和divide两个目录； divide目录是除法目录，由其目录中的配置文件单独构建为一个库； math目录包括了add_minus和multiply两个目录； add_minus目录包括加法的实现文件和减法目录minus; 减法不单独构建为库，而是和加法一起，用add_minus中的配置文件构建为一个库； 乘法的库也不再它自己的目录中构建，而是在math目录下构建为单独的乘法库； 最后，在demo6根目录下的配置文件中构建demo.exe程序，并连接了乘法库、除法库、加减法合在一起的库； 首先，divide目录下构建除法库的配置文件比较简单，使用了 aux_source_directory 和add_library两条指令。 12345678# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_LIB_DIVIDE_SRCS变量中aux_source_directory(. DIR_LIB_DIVIDE_SRCS)# 指定生成目标add_library(lib_divide $&#123;DIR_LIB_DIVIDE_SRCS&#125;) 其次，加减法库的构建如下： 12345678910# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 查找当前目录下的所有源文件，并将名称保存到DIR_MINUS_SRCS变量中aux_source_directory(./minus DIR_MINUS_SRCS)# 把要编译的文件都列在此处，存入ADD_SRCS变量中set(ADD_SRCS add.cpp)# 指定生成目标add_library(lib_add_minus $&#123;ADD_SRCS&#125; $&#123;DIR_MINUS_SRCS&#125;) 这个也很简单，只是有3点小改变： aux_source_directory指令中指定的目录为./minus，表示当前文件夹下的minus子目录，也就是把minus子目录下的减法源文件存在了DIR_MINUS_SRCS变量中 使用了一条新的指令set，这也是一条用来设置变量的，不过变量放在前面，变量的值放在后面。这里指定为将当前目录下的加法实现源文件存入变量ADD_SRCS中。需注意的是，后面的文件可以列出多个各处的文件 在add_library命令将前面的两个保存了加法和减法源文件的变量一起用来生成一个库lib_add_minus 再次，math目录下的配置文件如下： 1234567891011# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 添加子目录add_subdirectory(add_minus)# 把要编译的文件都列在此处，存入DIR_MULTIPLY_SRC变量中set(DIR_MULTIPLY_SRC multiply/multiply.cpp)# 指定生成目标add_library(lib_multiply $&#123;DIR_MULTIPLY_SRC&#125;) 在这个配置文件中，将multiply目录下的乘法编译成了单独的一个库，然后添加了add_minus子目录。所用的指令都是已使用过的。 最后，根目录demo6下的配置文件如下： 123456789101112131415161718192021222324# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo6)# 添加头文件目录include_directories(math/add_minus math/add_minus/minus math/multiply)include_directories(divide)# 查找当前目录下的所有源文件，并将名称保存到DIR_SRCS变量中aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(demo $&#123;DIR_SRCS&#125;)# 添加math子目录add_subdirectory(math)# 添加divide子目录add_subdirectory(divide)# 添加链接库target_link_libraries(demo lib_add_minus)target_link_libraries(demo lib_multiply lib_divide) 在这个配置文件中，有几点小说明： 这个根目录下的配置文件为cmake的入口配置文件，所以在其中指定了最低版本。这样其实在子目录下的配置文件中就可以不用再用cmake_minimum_required指令了 用include_directories指令指明了头文件所在目录，一条命令中可以指定多个头文件包含目录。在实际项目中可将头文件提取到一个目录中，然后指定一个目录就可以了 用add_subdirectory指明了divide和math两个子目录 用target_link_libraries将各个库连接到目标程序”demo”中，此命令也可以一次指定多个库。 至此，所有的工作就做好了，在命令下执行cmake命令和nmake命令，就可编译出执行程序。同时可以看到，在math子目录下生成了一个”lib_multiply.lib”库，在math/add_minus目录下生成了一个lib_add_minus.lib库，在divide目录下生成了lib_divide库。 基本语法规则 从前面的几个例子中，我们使用了cmake的几条基本指令，在这里，总结一下： cmake由指令、注释和空白字符组成 以#开头，到行末尾的是注释 形如指令(参数1 参数2 参数3 ...)的是指令，参数间使用空格或者分号;隔开 指令不区分大小写，但参数是区分大小写的 cmake中可以设置变量，变量的引用方式为**${变量名}** cmake的构建指令为**&quot;cmake path [参数选项]&quot;；当前我们都使用的是“cmake .”**，表示构建当前目录下的项目 内部构建与外部构建 在前面的例子中，danger构建项目后，会发现cmake构建过程中产生的中间文件和项目文件混在一起，多了就不好区分；而且cmake不能跟踪这些中间文件，所以也没有一条可以清除它们的指令。 这样的情况是因为我们使用的是cmake的内部构建，而cmake提供的另外一种称为外部构建的构建方式，可以解决这个问题。 内部构建：in-source build，在项目的入口配置文件目录下执行**“cmake .”**时，就是内部构建；这种方式下，生成的临时中间文件就放在了构建目录下，导致和源文件混在一起 外部构建：out-of-source build，在其他目录下执行cmake构建命令，然后指定入口配置文件的目录，这样就可以将临时文件存放于单独的目录中。比如我们在项目下新建一个build目录，然后在build目录下执行**“cmake ..”**，那么我们就可以看到构建后的所有临时文件都产生在build目录中，这样就方便我们管理和清理了 例7 外部构建以及**&quot;project&quot;和&quot;message&quot;**指令 首先，我们新建一个项目demo7，其中的源文件和demo6的是一样的，唯一的区别只有demo7根目录下的CMakeLists.txt文件不同，我们添加了几条**&quot;message&quot;**指令，这是用来在构建过程中显示消息的。 配置文件的前面部分如下： 12345678910111213# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo7)message(STATUS \"the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;\")message(STATUS \"the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;\")message(STATUS \"the BINARY dir is $&#123;demo7_BINARY_DIR&#125;\")message(STATUS \"the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;\")# ... 后面的没有改变，此处省略不显示 因为要采用外部构建的方式，因此我们先新建一个build目录，然后在build目录下执行cmake构建指令。过程如下： 可以从以一个红框中看到外部构建的一般过程。这里我们来看看第二个红框中的输出内容，这就是**&quot;message&quot;**指令的输出。 **&quot;message&quot;**指令的语法如下： 1message([SEND_ERROR | STATUS | FATAL_ERROR] \"message\" ...) 第一个参数是消息类型，后面的参数是一条或多条要显示的消息。错误类型有3种： SEND_ERROR：表示产生错误信息 STATUS：表示一般的状态信息 FATAL_ERROR：我们知道肯定是严重错误信息，cmake会立即停止执行 参数个数： 一条消息显示指令后可以跟上多条消息，它们会依次连在一起进行显示 我们修改一下前面的配置文件如下： 12345678910111213141516# CMake最低版本要求，如果低于3.10.1版本，则构建过程会被终止 cmake_minimum_required(VERSION 3.10.1)# 项目信息project(demo7)message(STATUS \"------------------------------\" \"this is \" \"another message\")message(STATUS \"the BINARY dir is $&#123;PROJECT_BINARY_DIR&#125;\")message(STATUS \"------------------------------\")message(SEND_ERROR \"the SOURCE dir is $&#123;PROJECT_SOURCE_DIR&#125;\")message(STATUS \"------------------------------\")message(STATUS \"the BINARY dir is $&#123;demo7_BINARY_DIR&#125;\")message(STATUS \"------------------------------\")message(FATAL_ERROR \"the SOURCE dir is $&#123;demo7_SOURCE_DIR&#125;\")message(STATUS \"------------------------------\") 在每条消息前后我们用分割线分割开，构建后，可以看到消息显示如下： 第一个红框中的是前两条消息，其中第一条消息的多个消息是连续显示的；第二个红框中的是”SEND_ERROR”类型的错误消息，cmake会提示错误所在的行，然后项目会继续构建；最后一个红框中的是”FATAL_ERROR”类型的消息，cmake首先也输出了错误消息，然后便中止了构建过程。 下面我们来关注一下这个配置文件中在message指令中使用的几个变量： ${PROJECT_BINARY_DIR} ${PROJECT_SOURCE_DIR} ${demo6_BINARY_DIR} ${demo6_SOURCE_DIR} 首先，&quot;project&quot; 指令在使用后会定义两个隐式的变量 &quot;PROJECT_BINARY_DIR&quot; 和 &quot;PROJECT_SOURCE_DIR&quot;。从输出的消息我们也可以看到，前者就是我们执行构建命令时所在的目录，也是我们的中间文件存放的目录；后者就是我们的配置文件和源文件所在的目录。 同时，因为用 &quot;project&quot; 指令将项目名称指定为 &quot;demo7&quot; ，所以这两个变量中的”PROJECT”部分也可以中”demo7来代替。但是，不推荐用这种方式。 另外，当我们使用内部构建时，这两个变量的值是一样的。 最后，这两个值和我们使用cmake-gui时，要设置的两个目录是相对应的。","categories":[{"name":"CMake","slug":"CMake","permalink":"https://douxl5516.github.io/categories/CMake/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://douxl5516.github.io/tags/CMake/"}]},{"title":"Java平台下Opencv图像展示的简便实现","slug":"Java平台下Opencv图像展示的简便实现","date":"2018-08-12T13:21:14.000Z","updated":"2019-06-11T08:13:22.914Z","comments":true,"path":"2018/08/12/Java平台下Opencv图像展示的简便实现/","link":"","permalink":"https://douxl5516.github.io/2018/08/12/Java平台下Opencv图像展示的简便实现/","excerpt":"","text":"在C++环境下的OpenCV中，展示Mat图像可以通过imshow()实现。但在Java平台上该怎样简便地实现呢？ 通常的做法是将读取到的Mat转化为BufferedImage，将BufferedImage作为GUI中的icon进行展示。下方是将Mat转化为BufferedImage的代码。 12345678910111213141516171819202122/** * Mat转换成BufferedImage * * @param matrix 要转换的Mat * @param fileExtension 格式为 \".jpg\", \".png\", etc * @return 转换后的BufferedImage */ public static BufferedImage Mat2BufferedImage (Mat matrix, String fileExtension) &#123; // convert the matrix into a matrix of bytes appropriate for this file extension MatOfByte mob = new MatOfByte(); Imgcodecs.imencode(fileExtension, matrix, mob); // convert the \"matrix of bytes\" into a byte array byte[] byteArray = mob.toArray(); BufferedImage bufImage = null; try &#123; InputStream in = new ByteArrayInputStream(byteArray); bufImage = ImageIO.read(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bufImage; &#125; 这里提供一种简单的方法，实现了类似C++的图像展示方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.awt.Graphics;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.BufferedImage;import javax.swing.JFrame;import javax.swing.JPanel;import org.opencv.core.Mat;public class ImageUI extends JPanel implements KeyListener &#123; public ImageUI(Mat m, String window) &#123; super(); init(m, window); &#125; //Elements for paint. private Mat mat; private boolean firstPaint = true; private BufferedImage out; int type; private String WINDOW = \"\"; private JFrame jframe = new JFrame(); byte[] data; private void Mat2BufIm()&#123; mat.get(0, 0, data); out.getRaster().setDataElements(0, 0, mat.cols(), mat.rows(), data); &#125; private void init(Mat m,String window)&#123; this.mat = m; data = new byte[mat.cols() * mat.rows() * (int)mat.elemSize()]; WINDOW = window; if(mat.channels() == 1) type = BufferedImage.TYPE_BYTE_GRAY; else type = BufferedImage.TYPE_3BYTE_BGR; out = new BufferedImage(mat.cols(), mat.rows(), type); Mat2BufIm(); jframe.add(this); jframe.setSize(mat.cols(), mat.rows()); jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jframe.setTitle(WINDOW); jframe.addKeyListener(this); &#125; @Override public void paintComponent(Graphics g) &#123; g.drawImage(out, 0, 0, null); &#125; public ImageUI imshow()&#123; if(firstPaint)&#123; jframe.setVisible(true); firstPaint = false; &#125; Mat2BufIm(); this.repaint(); return this; &#125; //Elements for waitKey. private static Object mt = new Object(); private static int lastKey = 0; private static int key = 0; public static int waitKey(int millisecond)&#123; //TODO 实现监听键盘 try &#123; if(millisecond == 0)&#123; synchronized(mt)&#123; mt.wait(); &#125; &#125; Thread.sleep(millisecond); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; int ret = -1; if(key != lastKey)&#123; ret = key; lastKey = key; &#125; return ret; &#125; @Override public void keyPressed(KeyEvent e) &#123; synchronized(mt)&#123; mt.notifyAll(); &#125; this.key = e.getKeyCode(); &#125; @Override public void keyReleased(KeyEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent arg0) &#123; // TODO Auto-generated method stub &#125; &#125; 在项目中添加上面的源码后，可以通过以下方式实现图像的展示： 12345Mat mat = Mat.eye(1000, 2000, CvType.CV_8UC3);String window_name = \"mat\"ImageUI ig = new ImageGui(mat,window_name);ig.imshow();ig.waitKey(0); 或者，可以通过另一种简单的方法实现： 12Mat mat = Mat.eye(1000, 2000, CvType.CV_8UC3);new ImageGui(mat,\"mat\").imshow().waitKey(0);","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://douxl5516.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://douxl5516.github.io/tags/OpenCV/"},{"name":"Java","slug":"Java","permalink":"https://douxl5516.github.io/tags/Java/"}]},{"title":"Java下OpenCV中Mat的初始化及赋值方法","slug":"Java下OpenCV中Mat的初始化及赋值方法","date":"2018-08-08T14:54:20.000Z","updated":"2019-06-11T08:13:02.896Z","comments":true,"path":"2018/08/08/Java下OpenCV中Mat的初始化及赋值方法/","link":"","permalink":"https://douxl5516.github.io/2018/08/08/Java下OpenCV中Mat的初始化及赋值方法/","excerpt":"","text":"利用函数构造特殊Mat 12A = Mat.eye(3,3, CvType.CV_64FC1);A = Mat.zero(3,3,CvType.CV_64FC1); 诸如MatOfDouble之类的矩阵，还支持将矩阵转换为List或者从List（array）转换成矩阵。所以可以直接这样创建矩阵： 1MatOfDouble A = new MatOfDouble(1,2,3,4,5,6,7,8,9); 或者 12MatOfDouble A = new MatOfDouble();A.fromArray(1,2,3,4,5,6,7,8,9); 这样得到的矩阵实际上是一个列向量，也就是$91$的矩阵。如果想得到一个$33$的矩阵，可以使用reshape。 1A.reshape(1,3); 注意这里第一个参数为通道数，第二个参数为行数","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://douxl5516.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://douxl5516.github.io/tags/OpenCV/"},{"name":"Java","slug":"Java","permalink":"https://douxl5516.github.io/tags/Java/"}]},{"title":"Windows远程桌面连接阿里云Ubuntu服务器","slug":"Windows远程桌面连接阿里云Ubuntu服务器","date":"2018-08-02T11:06:10.000Z","updated":"2019-06-11T08:12:39.769Z","comments":true,"path":"2018/08/02/Windows远程桌面连接阿里云Ubuntu服务器/","link":"","permalink":"https://douxl5516.github.io/2018/08/02/Windows远程桌面连接阿里云Ubuntu服务器/","excerpt":"","text":"本地Windows远程桌面连接阿里云Ubuntu 16.04服务器: 1、目的:希望通过本地的Windows远程桌面连接到阿里云的Ubuntu服务器,通过远程桌面图形界面的方式操作服务器。 2、条件:申请的阿里云Ubuntu服务器一台,本地Windows操作系统电脑一台。 3、如何远程桌面连接: (1)首先通过Windows系统下连接Linux系统的命令行工具连接Ubuntu服务器,(工具:xshell,securecrt,putty等)。 (2)通过Windows下工具连接到linux操作系统,之后打开命令窗口,切换到root权限。 (3)先安装更新:apt-get upate。 (4)安装xrdp:输入apt-get install xrdp--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车,安装完成。 (xrdp: An open source remote desktop protocol(rdp) server) (5)安装vnc4server:输入apt-get install vnc4server&quot;--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车,安装完成。 (VNC (Virtual Network Console)是虚拟网络控制台的缩写) (6)安装xfce4:输入apt-get install xubuntu-desktop&quot;--&gt;回车--&gt;输入&quot;y&quot;--&gt;回车。 --&gt;输入echo &quot;xfce4-session&quot; &gt;~/.xsession--&gt;回车--&gt;输入 service xrdp restart--&gt;回车,安装完成。 (Xfce是一个自由软件,运行在类Unix操作系统 (如Linux、FreeBSD 和 Solaris)上,提供轻量级桌面环境。) (7)在本地Windows电脑上,使用&quot;窗口键+R&quot;打开&quot;运行对话框&quot;--&gt;输入&quot;mstsc&quot;--&gt;回车--&gt;输入Ubuntu主机的IP地址--&gt;&quot;连接&quot;。 (8)选择&quot;sesman-Xvnc&quot;--&gt;输入&quot;用户名和密码&quot;--&gt;回车,成功登录到Ubuntu桌面,现在可以进行远程操作了。","categories":[{"name":"云服务器","slug":"云服务器","permalink":"https://douxl5516.github.io/categories/云服务器/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://douxl5516.github.io/tags/云服务器/"},{"name":"Linux","slug":"Linux","permalink":"https://douxl5516.github.io/tags/Linux/"}]}]}